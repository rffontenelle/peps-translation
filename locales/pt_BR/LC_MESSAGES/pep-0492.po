# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0492.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-0492.rst:3
msgid "Yury Selivanov <yury@edgedb.com>"
msgstr ""

#: ../../peps/pep-0492.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/pep-0492.rst:4
msgid "python-dev@python.org"
msgstr ""

#: ../../peps/pep-0492.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-0492.rst:5
msgid "Final"
msgstr ""

#: ../../peps/pep-0492.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-0492.rst:6
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0492.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-0492.rst:8
msgid "09-Apr-2015"
msgstr ""

#: ../../peps/pep-0492.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0492.rst:9
msgid "3.5"
msgstr ""

#: ../../peps/pep-0492.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-0492.rst:10
msgid "17-Apr-2015, 21-Apr-2015, 27-Apr-2015, 29-Apr-2015, 05-May-2015"
msgstr ""

#: ../../peps/pep-0492.rst:14
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0492.rst:16
msgid ""
"The growth of Internet and general connectivity has triggered the "
"proportionate need for responsive and scalable code.  This proposal aims "
"to answer that need by making writing explicitly asynchronous, concurrent"
" Python code easier and more Pythonic."
msgstr ""

#: ../../peps/pep-0492.rst:21
msgid ""
"It is proposed to make *coroutines* a proper standalone concept in "
"Python, and introduce new supporting syntax.  The ultimate goal is to "
"help establish a common, easily approachable, mental model of "
"asynchronous programming in Python and make it as close to synchronous "
"programming as possible."
msgstr ""

#: ../../peps/pep-0492.rst:27
msgid ""
"This PEP assumes that the asynchronous tasks are scheduled and "
"coordinated by an Event Loop similar to that of stdlib module "
"``asyncio.events.AbstractEventLoop``.  While the PEP is not tied to any "
"specific Event Loop implementation, it is relevant only to the kind of "
"coroutine that uses ``yield`` as a signal to the scheduler, indicating "
"that the coroutine will be waiting until an event (such as IO) is "
"completed."
msgstr ""

#: ../../peps/pep-0492.rst:35
msgid ""
"We believe that the changes proposed here will help keep Python relevant "
"and competitive in a quickly growing area of asynchronous programming, as"
" many other languages have adopted, or are planning to adopt, similar "
"features: [2]_, [5]_, [6]_, [7]_, [8]_, [10]_."
msgstr ""

#: ../../peps/pep-0492.rst:42
msgid "API Design and Implementation Revisions"
msgstr ""

#: ../../peps/pep-0492.rst:44
msgid ""
"Feedback on the initial beta release of Python 3.5 resulted in a redesign"
" of the object model supporting this PEP to more clearly separate native "
"coroutines from generators - rather than being a new kind of generator, "
"native coroutines are now their own completely distinct type (implemented"
" in [17]_)."
msgstr ""

#: ../../peps/pep-0492.rst:50
msgid ""
"This change was implemented based primarily due to problems encountered "
"attempting to integrate support for native coroutines into the Tornado "
"web server (reported in [18]_)."
msgstr ""

#: ../../peps/pep-0492.rst:54
msgid "In CPython 3.5.2, the ``__aiter__`` protocol was updated."
msgstr ""

#: ../../peps/pep-0492.rst:56
msgid ""
"Before 3.5.2, ``__aiter__`` was expected to return an *awaitable* "
"resolving to an *asynchronous iterator*.  Starting with 3.5.2, "
"``__aiter__`` should return asynchronous iterators directly."
msgstr ""

#: ../../peps/pep-0492.rst:60
msgid ""
"If the old protocol is used in 3.5.2, Python will raise a "
"``PendingDeprecationWarning``."
msgstr ""

#: ../../peps/pep-0492.rst:63
msgid ""
"In CPython 3.6, the old ``__aiter__`` protocol will still be supported "
"with a ``DeprecationWarning`` being raised."
msgstr ""

#: ../../peps/pep-0492.rst:66
msgid ""
"In CPython 3.7, the old ``__aiter__`` protocol will no longer be "
"supported: a ``RuntimeError`` will be raised if ``__aiter__`` returns "
"anything but an asynchronous iterator."
msgstr ""

#: ../../peps/pep-0492.rst:70
msgid "See [19]_ and [20]_ for more details."
msgstr ""

#: ../../peps/pep-0492.rst:74
msgid "Rationale and Goals"
msgstr ""

#: ../../peps/pep-0492.rst:76
msgid ""
"Current Python supports implementing coroutines via generators (PEP 342),"
" further enhanced by the ``yield from`` syntax introduced in PEP 380. "
"This approach has a number of shortcomings:"
msgstr ""

#: ../../peps/pep-0492.rst:80
msgid ""
"It is easy to confuse coroutines with regular generators, since they "
"share the same syntax; this is especially true for new developers."
msgstr ""

#: ../../peps/pep-0492.rst:83
msgid ""
"Whether or not a function is a coroutine is determined by a presence of "
"``yield``  or ``yield from`` statements in its *body*, which can lead to "
"unobvious errors when such statements appear in or disappear from "
"function body during refactoring."
msgstr ""

#: ../../peps/pep-0492.rst:88
msgid ""
"Support for asynchronous calls is limited to expressions where ``yield`` "
"is allowed syntactically, limiting the usefulness of syntactic features, "
"such as ``with`` and ``for`` statements."
msgstr ""

#: ../../peps/pep-0492.rst:92
msgid ""
"This proposal makes coroutines a native Python language feature, and "
"clearly separates them from generators.  This removes generator/coroutine"
" ambiguity, and makes it possible to reliably define coroutines without "
"reliance on a specific library.  This also enables linters and IDEs to "
"improve static code analysis and refactoring."
msgstr ""

#: ../../peps/pep-0492.rst:98
msgid ""
"Native coroutines and the associated new syntax features make it possible"
" to define context manager and iteration protocols in asynchronous terms."
" As shown later in this proposal, the new ``async with`` statement lets "
"Python programs perform asynchronous calls when entering and exiting a "
"runtime context, and the new ``async for`` statement makes it possible to"
" perform asynchronous calls in iterators."
msgstr ""

#: ../../peps/pep-0492.rst:107
msgid "Specification"
msgstr ""

#: ../../peps/pep-0492.rst:109
msgid ""
"This proposal introduces new syntax and semantics to enhance coroutine "
"support in Python."
msgstr ""

#: ../../peps/pep-0492.rst:112
msgid ""
"This specification presumes knowledge of the implementation of coroutines"
" in Python (:pep:`342` and :pep:`380`).  Motivation for the syntax "
"changes proposed here comes from the asyncio framework (:pep:`3156`) and "
"the \"Cofunctions\" proposal (:pep:`3152`, now rejected in favor of this "
"specification)."
msgstr ""

#: ../../peps/pep-0492.rst:118
msgid ""
"From this point in this document we use the word *native coroutine* to "
"refer to functions declared using the new syntax.  *generator-based "
"coroutine* is used where necessary to refer to coroutines that are based "
"on generator syntax.  *coroutine* is used in contexts where both "
"definitions are applicable."
msgstr ""

#: ../../peps/pep-0492.rst:126
msgid "New Coroutine Declaration Syntax"
msgstr ""

#: ../../peps/pep-0492.rst:128
msgid "The following new syntax is used to declare a *native coroutine*::"
msgstr ""

#: ../../peps/pep-0492.rst:133
msgid "Key properties of *coroutines*:"
msgstr ""

#: ../../peps/pep-0492.rst:135
msgid ""
"``async def`` functions are always coroutines, even if they do not "
"contain ``await`` expressions."
msgstr ""

#: ../../peps/pep-0492.rst:138
msgid ""
"It is a ``SyntaxError`` to have ``yield`` or ``yield from`` expressions "
"in an ``async`` function."
msgstr ""

#: ../../peps/pep-0492.rst:141
msgid "Internally, two new code object flags were introduced:"
msgstr ""

#: ../../peps/pep-0492.rst:143
msgid ""
"``CO_COROUTINE`` is used to mark *native coroutines* (defined with new "
"syntax)."
msgstr ""

#: ../../peps/pep-0492.rst:146
msgid ""
"``CO_ITERABLE_COROUTINE`` is used to make *generator-based coroutines* "
"compatible with *native coroutines* (set by `types.coroutine()`_ "
"function)."
msgstr ""

#: ../../peps/pep-0492.rst:150
msgid ""
"Regular generators, when called, return a *generator object*; similarly, "
"coroutines return a *coroutine* object."
msgstr ""

#: ../../peps/pep-0492.rst:153
msgid ""
"``StopIteration`` exceptions are not propagated out of coroutines, and "
"are replaced with a ``RuntimeError``.  For regular generators such "
"behavior requires a future import (see :pep:`479`)."
msgstr ""

#: ../../peps/pep-0492.rst:157
msgid ""
"When a *native coroutine* is garbage collected, a ``RuntimeWarning`` is "
"raised if it was never awaited on (see also `Debugging Features`_)."
msgstr ""

#: ../../peps/pep-0492.rst:161
msgid "See also `Coroutine objects`_ section."
msgstr ""

#: ../../peps/pep-0492.rst:165
msgid "types.coroutine()"
msgstr ""

#: ../../peps/pep-0492.rst:167
msgid ""
"A new function ``coroutine(fn)`` is added to the ``types`` module.  It "
"allows interoperability between existing *generator-based coroutines* in "
"asyncio and *native coroutines* introduced by this PEP::"
msgstr ""

#: ../../peps/pep-0492.rst:176
msgid ""
"The function applies ``CO_ITERABLE_COROUTINE`` flag to generator-"
"function's code object, making it return a *coroutine* object."
msgstr ""

#: ../../peps/pep-0492.rst:179
msgid ""
"If ``fn`` is not a *generator function*, it is wrapped.  If it returns a "
"*generator*, it will be wrapped in an *awaitable* proxy object (see below"
" the definition of awaitable objects)."
msgstr ""

#: ../../peps/pep-0492.rst:183
msgid ""
"Note, that the ``CO_COROUTINE`` flag is not applied by "
"``types.coroutine()`` to make it possible to separate *native coroutines*"
" defined with new syntax, from *generator-based coroutines*."
msgstr ""

#: ../../peps/pep-0492.rst:189
msgid "Await Expression"
msgstr ""

#: ../../peps/pep-0492.rst:191
msgid ""
"The following new ``await`` expression is used to obtain a result of "
"coroutine execution::"
msgstr ""

#: ../../peps/pep-0492.rst:198
msgid ""
"``await``, similarly to ``yield from``, suspends execution of "
"``read_data`` coroutine until ``db.fetch`` *awaitable* completes and "
"returns the result data."
msgstr ""

#: ../../peps/pep-0492.rst:202
msgid ""
"It uses the ``yield from`` implementation with an extra step of "
"validating its argument.  ``await`` only accepts an *awaitable*, which "
"can be one of:"
msgstr ""

#: ../../peps/pep-0492.rst:206
msgid "A *native coroutine* object returned from a *native coroutine function*."
msgstr ""

#: ../../peps/pep-0492.rst:209
msgid ""
"A *generator-based coroutine* object returned from a function decorated "
"with ``types.coroutine()``."
msgstr ""

#: ../../peps/pep-0492.rst:212
msgid "An object with an ``__await__`` method returning an iterator."
msgstr ""

#: ../../peps/pep-0492.rst:214
msgid ""
"Any ``yield from`` chain of calls ends with a ``yield``.  This is a "
"fundamental mechanism of how *Futures* are implemented.  Since, "
"internally, coroutines are a special kind of generators, every ``await`` "
"is suspended by a ``yield`` somewhere down the chain of ``await`` calls "
"(please refer to :pep:`3156` for a detailed explanation)."
msgstr ""

#: ../../peps/pep-0492.rst:221
msgid ""
"To enable this behavior for coroutines, a new magic method called "
"``__await__`` is added.  In asyncio, for instance, to enable *Future* "
"objects in ``await`` statements, the only change is to add ``__await__ = "
"__iter__`` line to ``asyncio.Future`` class."
msgstr ""

#: ../../peps/pep-0492.rst:226
msgid ""
"Objects with ``__await__`` method are called *Future-like* objects in the"
" rest of this PEP."
msgstr ""

#: ../../peps/pep-0492.rst:229
msgid "It is a ``TypeError`` if ``__await__`` returns anything but an iterator."
msgstr ""

#: ../../peps/pep-0492.rst:232
msgid ""
"Objects defined with CPython C API with a ``tp_as_async.am_await`` "
"function, returning an *iterator* (similar to ``__await__`` method)."
msgstr ""

#: ../../peps/pep-0492.rst:235
msgid ""
"It is a ``SyntaxError`` to use ``await`` outside of an ``async def`` "
"function (like it is a ``SyntaxError`` to use ``yield`` outside of "
"``def`` function)."
msgstr ""

#: ../../peps/pep-0492.rst:239
msgid ""
"It is a ``TypeError`` to pass anything other than an *awaitable* object "
"to an ``await`` expression."
msgstr ""

#: ../../peps/pep-0492.rst:244
msgid "Updated operator precedence table"
msgstr ""

#: ../../peps/pep-0492.rst:246
msgid "``await`` keyword is defined as follows::"
msgstr ""

#: ../../peps/pep-0492.rst:251
msgid ""
"where \"primary\" represents the most tightly bound operations of the "
"language.  Its syntax is::"
msgstr ""

#: ../../peps/pep-0492.rst:256
msgid ""
"See Python Documentation [12]_ and `Grammar Updates`_ section of this "
"proposal for details."
msgstr ""

#: ../../peps/pep-0492.rst:259
msgid ""
"The key ``await`` difference from ``yield`` and ``yield from`` operators "
"is that *await expressions* do not require parentheses around them most "
"of the times."
msgstr ""

#: ../../peps/pep-0492.rst:263
msgid ""
"Also, ``yield from`` allows any expression as its argument, including "
"expressions like ``yield from a() + b()``, that would be parsed as "
"``yield from (a() + b())``, which is almost always a bug.  In general, "
"the result of any arithmetic operation is not an *awaitable* object. To "
"avoid this kind of mistakes, it was decided to make ``await`` precedence "
"lower than ``[]``, ``()``, and ``.``, but higher than ``**`` operators."
msgstr ""

#: ../../peps/pep-0492.rst:272
msgid "Operator"
msgstr ""

#: ../../peps/pep-0492.rst:272
msgid "Description"
msgstr ""

#: ../../peps/pep-0492.rst:274
msgid "``yield`` ``x``, ``yield from`` ``x``"
msgstr ""

#: ../../peps/pep-0492.rst:274
msgid "Yield expression"
msgstr ""

#: ../../peps/pep-0492.rst:277
msgid "``lambda``"
msgstr ""

#: ../../peps/pep-0492.rst:277
msgid "Lambda expression"
msgstr ""

#: ../../peps/pep-0492.rst:279
msgid "``if`` -- ``else``"
msgstr ""

#: ../../peps/pep-0492.rst:279
msgid "Conditional expression"
msgstr ""

#: ../../peps/pep-0492.rst:281
msgid "``or``"
msgstr ""

#: ../../peps/pep-0492.rst:281
msgid "Boolean OR"
msgstr ""

#: ../../peps/pep-0492.rst:283
msgid "``and``"
msgstr ""

#: ../../peps/pep-0492.rst:283
msgid "Boolean AND"
msgstr ""

#: ../../peps/pep-0492.rst:285
msgid "``not`` ``x``"
msgstr ""

#: ../../peps/pep-0492.rst:285
msgid "Boolean NOT"
msgstr ""

#: ../../peps/pep-0492.rst:287
msgid ""
"``in``, ``not in``, ``is``, ``is not``, ``<``, ``<=``, ``>``, ``>=``, "
"``!=``, ``==``"
msgstr ""

#: ../../peps/pep-0492.rst:287
msgid "Comparisons, including membership tests and identity tests"
msgstr ""

#: ../../peps/pep-0492.rst:292
msgid "``|``"
msgstr ""

#: ../../peps/pep-0492.rst:292
msgid "Bitwise OR"
msgstr ""

#: ../../peps/pep-0492.rst:294
msgid "``^``"
msgstr ""

#: ../../peps/pep-0492.rst:294
msgid "Bitwise XOR"
msgstr ""

#: ../../peps/pep-0492.rst:296
msgid "``&``"
msgstr ""

#: ../../peps/pep-0492.rst:296
msgid "Bitwise AND"
msgstr ""

#: ../../peps/pep-0492.rst:298
msgid "``<<``, ``>>``"
msgstr ""

#: ../../peps/pep-0492.rst:298
msgid "Shifts"
msgstr ""

#: ../../peps/pep-0492.rst:300
msgid "``+``, ``-``"
msgstr ""

#: ../../peps/pep-0492.rst:300
msgid "Addition and subtraction"
msgstr ""

#: ../../peps/pep-0492.rst:302
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr ""

#: ../../peps/pep-0492.rst:302
msgid "Multiplication, matrix multiplication, division, remainder"
msgstr ""

#: ../../peps/pep-0492.rst:306
msgid "``+x``, ``-x``, ``~x``"
msgstr ""

#: ../../peps/pep-0492.rst:306
msgid "Positive, negative, bitwise NOT"
msgstr ""

#: ../../peps/pep-0492.rst:308
msgid "``**``"
msgstr ""

#: ../../peps/pep-0492.rst:308
msgid "Exponentiation"
msgstr ""

#: ../../peps/pep-0492.rst:310
msgid "``await`` ``x``"
msgstr ""

#: ../../peps/pep-0492.rst:310
msgid "Await expression"
msgstr ""

#: ../../peps/pep-0492.rst:312
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""

#: ../../peps/pep-0492.rst:312
msgid "Subscription, slicing, call, attribute reference"
msgstr ""

#: ../../peps/pep-0492.rst:317
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"``{expressions...}``"
msgstr ""

#: ../../peps/pep-0492.rst:317
msgid "Binding or tuple display, list display, dictionary display, set display"
msgstr ""

#: ../../peps/pep-0492.rst:325
msgid "Examples of \"await\" expressions"
msgstr ""

#: ../../peps/pep-0492.rst:327
msgid "Valid syntax examples:"
msgstr ""

#: ../../peps/pep-0492.rst:330 ../../peps/pep-0492.rst:347
msgid "Expression"
msgstr ""

#: ../../peps/pep-0492.rst:330
msgid "Will be parsed as"
msgstr ""

#: ../../peps/pep-0492.rst:332
msgid "``if await fut: pass``"
msgstr ""

#: ../../peps/pep-0492.rst:332
msgid "``if (await fut): pass``"
msgstr ""

#: ../../peps/pep-0492.rst:333
msgid "``if await fut + 1: pass``"
msgstr ""

#: ../../peps/pep-0492.rst:333
msgid "``if (await fut) + 1: pass``"
msgstr ""

#: ../../peps/pep-0492.rst:334
msgid "``pair = await fut, 'spam'``"
msgstr ""

#: ../../peps/pep-0492.rst:334
msgid "``pair = (await fut), 'spam'``"
msgstr ""

#: ../../peps/pep-0492.rst:335
msgid "``with await fut, open(): pass``"
msgstr ""

#: ../../peps/pep-0492.rst:335
msgid "``with (await fut), open(): pass``"
msgstr ""

#: ../../peps/pep-0492.rst:336
msgid "``await foo()['spam'].baz()()``"
msgstr ""

#: ../../peps/pep-0492.rst:336
msgid "``await ( foo()['spam'].baz()() )``"
msgstr ""

#: ../../peps/pep-0492.rst:337
msgid "``return await coro()``"
msgstr ""

#: ../../peps/pep-0492.rst:337
msgid "``return ( await coro() )``"
msgstr ""

#: ../../peps/pep-0492.rst:338
msgid "``res = await coro() ** 2``"
msgstr ""

#: ../../peps/pep-0492.rst:338
msgid "``res = (await coro()) ** 2``"
msgstr ""

#: ../../peps/pep-0492.rst:339
msgid "``func(a1=await coro(), a2=0)``"
msgstr ""

#: ../../peps/pep-0492.rst:339
msgid "``func(a1=(await coro()), a2=0)``"
msgstr ""

#: ../../peps/pep-0492.rst:340
msgid "``await foo() + await bar()``"
msgstr ""

#: ../../peps/pep-0492.rst:340
msgid "``(await foo()) + (await bar())``"
msgstr ""

#: ../../peps/pep-0492.rst:341
msgid "``-await foo()``"
msgstr ""

#: ../../peps/pep-0492.rst:341
msgid "``-(await foo())``"
msgstr ""

#: ../../peps/pep-0492.rst:344
msgid "Invalid syntax examples:"
msgstr ""

#: ../../peps/pep-0492.rst:347
msgid "Should be written as"
msgstr ""

#: ../../peps/pep-0492.rst:349
msgid "``await await coro()``"
msgstr ""

#: ../../peps/pep-0492.rst:349
msgid "``await (await coro())``"
msgstr ""

#: ../../peps/pep-0492.rst:350
msgid "``await -coro()``"
msgstr ""

#: ../../peps/pep-0492.rst:350
msgid "``await (-coro())``"
msgstr ""

#: ../../peps/pep-0492.rst:355
msgid "Asynchronous Context Managers and \"async with\""
msgstr ""

#: ../../peps/pep-0492.rst:357
msgid ""
"An *asynchronous context manager* is a context manager that is able to "
"suspend execution in its *enter* and *exit* methods."
msgstr ""

#: ../../peps/pep-0492.rst:360
msgid ""
"To make this possible, a new protocol for asynchronous context managers "
"is proposed.  Two new magic methods are added: ``__aenter__`` and "
"``__aexit__``. Both must return an *awaitable*."
msgstr ""

#: ../../peps/pep-0492.rst:364
msgid "An example of an asynchronous context manager::"
msgstr ""

#: ../../peps/pep-0492.rst:375 ../../peps/pep-0492.rst:469
msgid "New Syntax"
msgstr ""

#: ../../peps/pep-0492.rst:377
msgid "A new statement for asynchronous context managers is proposed::"
msgstr ""

#: ../../peps/pep-0492.rst:383 ../../peps/pep-0492.rst:479
msgid "which is semantically equivalent to::"
msgstr ""

#: ../../peps/pep-0492.rst:399
msgid ""
"As with regular ``with`` statements, it is possible to specify multiple "
"context managers in a single ``async with`` statement."
msgstr ""

#: ../../peps/pep-0492.rst:402
msgid ""
"It is an error to pass a regular context manager without ``__aenter__`` "
"and ``__aexit__`` methods to ``async with``.  It is a ``SyntaxError`` to "
"use ``async with`` outside of an ``async def`` function."
msgstr ""

#: ../../peps/pep-0492.rst:408
msgid "Example"
msgstr ""

#: ../../peps/pep-0492.rst:410
msgid ""
"With *asynchronous context managers* it is easy to implement proper "
"database transaction managers for coroutines::"
msgstr ""

#: ../../peps/pep-0492.rst:421
msgid "Code that needs locking also looks lighter::"
msgstr ""

#: ../../peps/pep-0492.rst:426
msgid "instead of::"
msgstr ""

#: ../../peps/pep-0492.rst:433
msgid "Asynchronous Iterators and \"async for\""
msgstr ""

#: ../../peps/pep-0492.rst:435
msgid ""
"An *asynchronous iterable* is able to call asynchronous code in its "
"*iter* implementation, and *asynchronous iterator* can call asynchronous "
"code in its *next* method.  To support asynchronous iteration:"
msgstr ""

#: ../../peps/pep-0492.rst:440
msgid ""
"An object must implement an  ``__aiter__`` method (or, if defined with "
"CPython C API, ``tp_as_async.am_aiter`` slot) returning an *asynchronous "
"iterator object*."
msgstr ""

#: ../../peps/pep-0492.rst:444
msgid ""
"An *asynchronous iterator object* must implement an ``__anext__`` method "
"(or, if defined with CPython C API, ``tp_as_async.am_anext`` slot) "
"returning an *awaitable*."
msgstr ""

#: ../../peps/pep-0492.rst:448
msgid ""
"To stop iteration ``__anext__`` must raise a ``StopAsyncIteration`` "
"exception."
msgstr ""

#: ../../peps/pep-0492.rst:451
msgid "An example of asynchronous iterable::"
msgstr ""

#: ../../peps/pep-0492.rst:471
msgid "A new statement for iterating through asynchronous iterators is proposed::"
msgstr ""

#: ../../peps/pep-0492.rst:495
msgid ""
"It is a ``TypeError`` to pass a regular iterable without ``__aiter__`` "
"method to ``async for``.  It is a ``SyntaxError`` to use ``async for`` "
"outside of an ``async def`` function."
msgstr ""

#: ../../peps/pep-0492.rst:499
msgid ""
"As for with regular ``for`` statement, ``async for`` has an optional "
"``else`` clause."
msgstr ""

#: ../../peps/pep-0492.rst:504
msgid "Example 1"
msgstr ""

#: ../../peps/pep-0492.rst:506
msgid ""
"With asynchronous iteration protocol it is possible to asynchronously "
"buffer data during iteration::"
msgstr ""

#: ../../peps/pep-0492.rst:512
msgid ""
"Where ``cursor`` is an asynchronous iterator that prefetches ``N`` rows "
"of data from a database after every ``N`` iterations."
msgstr ""

#: ../../peps/pep-0492.rst:515
msgid "The following code illustrates new asynchronous iteration protocol::"
msgstr ""

#: ../../peps/pep-0492.rst:534
msgid "then the ``Cursor`` class can be used as follows::"
msgstr ""

#: ../../peps/pep-0492.rst:539
msgid "which would be equivalent to the following code::"
msgstr ""

#: ../../peps/pep-0492.rst:552
msgid "Example 2"
msgstr ""

#: ../../peps/pep-0492.rst:554
msgid ""
"The following is a utility class that transforms a regular iterable to an"
" asynchronous one.  While this is not a very useful thing to do, the code"
" illustrates the relationship between regular and asynchronous iterators."
msgstr ""

#: ../../peps/pep-0492.rst:580
msgid "Why StopAsyncIteration?"
msgstr ""

#: ../../peps/pep-0492.rst:582
msgid ""
"Coroutines are still based on generators internally.  So, before PEP 479,"
" there was no fundamental difference between"
msgstr ""

#: ../../peps/pep-0492.rst:591
msgid "and"
msgstr ""

#: ../../peps/pep-0492.rst:599
msgid ""
"And since :pep:`479` is accepted and enabled by default for coroutines, "
"the following example will have its ``StopIteration`` wrapped into a "
"``RuntimeError``"
msgstr ""

#: ../../peps/pep-0492.rst:609
msgid ""
"The only way to tell the outside code that the iteration has ended is to "
"raise something other than ``StopIteration``.  Therefore, a new built-in "
"exception class ``StopAsyncIteration`` was added."
msgstr ""

#: ../../peps/pep-0492.rst:613
msgid ""
"Moreover, with semantics from :pep:`479`, all ``StopIteration`` "
"exceptions raised in coroutines are wrapped in ``RuntimeError``."
msgstr ""

#: ../../peps/pep-0492.rst:618
msgid "Coroutine objects"
msgstr ""

#: ../../peps/pep-0492.rst:621
msgid "Differences from generators"
msgstr ""

#: ../../peps/pep-0492.rst:623
msgid ""
"This section applies only to *native coroutines* with ``CO_COROUTINE`` "
"flag, i.e. defined with the new ``async def`` syntax."
msgstr ""

#: ../../peps/pep-0492.rst:626
msgid ""
"**The behavior of existing *generator-based coroutines* in asyncio "
"remains unchanged.**"
msgstr ""

#: ../../peps/pep-0492.rst:629
msgid ""
"Great effort has been made to make sure that coroutines and generators "
"are treated as distinct concepts:"
msgstr ""

#: ../../peps/pep-0492.rst:632
msgid ""
"*Native coroutine* objects do not implement ``__iter__`` and ``__next__``"
" methods.  Therefore, they cannot be iterated over or passed to "
"``iter()``, ``list()``, ``tuple()`` and other built-ins. They also cannot"
" be used in a ``for..in`` loop."
msgstr ""

#: ../../peps/pep-0492.rst:637
msgid ""
"An attempt to use ``__iter__`` or ``__next__`` on a *native coroutine* "
"object will result in a ``TypeError``."
msgstr ""

#: ../../peps/pep-0492.rst:640
msgid ""
"*Plain generators* cannot ``yield from`` *native coroutines*: doing so "
"will result in a ``TypeError``."
msgstr ""

#: ../../peps/pep-0492.rst:643
msgid ""
"*generator-based coroutines* (for asyncio code must be decorated with "
"``@asyncio.coroutine`` [1]_) can ``yield from`` *native coroutine "
"objects*."
msgstr ""

#: ../../peps/pep-0492.rst:647
msgid ""
"``inspect.isgenerator()`` and ``inspect.isgeneratorfunction()`` return "
"``False`` for *native coroutine* objects and *native coroutine "
"functions*."
msgstr ""

#: ../../peps/pep-0492.rst:653
msgid "Coroutine object methods"
msgstr ""

#: ../../peps/pep-0492.rst:655
msgid ""
"Coroutines are based on generators internally, thus they share the "
"implementation.  Similarly to generator objects, *coroutines* have "
"``throw()``, ``send()`` and ``close()`` methods.  ``StopIteration`` and "
"``GeneratorExit`` play the same role for coroutines (although :pep:`479` "
"is enabled by default for coroutines).  See :pep:`342`, :pep:`380`, and "
"Python Documentation [11]_ for details."
msgstr ""

#: ../../peps/pep-0492.rst:662
msgid ""
"``throw()``, ``send()`` methods for *coroutines* are used to push values "
"and raise errors into *Future-like* objects."
msgstr ""

#: ../../peps/pep-0492.rst:667
msgid "Debugging Features"
msgstr ""

#: ../../peps/pep-0492.rst:669
msgid ""
"A common beginner mistake is forgetting to use ``yield from`` on "
"coroutines::"
msgstr ""

#: ../../peps/pep-0492.rst:676
msgid ""
"For debugging this kind of mistakes there is a special debug mode in "
"asyncio, in which ``@coroutine`` decorator wraps all functions with a "
"special object with a destructor logging a warning.  Whenever a wrapped "
"generator gets garbage collected, a detailed logging message is generated"
" with information about where exactly the decorator function was defined,"
" stack trace of where it was collected, etc.  Wrapper object also "
"provides a convenient ``__repr__`` function with detailed information "
"about the generator."
msgstr ""

#: ../../peps/pep-0492.rst:685
msgid ""
"The only problem is how to enable these debug capabilities.  Since debug "
"facilities should be a no-op in production mode, ``@coroutine`` decorator"
" makes the decision of whether to wrap or not to wrap based on an OS "
"environment variable ``PYTHONASYNCIODEBUG``.  This way it is possible to "
"run asyncio programs with asyncio's own functions instrumented.  "
"``EventLoop.set_debug``, a different debug facility, has no impact on "
"``@coroutine`` decorator's behavior."
msgstr ""

#: ../../peps/pep-0492.rst:693
msgid ""
"With this proposal, coroutines is a native, distinct from generators, "
"concept.  *In addition* to a ``RuntimeWarning`` being raised on "
"coroutines that were never awaited, it is proposed to add two new "
"functions to the ``sys`` module: ``set_coroutine_wrapper`` and "
"``get_coroutine_wrapper``.  This is to enable advanced debugging "
"facilities in asyncio and other frameworks (such as displaying where "
"exactly coroutine was created, and a more detailed stack trace of where "
"it was garbage collected)."
msgstr ""

#: ../../peps/pep-0492.rst:704
msgid "New Standard Library Functions"
msgstr ""

#: ../../peps/pep-0492.rst:706
msgid "``types.coroutine(gen)``.  See `types.coroutine()`_ section for details."
msgstr ""

#: ../../peps/pep-0492.rst:709
msgid ""
"``inspect.iscoroutine(obj)`` returns ``True`` if ``obj`` is a *native "
"coroutine* object."
msgstr ""

#: ../../peps/pep-0492.rst:712
msgid ""
"``inspect.iscoroutinefunction(obj)`` returns ``True`` if ``obj`` is a "
"*native coroutine function*."
msgstr ""

#: ../../peps/pep-0492.rst:715
msgid ""
"``inspect.isawaitable(obj)`` returns ``True`` if ``obj`` is an "
"*awaitable*."
msgstr ""

#: ../../peps/pep-0492.rst:718
msgid ""
"``inspect.getcoroutinestate(coro)`` returns the current state of a "
"*native coroutine object* (mirrors ``inspect.getfgeneratorstate(gen)``)."
msgstr ""

#: ../../peps/pep-0492.rst:722
msgid ""
"``inspect.getcoroutinelocals(coro)`` returns the mapping of a *native "
"coroutine object's* local variables to their values (mirrors "
"``inspect.getgeneratorlocals(gen)``)."
msgstr ""

#: ../../peps/pep-0492.rst:726
msgid ""
"``sys.set_coroutine_wrapper(wrapper)`` allows to intercept creation of "
"*native coroutine* objects. ``wrapper`` must be either a callable that "
"accepts one argument (a *coroutine* object), or ``None``.  ``None`` "
"resets the wrapper.  If called twice, the new wrapper replaces the "
"previous one. The function is thread-specific.  See `Debugging Features`_"
" for more details."
msgstr ""

#: ../../peps/pep-0492.rst:733
msgid ""
"``sys.get_coroutine_wrapper()`` returns the current wrapper object. "
"Returns ``None`` if no wrapper was set.  The function is thread-specific."
"  See  `Debugging Features`_ for more details."
msgstr ""

#: ../../peps/pep-0492.rst:739
msgid "New Abstract Base Classes"
msgstr ""

#: ../../peps/pep-0492.rst:741
msgid ""
"In order to allow better integration with existing frameworks (such as "
"Tornado, see [13]_) and compilers (such as Cython, see [16]_), two new "
"Abstract Base Classes (ABC) are added:"
msgstr ""

#: ../../peps/pep-0492.rst:745
msgid ""
"``collections.abc.Awaitable`` ABC for *Future-like* classes, that "
"implement ``__await__`` method."
msgstr ""

#: ../../peps/pep-0492.rst:748
msgid ""
"``collections.abc.Coroutine`` ABC for *coroutine* objects, that implement"
" ``send(value)``, ``throw(type, exc, tb)``, ``close()`` and "
"``__await__()`` methods."
msgstr ""

#: ../../peps/pep-0492.rst:752
msgid ""
"Note that generator-based coroutines with ``CO_ITERABLE_COROUTINE`` flag "
"do not implement ``__await__`` method, and therefore are not instances of"
" ``collections.abc.Coroutine`` and ``collections.abc.Awaitable`` ABCs::"
msgstr ""

#: ../../peps/pep-0492.rst:766
msgid ""
"To allow easy testing if objects support asynchronous iteration, two more"
" ABCs are added:"
msgstr ""

#: ../../peps/pep-0492.rst:769
msgid "``collections.abc.AsyncIterable`` -- tests for ``__aiter__`` method."
msgstr ""

#: ../../peps/pep-0492.rst:771
msgid ""
"``collections.abc.AsyncIterator`` -- tests for ``__aiter__`` and "
"``__anext__`` methods."
msgstr ""

#: ../../peps/pep-0492.rst:776
msgid "Glossary"
msgstr ""

#: ../../peps/pep-0492.rst:781
msgid "Native coroutine function"
msgstr ""

#: ../../peps/pep-0492.rst:779
msgid ""
"A coroutine function is declared with ``async def``. It uses ``await`` "
"and ``return value``; see `New Coroutine Declaration Syntax`_ for "
"details."
msgstr ""

#: ../../peps/pep-0492.rst:785
msgid "Native coroutine"
msgstr ""

#: ../../peps/pep-0492.rst:784
msgid ""
"Returned from a native coroutine function. See `Await Expression`_ for "
"details."
msgstr ""

#: ../../peps/pep-0492.rst:789
msgid "Generator-based coroutine function"
msgstr ""

#: ../../peps/pep-0492.rst:788
msgid ""
"Coroutines based on generator syntax.  Most common example are functions "
"decorated with ``@asyncio.coroutine``."
msgstr ""

#: ../../peps/pep-0492.rst:792
msgid "Generator-based coroutine"
msgstr ""

#: ../../peps/pep-0492.rst:792
msgid "Returned from a generator-based coroutine function."
msgstr ""

#: ../../peps/pep-0492.rst:795
msgid "Coroutine"
msgstr ""

#: ../../peps/pep-0492.rst:795
msgid "Either *native coroutine* or *generator-based coroutine*."
msgstr ""

#: ../../peps/pep-0492.rst:799
msgid "Coroutine object"
msgstr ""

#: ../../peps/pep-0492.rst:798
msgid "Either *native coroutine* object or *generator-based coroutine* object."
msgstr ""

#: ../../peps/pep-0492.rst:807
msgid "Future-like object"
msgstr ""

#: ../../peps/pep-0492.rst:802
msgid ""
"An object with an ``__await__`` method, or a C object with "
"``tp_as_async->am_await`` function, returning an *iterator*.  Can be "
"consumed by an ``await`` expression in a coroutine. A coroutine waiting "
"for a Future-like object is suspended until the Future-like object's "
"``__await__`` completes, and returns the result.  See `Await Expression`_"
" for details."
msgstr ""

#: ../../peps/pep-0492.rst:811
msgid "Awaitable"
msgstr ""

#: ../../peps/pep-0492.rst:810
msgid ""
"A *Future-like* object or a *coroutine* object.  See `Await Expression`_ "
"for details."
msgstr ""

#: ../../peps/pep-0492.rst:816
msgid "Asynchronous context manager"
msgstr ""

#: ../../peps/pep-0492.rst:814
msgid ""
"An asynchronous context manager has ``__aenter__`` and ``__aexit__`` "
"methods and can be used with ``async with``.  See `Asynchronous Context "
"Managers and \"async with\"`_ for details."
msgstr ""

#: ../../peps/pep-0492.rst:821
msgid "Asynchronous iterable"
msgstr ""

#: ../../peps/pep-0492.rst:819
msgid ""
"An object with an ``__aiter__`` method, which must return an "
"*asynchronous iterator* object.  Can be used with ``async for``. See "
"`Asynchronous Iterators and \"async for\"`_ for details."
msgstr ""

#: ../../peps/pep-0492.rst:826
msgid "Asynchronous iterator"
msgstr ""

#: ../../peps/pep-0492.rst:824
msgid ""
"An asynchronous iterator has an ``__anext__`` method.  See `Asynchronous "
"Iterators and \"async for\"`_ for details."
msgstr ""

#: ../../peps/pep-0492.rst:829
msgid "Transition Plan"
msgstr ""

#: ../../peps/pep-0492.rst:831
msgid ""
"To avoid backwards compatibility issues with ``async`` and ``await`` "
"keywords, it was decided to modify ``tokenizer.c`` in such a way, that "
"it:"
msgstr ""

#: ../../peps/pep-0492.rst:835
msgid "recognizes ``async def`` ``NAME`` tokens combination;"
msgstr ""

#: ../../peps/pep-0492.rst:837
msgid ""
"while tokenizing ``async def`` block, it replaces ``'async'`` ``NAME`` "
"token with ``ASYNC``, and ``'await'`` ``NAME`` token with ``AWAIT``;"
msgstr ""

#: ../../peps/pep-0492.rst:841
msgid ""
"while tokenizing ``def`` block, it yields ``'async'`` and ``'await'`` "
"``NAME`` tokens as is."
msgstr ""

#: ../../peps/pep-0492.rst:844
msgid ""
"This approach allows for seamless combination of new syntax features (all"
" of them available only in ``async`` functions) with any existing code."
msgstr ""

#: ../../peps/pep-0492.rst:848
msgid ""
"An example of having \"async def\" and \"async\" attribute in one piece "
"of code::"
msgstr ""

#: ../../peps/pep-0492.rst:861
msgid "Backwards Compatibility"
msgstr ""

#: ../../peps/pep-0492.rst:863
msgid "This proposal preserves 100% backwards compatibility."
msgstr ""

#: ../../peps/pep-0492.rst:867
msgid "asyncio"
msgstr ""

#: ../../peps/pep-0492.rst:869
msgid ""
"``asyncio`` module was adapted and tested to work with coroutines and new"
" statements.  Backwards compatibility is 100% preserved, i.e. all "
"existing code will work as-is."
msgstr ""

#: ../../peps/pep-0492.rst:873
msgid "The required changes are mainly:"
msgstr ""

#: ../../peps/pep-0492.rst:875
msgid ""
"Modify ``@asyncio.coroutine`` decorator to use new ``types.coroutine()`` "
"function."
msgstr ""

#: ../../peps/pep-0492.rst:878
msgid "Add ``__await__ = __iter__`` line to ``asyncio.Future`` class."
msgstr ""

#: ../../peps/pep-0492.rst:880
msgid ""
"Add ``ensure_future()`` as an alias for ``async()`` function. Deprecate "
"``async()`` function."
msgstr ""

#: ../../peps/pep-0492.rst:885
msgid "asyncio migration strategy"
msgstr ""

#: ../../peps/pep-0492.rst:887
msgid ""
"Because *plain generators* cannot ``yield from`` *native coroutine "
"objects* (see `Differences from generators`_ section for more details), "
"it is advised to make sure that all generator-based coroutines are "
"decorated with ``@asyncio.coroutine`` *before* starting to use the new "
"syntax."
msgstr ""

#: ../../peps/pep-0492.rst:895
msgid "async/await in CPython code base"
msgstr ""

#: ../../peps/pep-0492.rst:897
msgid "There is no use of ``await`` names in CPython."
msgstr ""

#: ../../peps/pep-0492.rst:899
msgid ""
"``async`` is mostly used by asyncio.  We are addressing this by renaming "
"``async()`` function to ``ensure_future()`` (see `asyncio`_ section for "
"details)."
msgstr ""

#: ../../peps/pep-0492.rst:903
msgid ""
"Another use of ``async`` keyword is in ``Lib/xml/dom/xmlbuilder.py``, to "
"define an ``async = False`` attribute for ``DocumentLS`` class. There is "
"no documentation or tests for it, it is not used anywhere else in "
"CPython.  It is replaced with a getter, that raises a "
"``DeprecationWarning``, advising to use ``async_`` attribute instead. "
"'async' attribute is not documented and is not used in CPython code base."
msgstr ""

#: ../../peps/pep-0492.rst:913
msgid "Grammar Updates"
msgstr ""

#: ../../peps/pep-0492.rst:915
msgid "Grammar changes are fairly minimal::"
msgstr ""

#: ../../peps/pep-0492.rst:930
msgid "Deprecation Plans"
msgstr ""

#: ../../peps/pep-0492.rst:932
msgid ""
"``async`` and ``await`` names will be softly deprecated in CPython 3.5 "
"and 3.6. In 3.7 we will transform them to proper keywords.  Making "
"``async`` and ``await`` proper keywords before 3.7 might make it harder "
"for people to port their code to Python 3."
msgstr ""

#: ../../peps/pep-0492.rst:939
msgid "Design Considerations"
msgstr ""

#: ../../peps/pep-0492.rst:942
msgid "PEP 3152"
msgstr ""

#: ../../peps/pep-0492.rst:944
msgid ""
":pep:`3152` by Gregory Ewing proposes a different mechanism for "
"coroutines (called \"cofunctions\").  Some key points:"
msgstr ""

#: ../../peps/pep-0492.rst:947
msgid ""
"A new keyword ``codef`` to declare a *cofunction*.  *Cofunction* is "
"always a generator, even if there is no ``cocall`` expressions inside it."
"  Maps to ``async def`` in this proposal."
msgstr ""

#: ../../peps/pep-0492.rst:951
msgid ""
"A new keyword ``cocall`` to call a *cofunction*.  Can only be used inside"
" a *cofunction*.  Maps to ``await`` in this proposal (with some "
"differences, see below)."
msgstr ""

#: ../../peps/pep-0492.rst:955
msgid "It is not possible to call a *cofunction* without a ``cocall`` keyword."
msgstr ""

#: ../../peps/pep-0492.rst:958
msgid "``cocall`` grammatically requires parentheses after it::"
msgstr ""

#: ../../peps/pep-0492.rst:964
msgid ""
"``cocall f(*args, **kwds)`` is semantically equivalent to ``yield from "
"f.__cocall__(*args, **kwds)``."
msgstr ""

#: ../../peps/pep-0492.rst:967
msgid "Differences from this proposal:"
msgstr ""

#: ../../peps/pep-0492.rst:969
msgid ""
"There is no equivalent of ``__cocall__`` in this PEP, which is called and"
" its result is passed to ``yield from`` in the ``cocall`` expression. "
"``await`` keyword expects an *awaitable* object, validates the type, and "
"executes ``yield from`` on it.  Although, ``__await__`` method is similar"
" to ``__cocall__``, but is only used to define *Future-like* objects."
msgstr ""

#: ../../peps/pep-0492.rst:976
msgid ""
"``await`` is defined in almost the same way as ``yield from`` in the "
"grammar (it is later enforced that ``await`` can only be inside ``async "
"def``).  It is possible to simply write ``await future``, whereas "
"``cocall`` always requires parentheses."
msgstr ""

#: ../../peps/pep-0492.rst:981
msgid ""
"To make asyncio work with :pep:`3152` it would be required to modify "
"``@asyncio.coroutine`` decorator to wrap all functions in an object with "
"a ``__cocall__`` method, or to implement ``__cocall__`` on generators.  "
"To call *cofunctions* from existing generator-based coroutines it would "
"be required to use ``costart(cofunc, *args, **kwargs)`` built-in."
msgstr ""

#: ../../peps/pep-0492.rst:988
msgid ""
"Since it is impossible to call a *cofunction* without a ``cocall`` "
"keyword, it automatically prevents the common mistake of forgetting to "
"use ``yield from`` on generator-based coroutines.  This proposal "
"addresses this problem with a different approach, see `Debugging "
"Features`_."
msgstr ""

#: ../../peps/pep-0492.rst:994
msgid ""
"A shortcoming of requiring a ``cocall`` keyword to call a coroutine is "
"that if is decided to implement coroutine-generators -- coroutines with "
"``yield`` or ``async yield`` expressions -- we wouldn't need a ``cocall``"
" keyword to call them.  So we'll end up having ``__cocall__`` and no "
"``__call__`` for regular coroutines, and having ``__call__`` and no "
"``__cocall__`` for coroutine-generators."
msgstr ""

#: ../../peps/pep-0492.rst:1002
msgid ""
"Requiring parentheses grammatically also introduces a whole lot of new "
"problems."
msgstr ""

#: ../../peps/pep-0492.rst:1005
msgid "The following code::"
msgstr ""

#: ../../peps/pep-0492.rst:1011
msgid "would look like::"
msgstr ""

#: ../../peps/pep-0492.rst:1018
msgid "There are no equivalents of ``async for`` and ``async with`` in PEP 3152."
msgstr ""

#: ../../peps/pep-0492.rst:1023
msgid "Coroutine-generators"
msgstr ""

#: ../../peps/pep-0492.rst:1025
msgid ""
"With ``async for`` keyword it is desirable to have a concept of a "
"*coroutine-generator* -- a coroutine with ``yield`` and ``yield from`` "
"expressions.  To avoid any ambiguity with regular generators, we would "
"likely require to have an ``async`` keyword before ``yield``, and ``async"
" yield from`` would raise a ``StopAsyncIteration`` exception."
msgstr ""

#: ../../peps/pep-0492.rst:1031
msgid ""
"While it is possible to implement coroutine-generators, we believe that "
"they are out of scope of this proposal.  It is an advanced concept that "
"should be carefully considered and balanced, with a non-trivial changes "
"in the implementation of current generator objects.  This is a matter for"
" a separate PEP."
msgstr ""

#: ../../peps/pep-0492.rst:1039
msgid "Why \"async\" and \"await\" keywords"
msgstr ""

#: ../../peps/pep-0492.rst:1041
msgid "async/await is not a new concept in programming languages:"
msgstr ""

#: ../../peps/pep-0492.rst:1043
msgid "C# has it since long time ago [5]_;"
msgstr ""

#: ../../peps/pep-0492.rst:1045
msgid ""
"proposal to add async/await in ECMAScript 7 [2]_; see also Traceur "
"project [9]_;"
msgstr ""

#: ../../peps/pep-0492.rst:1048
msgid "Facebook's Hack/HHVM [6]_;"
msgstr ""

#: ../../peps/pep-0492.rst:1050
msgid "Google's Dart language [7]_;"
msgstr ""

#: ../../peps/pep-0492.rst:1052
msgid "Scala [8]_;"
msgstr ""

#: ../../peps/pep-0492.rst:1054
msgid "proposal to add async/await to C++ [10]_;"
msgstr ""

#: ../../peps/pep-0492.rst:1056
msgid "and many other less popular languages."
msgstr ""

#: ../../peps/pep-0492.rst:1058
msgid ""
"This is a huge benefit, as some users already have experience with "
"async/await, and because it makes working with many languages in one "
"project easier (Python with ECMAScript 7 for instance)."
msgstr ""

#: ../../peps/pep-0492.rst:1064
msgid "Why \"__aiter__\" does not return an awaitable"
msgstr ""

#: ../../peps/pep-0492.rst:1066
msgid ""
":pep:`492` was accepted in CPython 3.5.0 with ``__aiter__`` defined as a "
"method, that was expected to return an awaitable resolving to an "
"asynchronous iterator."
msgstr ""

#: ../../peps/pep-0492.rst:1070
msgid ""
"In 3.5.2 (as :pep:`492` was accepted on a provisional basis) the "
"``__aiter__`` protocol was updated to return asynchronous iterators "
"directly."
msgstr ""

#: ../../peps/pep-0492.rst:1074
msgid ""
"The motivation behind this change is to make it possible to implement "
"asynchronous generators in Python.  See [19]_ and [20]_ for more details."
msgstr ""

#: ../../peps/pep-0492.rst:1080
msgid "Importance of \"async\" keyword"
msgstr ""

#: ../../peps/pep-0492.rst:1082
msgid ""
"While it is possible to just implement ``await`` expression and treat all"
" functions with at least one ``await`` as coroutines, this approach makes"
" APIs design, code refactoring and its long time support harder."
msgstr ""

#: ../../peps/pep-0492.rst:1086
msgid "Let's pretend that Python only has ``await`` keyword::"
msgstr ""

#: ../../peps/pep-0492.rst:1096
msgid ""
"If ``useful()`` function is refactored and someone removes all ``await`` "
"expressions from it, it would become a regular python function, and all "
"code that depends on it, including ``important()`` would be broken.  To "
"mitigate this issue a decorator similar to ``@asyncio.coroutine`` has to "
"be introduced."
msgstr ""

#: ../../peps/pep-0492.rst:1104
msgid "Why \"async def\""
msgstr ""

#: ../../peps/pep-0492.rst:1106
msgid ""
"For some people bare ``async name(): pass`` syntax might look more "
"appealing than ``async def name(): pass``.  It is certainly easier to "
"type.  But on the other hand, it breaks the symmetry between ``async "
"def``, ``async with`` and ``async for``, where ``async`` is a modifier, "
"stating that the statement is asynchronous.  It is also more consistent "
"with the existing grammar."
msgstr ""

#: ../../peps/pep-0492.rst:1115
msgid "Why not \"await for\" and \"await with\""
msgstr ""

#: ../../peps/pep-0492.rst:1117
msgid ""
"``async`` is an adjective, and hence it is a better choice for a "
"*statement qualifier* keyword.  ``await for/with`` would imply that "
"something is awaiting for a completion of a ``for`` or ``with`` "
"statement."
msgstr ""

#: ../../peps/pep-0492.rst:1124
msgid "Why \"async def\" and not \"def async\""
msgstr ""

#: ../../peps/pep-0492.rst:1126
msgid ""
"``async`` keyword is a *statement qualifier*.  A good analogy to it are "
"\"static\", \"public\", \"unsafe\" keywords from other languages.  "
"\"async for\" is an asynchronous \"for\" statement, \"async with\" is an "
"asynchronous \"with\" statement, \"async def\" is an asynchronous "
"function."
msgstr ""

#: ../../peps/pep-0492.rst:1131
msgid ""
"Having \"async\" after the main statement keyword might introduce some "
"confusion, like \"for async item in iterator\" can be read as \"for each "
"asynchronous item in iterator\"."
msgstr ""

#: ../../peps/pep-0492.rst:1135
msgid ""
"Having ``async`` keyword before ``def``, ``with`` and ``for`` also makes "
"the language grammar simpler.  And \"async def\" better separates "
"coroutines from regular functions visually."
msgstr ""

#: ../../peps/pep-0492.rst:1141
msgid "Why not a __future__ import"
msgstr ""

#: ../../peps/pep-0492.rst:1143
msgid ""
"`Transition Plan`_ section explains how tokenizer is modified to treat "
"``async`` and ``await`` as keywords *only* in ``async def`` blocks. Hence"
" ``async def`` fills the role that a module level compiler declaration "
"like ``from __future__ import async_await`` would otherwise fill."
msgstr ""

#: ../../peps/pep-0492.rst:1151
msgid "Why magic methods start with \"a\""
msgstr ""

#: ../../peps/pep-0492.rst:1153
msgid ""
"New asynchronous magic methods ``__aiter__``, ``__anext__``, "
"``__aenter__``, and ``__aexit__`` all start with the same prefix \"a\". "
"An alternative proposal is to use \"async\" prefix, so that ``__anext__``"
" becomes ``__async_next__``. However, to align new magic methods with the"
" existing ones, such as ``__radd__`` and ``__iadd__`` it was decided to "
"use a shorter version."
msgstr ""

#: ../../peps/pep-0492.rst:1162
msgid "Why not reuse existing magic names"
msgstr ""

#: ../../peps/pep-0492.rst:1164
msgid ""
"An alternative idea about new asynchronous iterators and context managers"
" was to reuse existing magic methods, by adding an ``async`` keyword to "
"their declarations::"
msgstr ""

#: ../../peps/pep-0492.rst:1172
msgid "This approach has the following downsides:"
msgstr ""

#: ../../peps/pep-0492.rst:1174
msgid ""
"it would not be possible to create an object that works in both ``with`` "
"and ``async with`` statements;"
msgstr ""

#: ../../peps/pep-0492.rst:1177
msgid ""
"it would break backwards compatibility, as nothing prohibits from "
"returning a Future-like objects from ``__enter__`` and/or ``__exit__`` in"
" Python <= 3.4;"
msgstr ""

#: ../../peps/pep-0492.rst:1181
msgid ""
"one of the main points of this proposal is to make native coroutines as "
"simple and foolproof as possible, hence the clear separation of the "
"protocols."
msgstr ""

#: ../../peps/pep-0492.rst:1187
msgid "Why not reuse existing \"for\" and \"with\" statements"
msgstr ""

#: ../../peps/pep-0492.rst:1189
msgid ""
"The vision behind existing generator-based coroutines and this proposal "
"is to make it easy for users to see where the code might be suspended. "
"Making existing \"for\" and \"with\" statements to recognize asynchronous"
" iterators and context managers will inevitably create implicit suspend "
"points, making it harder to reason about the code."
msgstr ""

#: ../../peps/pep-0492.rst:1197
msgid "Comprehensions"
msgstr ""

#: ../../peps/pep-0492.rst:1199
msgid ""
"Syntax for asynchronous comprehensions could be provided, but this "
"construct is outside of the scope of this PEP."
msgstr ""

#: ../../peps/pep-0492.rst:1204
msgid "Async lambda functions"
msgstr ""

#: ../../peps/pep-0492.rst:1206
msgid ""
"Syntax for asynchronous lambda functions could be provided, but this "
"construct is outside of the scope of this PEP."
msgstr ""

#: ../../peps/pep-0492.rst:1211
msgid "Performance"
msgstr ""

#: ../../peps/pep-0492.rst:1214
msgid "Overall Impact"
msgstr ""

#: ../../peps/pep-0492.rst:1216
msgid ""
"This proposal introduces no observable performance impact.  Here is an "
"output of python's official set of benchmarks [4]_:"
msgstr ""

#: ../../peps/pep-0492.rst:1243
msgid "Tokenizer modifications"
msgstr ""

#: ../../peps/pep-0492.rst:1245
msgid ""
"There is no observable slowdown of parsing python files with the modified"
" tokenizer: parsing of one 12Mb file (``Lib/test/test_binop.py`` repeated"
" 1000 times) takes the same amount of time."
msgstr ""

#: ../../peps/pep-0492.rst:1252
msgid "async/await"
msgstr ""

#: ../../peps/pep-0492.rst:1254
msgid ""
"The following micro-benchmark was used to determine performance "
"difference between \"async\" functions and generators::"
msgstr ""

#: ../../peps/pep-0492.rst:1287
msgid "The result is that there is no observable performance difference::"
msgstr ""

#: ../../peps/pep-0492.rst:1298
msgid "Note that depth of 19 means 1,048,575 calls."
msgstr ""

#: ../../peps/pep-0492.rst:1302
msgid "Reference Implementation"
msgstr ""

#: ../../peps/pep-0492.rst:1304
msgid "The reference implementation can be found here: [3]_."
msgstr ""

#: ../../peps/pep-0492.rst:1307
msgid "List of high-level changes and new protocols"
msgstr ""

#: ../../peps/pep-0492.rst:1309
msgid ""
"New syntax for defining coroutines: ``async def`` and new ``await`` "
"keyword."
msgstr ""

#: ../../peps/pep-0492.rst:1312
msgid ""
"New ``__await__`` method for Future-like objects, and new "
"``tp_as_async.am_await`` slot in ``PyTypeObject``."
msgstr ""

#: ../../peps/pep-0492.rst:1315
msgid ""
"New syntax for asynchronous context managers: ``async with``.  And "
"associated protocol with ``__aenter__`` and ``__aexit__`` methods."
msgstr ""

#: ../../peps/pep-0492.rst:1318
msgid ""
"New syntax for asynchronous iteration: ``async for``.  And associated "
"protocol with ``__aiter__``, ``__aexit__`` and new built-in exception "
"``StopAsyncIteration``.  New ``tp_as_async.am_aiter`` and "
"``tp_as_async.am_anext`` slots in ``PyTypeObject``."
msgstr ""

#: ../../peps/pep-0492.rst:1323
msgid ""
"New AST nodes: ``AsyncFunctionDef``, ``AsyncFor``, ``AsyncWith``, "
"``Await``."
msgstr ""

#: ../../peps/pep-0492.rst:1326
msgid ""
"New functions: ``sys.set_coroutine_wrapper(callback)``, "
"``sys.get_coroutine_wrapper()``, ``types.coroutine(gen)``, "
"``inspect.iscoroutinefunction(func)``, ``inspect.iscoroutine(obj)``, "
"``inspect.isawaitable(obj)``, ``inspect.getcoroutinestate(coro)``, and "
"``inspect.getcoroutinelocals(coro)``."
msgstr ""

#: ../../peps/pep-0492.rst:1332
msgid ""
"New ``CO_COROUTINE`` and ``CO_ITERABLE_COROUTINE`` bit flags for code "
"objects."
msgstr ""

#: ../../peps/pep-0492.rst:1335
msgid ""
"New ABCs: ``collections.abc.Awaitable``, ``collections.abc.Coroutine``, "
"``collections.abc.AsyncIterable``, and ``collections.abc.AsyncIterator``."
msgstr ""

#: ../../peps/pep-0492.rst:1339
msgid ""
"C API changes: new ``PyCoro_Type`` (exposed to Python as "
"``types.CoroutineType``) and ``PyCoroObject``. ``PyCoro_CheckExact(*o)`` "
"to test if ``o`` is a *native coroutine*."
msgstr ""

#: ../../peps/pep-0492.rst:1344
msgid ""
"While the list of changes and new things is not short, it is important to"
" understand, that most users will not use these features directly. It is "
"intended to be used in frameworks and libraries to provide users with "
"convenient to use and unambiguous APIs with ``async def``, ``await``, "
"``async for`` and ``async with`` syntax."
msgstr ""

#: ../../peps/pep-0492.rst:1352
msgid "Working example"
msgstr ""

#: ../../peps/pep-0492.rst:1354
msgid "All concepts proposed in this PEP are implemented [3]_ and can be tested."
msgstr ""

#: ../../peps/pep-0492.rst:1387
msgid "Acceptance"
msgstr ""

#: ../../peps/pep-0492.rst:1389
msgid ":pep:`492` was accepted by Guido, Tuesday, May 5, 2015 [14]_."
msgstr ""

#: ../../peps/pep-0492.rst:1393
msgid "Implementation"
msgstr ""

#: ../../peps/pep-0492.rst:1395
msgid ""
"The implementation is tracked in issue 24017 [15]_. It was committed on "
"May 11, 2015."
msgstr ""

#: ../../peps/pep-0492.rst:1400
msgid "References"
msgstr "Referências"

#: ../../peps/pep-0492.rst:1402
msgid "https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine"
msgstr ""

#: ../../peps/pep-0492.rst:1404
msgid "http://wiki.ecmascript.org/doku.php?id=strawman:async_functions"
msgstr ""

#: ../../peps/pep-0492.rst:1406
msgid "https://github.com/1st1/cpython/tree/await"
msgstr ""

#: ../../peps/pep-0492.rst:1408
msgid "https://hg.python.org/benchmarks"
msgstr ""

#: ../../peps/pep-0492.rst:1410
msgid "https://msdn.microsoft.com/en-us/library/hh191443.aspx"
msgstr ""

#: ../../peps/pep-0492.rst:1412
msgid "http://docs.hhvm.com/manual/en/hack.async.php"
msgstr ""

#: ../../peps/pep-0492.rst:1414
msgid "https://www.dartlang.org/articles/await-async/"
msgstr ""

#: ../../peps/pep-0492.rst:1416
msgid "http://docs.scala-lang.org/sips/pending/async.html"
msgstr ""

#: ../../peps/pep-0492.rst:1418
msgid ""
"https://github.com/google/traceur-compiler/wiki/LanguageFeatures#async-"
"functions-experimental"
msgstr ""

#: ../../peps/pep-0492.rst:1420
msgid "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3722.pdf (PDF)"
msgstr ""

#: ../../peps/pep-0492.rst:1422
msgid ""
"https://docs.python.org/3/reference/expressions.html#generator-iterator-"
"methods"
msgstr ""

#: ../../peps/pep-0492.rst:1424
msgid "https://docs.python.org/3/reference/expressions.html#primaries"
msgstr ""

#: ../../peps/pep-0492.rst:1426
msgid "https://mail.python.org/pipermail/python-dev/2015-May/139851.html"
msgstr ""

#: ../../peps/pep-0492.rst:1428
msgid "https://mail.python.org/pipermail/python-dev/2015-May/139844.html"
msgstr ""

#: ../../peps/pep-0492.rst:1430
msgid "http://bugs.python.org/issue24017"
msgstr ""

#: ../../peps/pep-0492.rst:1432
msgid "https://github.com/python/asyncio/issues/233"
msgstr ""

#: ../../peps/pep-0492.rst:1434
msgid "https://hg.python.org/cpython/rev/7a0a1a4ac639"
msgstr ""

#: ../../peps/pep-0492.rst:1436
msgid "http://bugs.python.org/issue24400"
msgstr ""

#: ../../peps/pep-0492.rst:1438
msgid "http://bugs.python.org/issue27243"
msgstr ""

#: ../../peps/pep-0492.rst:1440
msgid "https://docs.python.org/3/reference/datamodel.html#async-iterators"
msgstr ""

#: ../../peps/pep-0492.rst:1443
msgid "Acknowledgments"
msgstr ""

#: ../../peps/pep-0492.rst:1445
msgid ""
"I thank Guido van Rossum, Victor Stinner, Elvis Pranskevichus, Andrew "
"Svetlov, Łukasz Langa, Greg Ewing, Stephen J. Turnbull, Jim J. Jewett, "
"Brett Cannon, Alyssa Coghlan, Steven D'Aprano, Paul Moore, Nathaniel "
"Smith, Ethan Furman, Stefan Behnel, Paul Sokolovsky, Victor Petrovykh, "
"and many others for their feedback, ideas, edits, criticism, code "
"reviews, and discussions around this PEP."
msgstr ""

#: ../../peps/pep-0492.rst:1454
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-0492.rst:1456
msgid "This document has been placed in the public domain."
msgstr "Este documento foi colocado em domínio público."

#~ msgid ""
#~ "The function applies ``CO_ITERABLE_COROUTINE`` "
#~ "flag to generator- function's code "
#~ "object, making it return a *coroutine*"
#~ " object."
#~ msgstr ""

#~ msgid ""
#~ "*generator-based coroutines* (for asyncio "
#~ "code must be decorated with "
#~ "``@asyncio.coroutine``) can ``yield from`` "
#~ "*native coroutine objects*."
#~ msgstr ""

#~ msgid ""
#~ "A shortcoming of requiring a ``cocall``"
#~ " keyword to call a coroutine is "
#~ "that if is decided to implement "
#~ "coroutine-generators -- coroutines with "
#~ "``yield`` or ``async yield`` expressions "
#~ "-- we wouldn't need a ``cocall`` "
#~ "keyword to call them.  So we'll "
#~ "end up having ``__cocall__`` and no "
#~ "``__call__`` for regular coroutines, and "
#~ "having ``__call__`` and no ``__cocall__`` "
#~ "for coroutine- generators."
#~ msgstr ""

#~ msgid ""
#~ "New syntax for asynchronous iteration: "
#~ "``async for``.  And associated protocol "
#~ "with ``__aiter__``, ``__aexit__`` and new "
#~ "built- in exception ``StopAsyncIteration``.  "
#~ "New ``tp_as_async.am_aiter`` and "
#~ "``tp_as_async.am_anext`` slots in ``PyTypeObject``."
#~ msgstr ""

#~ msgid ""
#~ "I thank Guido van Rossum, Victor "
#~ "Stinner, Elvis Pranskevichus, Andrew Svetlov,"
#~ " Łukasz Langa, Greg Ewing, Stephen J."
#~ " Turnbull, Jim J. Jewett, Brett "
#~ "Cannon, Nick Coghlan, Steven D'Aprano, "
#~ "Paul Moore, Nathaniel Smith, Ethan "
#~ "Furman, Stefan Behnel, Paul Sokolovsky, "
#~ "Victor Petrovykh, and many others for"
#~ " their feedback, ideas, edits, criticism,"
#~ " code reviews, and discussions around "
#~ "this PEP."
#~ msgstr ""

