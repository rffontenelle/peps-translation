# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0670.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-0670.rst:3
msgid ""
"Erlend Egeberg Aasland <erlend@python.org>, Victor Stinner "
"<vstinner@python.org>"
msgstr ""

#: ../../peps/pep-0670.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-0670.rst:5
msgid "Final"
msgstr ""

#: ../../peps/pep-0670.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-0670.rst:6
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0670.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-0670.rst:8
msgid "19-Oct-2021"
msgstr ""

#: ../../peps/pep-0670.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0670.rst:9
msgid "3.11"
msgstr ""

#: ../../peps/pep-0670.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-0670.rst:10
msgid ""
"`20-Oct-2021 <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/2GN646CGWGTO6ZHHU7JTA5XWDF4ULM77/>`__, `08-Feb-2022"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/IJ3IBVY3JDPROKX55YNDT6XZTVTTPGOP/>`__, `22-Feb-2022"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/VM6I3UHVMME6QRSUOYLK6N2OZHP454W6/>`__"
msgstr ""

#: ../../peps/pep-0670.rst
msgid "Resolution"
msgstr ""

#: ../../peps/pep-0670.rst:13
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/thread/QQFCJ7LR36RUZSC3WI6WZZMQVQ3ZI4MS/"
msgstr ""

#: ../../peps/pep-0670.rst:17
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0670.rst:19
msgid ""
"Macros in the C API will be converted to static inline functions or "
"regular functions. This will help avoid macro pitfalls in C/C++, and make"
" the functions usable from other programming languages."
msgstr ""

#: ../../peps/pep-0670.rst:23
msgid ""
"To avoid compiler warnings, function arguments of pointer types will be "
"cast to appropriate types using additional macros. The cast will not be "
"done in the limited C API version 3.11: users who opt in to the new "
"limited API may need to add casts to the exact expected type."
msgstr ""

#: ../../peps/pep-0670.rst:29
msgid ""
"To avoid introducing incompatible changes, macros which can be used as "
"l-value in an assignment will not be converted."
msgstr ""

#: ../../peps/pep-0670.rst:34
msgid "Rationale"
msgstr ""

#: ../../peps/pep-0670.rst:36
msgid ""
"The use of macros may have unintended adverse effects that are hard to "
"avoid, even for experienced C developers. Some issues have been known for"
" years, while others have been discovered recently in Python. Working "
"around macro pitfalls makes the macro code harder to read and to "
"maintain."
msgstr ""

#: ../../peps/pep-0670.rst:42
msgid "Converting macros to functions has multiple advantages:"
msgstr ""

#: ../../peps/pep-0670.rst:44
msgid ""
"Functions don't suffer from macro pitfalls, for example the following "
"ones described in `GCC documentation <https://gcc.gnu.org/onlinedocs/cpp"
"/Macro-Pitfalls.html>`_:"
msgstr ""

#: ../../peps/pep-0670.rst:48 ../../peps/pep-0670.rst:233
msgid "Misnesting"
msgstr ""

#: ../../peps/pep-0670.rst:49
msgid "Operator precedence problems"
msgstr ""

#: ../../peps/pep-0670.rst:50
msgid "Swallowing the semicolon"
msgstr ""

#: ../../peps/pep-0670.rst:51 ../../peps/pep-0670.rst:212
msgid "Duplication of side effects"
msgstr ""

#: ../../peps/pep-0670.rst:52
msgid "Self-referential macros"
msgstr ""

#: ../../peps/pep-0670.rst:53
msgid "Argument prescan"
msgstr ""

#: ../../peps/pep-0670.rst:54
msgid "Newlines in arguments"
msgstr ""

#: ../../peps/pep-0670.rst:56
msgid ""
"Functions don't need the following workarounds for macro pitfalls, making"
" them usually easier to read and to maintain than similar macro code:"
msgstr ""

#: ../../peps/pep-0670.rst:60
msgid "Adding parentheses around arguments."
msgstr ""

#: ../../peps/pep-0670.rst:61
msgid ""
"Using line continuation characters if the function is written on multiple"
" lines."
msgstr ""

#: ../../peps/pep-0670.rst:63
msgid "Adding commas to execute multiple expressions."
msgstr ""

#: ../../peps/pep-0670.rst:64
msgid "Using ``do { ... } while (0)`` to write multiple statements."
msgstr ""

#: ../../peps/pep-0670.rst:66
msgid "Argument types and the return type of functions are well defined."
msgstr ""

#: ../../peps/pep-0670.rst:67
msgid "Debuggers and profilers can retrieve the name of inlined functions."
msgstr ""

#: ../../peps/pep-0670.rst:68
msgid "Debuggers can put breakpoints on inlined functions."
msgstr ""

#: ../../peps/pep-0670.rst:69
msgid "Variables have a well-defined scope."
msgstr ""

#: ../../peps/pep-0670.rst:71
msgid ""
"Converting macros and static inline functions to regular functions makes "
"these regular functions accessible to projects which use Python but "
"cannot use macros and static inline functions."
msgstr ""

#: ../../peps/pep-0670.rst:77
msgid "Specification"
msgstr ""

#: ../../peps/pep-0670.rst:80
msgid "Convert macros to static inline functions"
msgstr ""

#: ../../peps/pep-0670.rst:82
msgid "Most macros will be converted to static inline functions."
msgstr ""

#: ../../peps/pep-0670.rst:84
msgid "The following macros will not be converted:"
msgstr ""

#: ../../peps/pep-0670.rst:86
msgid ""
"Object-like macros (i.e. those which don't need parentheses and "
"arguments). For example:"
msgstr ""

#: ../../peps/pep-0670.rst:89
msgid "Empty macros. Example: ``#define Py_HAVE_CONDVAR``."
msgstr ""

#: ../../peps/pep-0670.rst:90
msgid ""
"Macros only defining a value, even if a constant with a well defined type"
" would be better. Example: ``#define METH_VARARGS 0x0001``."
msgstr ""

#: ../../peps/pep-0670.rst:93
msgid ""
"Compatibility layer for different C compilers, C language extensions, or "
"recent C features. Example: ``Py_GCC_ATTRIBUTE()``, ``Py_ALWAYS_INLINE``,"
" ``Py_MEMCPY()``."
msgstr ""

#: ../../peps/pep-0670.rst:96
msgid ""
"Macros used for definitions rather than behavior. Example: "
"``PyAPI_FUNC``, ``Py_DEPRECATED``, ``Py_PYTHON_H``."
msgstr ""

#: ../../peps/pep-0670.rst:98
msgid ""
"Macros that need C preprocessor features, like stringification and "
"concatenation. Example: ``Py_STRINGIFY()``."
msgstr ""

#: ../../peps/pep-0670.rst:100
msgid ""
"Macros which cannot be converted to functions. Examples: "
"``Py_BEGIN_ALLOW_THREADS`` (contains an unpaired ``}``), ``Py_VISIT`` "
"(relies on specific variable names), Py_RETURN_RICHCOMPARE (returns from "
"the calling function)."
msgstr ""

#: ../../peps/pep-0670.rst:104
msgid ""
"Macros which can be used as an l-value in assignments. This would be an "
"incompatible change and is out of the scope of this PEP. Example: "
"``PyBytes_AS_STRING()``."
msgstr ""

#: ../../peps/pep-0670.rst:107
msgid ""
"Macros which have different return types depending on the code path or "
"arguments."
msgstr ""

#: ../../peps/pep-0670.rst:112
msgid "Convert static inline functions to regular functions"
msgstr ""

#: ../../peps/pep-0670.rst:114
msgid ""
"Static inline functions in the public C API may be converted to regular "
"functions, but only if there is no measurable performance impact of "
"changing the function. The performance impact should be measured with "
"benchmarks."
msgstr ""

#: ../../peps/pep-0670.rst:121
msgid "Cast pointer arguments"
msgstr ""

#: ../../peps/pep-0670.rst:123
msgid ""
"Currently, most macros accepting pointers cast pointer arguments to their"
" expected types. For example, in Python 3.6, the ``Py_TYPE()`` macro "
"casts its argument to ``PyObject*``:"
msgstr ""

#: ../../peps/pep-0670.rst:131
msgid ""
"The ``Py_TYPE()`` macro accepts the ``PyObject*`` type, but also any "
"pointer types, such as ``PyLongObject*`` and ``PyDictObject*``."
msgstr ""

#: ../../peps/pep-0670.rst:134
msgid "Functions are strongly typed, and can only accept one type of argument."
msgstr ""

#: ../../peps/pep-0670.rst:136
msgid ""
"To avoid compiler errors and warnings in existing code, when a macro is "
"converted to a function and the macro casts at least one of its arguments"
" a new macro will be added to keep the cast. The new macro and the "
"function will have the same name."
msgstr ""

#: ../../peps/pep-0670.rst:141
msgid ""
"Example with the ``Py_TYPE()`` macro converted to a static inline "
"function:"
msgstr ""

#: ../../peps/pep-0670.rst:151
msgid ""
"The cast is kept for all pointer types, not only ``PyObject*``. This "
"includes casts to ``void*``: removing a cast to ``void*`` would emit a "
"new warning if the function is called with a ``const void*`` variable. "
"For example, the ``PyUnicode_WRITE()`` macro casts its *data* argument to"
" ``void*``, and so it currently accepts ``const void*`` type, even though"
" it writes into *data*.  This PEP will not change this."
msgstr ""

#: ../../peps/pep-0670.rst:160
msgid "Avoid the cast in the limited C API version 3.11"
msgstr ""

#: ../../peps/pep-0670.rst:162
msgid ""
"The casts will be excluded from the limited C API version 3.11 and newer."
" When an API user opts into the new limited API, they must pass the "
"expected type or perform the cast."
msgstr ""

#: ../../peps/pep-0670.rst:166
msgid "As an example, ``Py_TYPE()`` will be defined like this:"
msgstr ""

#: ../../peps/pep-0670.rst:179
msgid "Return type is not changed"
msgstr ""

#: ../../peps/pep-0670.rst:181
msgid ""
"When a macro is converted to a function, its return type must not change "
"to prevent emitting new compiler warnings."
msgstr ""

#: ../../peps/pep-0670.rst:184
msgid ""
"For example, Python 3.7 changed the return type of ``PyUnicode_AsUTF8()``"
" from ``char*`` to ``const char*`` (`commit "
"<https://github.com/python/cpython/commit/2a404b63d48d73bbaa007d89efb7a01048475acd>`__)."
" The change emitted new compiler warnings when building C extensions "
"expecting ``char*``. This PEP doesn't change the return type to prevent "
"this issue."
msgstr ""

#: ../../peps/pep-0670.rst:193
msgid "Backwards Compatibility"
msgstr ""

#: ../../peps/pep-0670.rst:195
msgid "The PEP is designed to avoid C API incompatible changes."
msgstr ""

#: ../../peps/pep-0670.rst:197
msgid ""
"Only C extensions explicitly targeting the limited C API version 3.11 "
"must now pass the expected types to functions: pointer arguments are no "
"longer cast to the expected types."
msgstr ""

#: ../../peps/pep-0670.rst:201
msgid ""
"Function arguments of pointer types are still cast and return types are "
"not changed to prevent emitting new compiler warnings."
msgstr ""

#: ../../peps/pep-0670.rst:204
msgid ""
"Macros which can be used as l-value in an assignment are not modified by "
"this PEP to avoid incompatible changes."
msgstr ""

#: ../../peps/pep-0670.rst:209
msgid "Examples of Macro Pitfalls"
msgstr ""

#: ../../peps/pep-0670.rst:214
msgid "Macros:"
msgstr ""

#: ../../peps/pep-0670.rst:224
msgid ""
"If the *op* or the *X* argument has a side effect, the side effect is "
"duplicated: it executed twice by ``PySet_Check()`` and ``Py_IS_NAN()``."
msgstr ""

#: ../../peps/pep-0670.rst:227
msgid ""
"For example, the ``pos++`` argument in the ``PyUnicode_WRITE(kind, data, "
"pos++, ch)`` code has a side effect. This code is safe because the "
"``PyUnicode_WRITE()`` macro only uses its 3rd argument once and so does "
"not duplicate ``pos++`` side effect."
msgstr ""

#: ../../peps/pep-0670.rst:235
msgid ""
"Example of the `bpo-43181: Python macros don't shield arguments "
"<https://bugs.python.org/issue43181>`_. The ``PyObject_TypeCheck()`` "
"macro before it has been fixed:"
msgstr ""

#: ../../peps/pep-0670.rst:244
msgid "C++ usage example:"
msgstr ""

#: ../../peps/pep-0670.rst:250
msgid "The preprocessor first expands it:"
msgstr ""

#: ../../peps/pep-0670.rst:256
msgid ""
"C++ ``\"<\"`` and ``\">\"`` characters are not treated as brackets by the"
" preprocessor, so the ``Py_IS_TYPE()`` macro is invoked with 3 arguments:"
msgstr ""

#: ../../peps/pep-0670.rst:259
msgid "``ob``"
msgstr ""

#: ../../peps/pep-0670.rst:260
msgid "``f<a``"
msgstr ""

#: ../../peps/pep-0670.rst:261
msgid "``b>(c)``"
msgstr ""

#: ../../peps/pep-0670.rst:263
msgid ""
"The compilation fails with an error on ``Py_IS_TYPE()`` which only takes "
"2 arguments."
msgstr ""

#: ../../peps/pep-0670.rst:266
msgid ""
"The bug is that the *op* and *tp* arguments of ``PyObject_TypeCheck()`` "
"must be put between parentheses: replace ``Py_IS_TYPE(ob, tp)`` with "
"``Py_IS_TYPE((ob), (tp))``. In regular C code, these parentheses are "
"redundant, can be seen as a bug, and so are often forgotten when writing "
"macros."
msgstr ""

#: ../../peps/pep-0670.rst:272
msgid ""
"To avoid Macro Pitfalls, the ``PyObject_TypeCheck()`` macro has been "
"converted to a static inline function: `commit "
"<https://github.com/python/cpython/commit/4bb2a1ebc569eee6f1b46ecef1965a26ae8cb76d>`__."
msgstr ""

#: ../../peps/pep-0670.rst:278
msgid "Examples of hard to read macros"
msgstr ""

#: ../../peps/pep-0670.rst:281
msgid "PyObject_INIT()"
msgstr ""

#: ../../peps/pep-0670.rst:283
msgid "Example showing the usage of commas in a macro which has a return value."
msgstr ""

#: ../../peps/pep-0670.rst:285
msgid "Python 3.7 macro:"
msgstr ""

#: ../../peps/pep-0670.rst:292 ../../peps/pep-0670.rst:338
msgid "Python 3.8 function (simplified code):"
msgstr ""

#: ../../peps/pep-0670.rst:307
msgid "The function doesn't need the line continuation character ``\"\\\"``."
msgstr ""

#: ../../peps/pep-0670.rst:308
msgid ""
"It has an explicit ``\"return op;\"`` rather than the surprising ``\", "
"(op)\"`` syntax at the end of the macro."
msgstr ""

#: ../../peps/pep-0670.rst:310
msgid ""
"It uses short statements on multiple lines, rather than being written as "
"a single long line."
msgstr ""

#: ../../peps/pep-0670.rst:312
msgid ""
"Inside the function, the *op* argument has the well defined type "
"``PyObject*`` and so doesn't need casts like ``(PyObject *)(op)``."
msgstr ""

#: ../../peps/pep-0670.rst:314
msgid ""
"Arguments don't need to be put inside parentheses: use ``typeobj``, "
"rather than ``(typeobj)``."
msgstr ""

#: ../../peps/pep-0670.rst:318
msgid "_Py_NewReference()"
msgstr ""

#: ../../peps/pep-0670.rst:320
msgid "Example showing the usage of an ``#ifdef`` inside a macro."
msgstr ""

#: ../../peps/pep-0670.rst:322
msgid "Python 3.7 macro (simplified code):"
msgstr ""

#: ../../peps/pep-0670.rst:350
msgid "PyUnicode_READ_CHAR()"
msgstr ""

#: ../../peps/pep-0670.rst:352
msgid ""
"This macro reuses arguments, and possibly calls ``PyUnicode_KIND`` "
"multiple times:"
msgstr ""

#: ../../peps/pep-0670.rst:369
msgid "Possible implementation as a static inlined function:"
msgstr ""

#: ../../peps/pep-0670.rst:392
msgid "Macros converted to functions since Python 3.8"
msgstr ""

#: ../../peps/pep-0670.rst:394
msgid ""
"This is a list of macros already converted to functions between Python "
"3.8 and Python 3.11. Even though some converted macros (like "
"``Py_INCREF()``) are very commonly used by C extensions, these "
"conversions did not significantly impact Python performance and most of "
"them didn't break backward compatibility."
msgstr ""

#: ../../peps/pep-0670.rst:402
msgid "Macros converted to static inline functions"
msgstr ""

#: ../../peps/pep-0670.rst:404
msgid "Python 3.8:"
msgstr ""

#: ../../peps/pep-0670.rst:406
msgid "``Py_DECREF()``"
msgstr ""

#: ../../peps/pep-0670.rst:407
msgid "``Py_INCREF()``"
msgstr ""

#: ../../peps/pep-0670.rst:408
msgid "``Py_XDECREF()``"
msgstr ""

#: ../../peps/pep-0670.rst:409
msgid "``Py_XINCREF()``"
msgstr ""

#: ../../peps/pep-0670.rst:410
msgid "``PyObject_INIT()``"
msgstr ""

#: ../../peps/pep-0670.rst:411
msgid "``PyObject_INIT_VAR()``"
msgstr ""

#: ../../peps/pep-0670.rst:412
msgid "``_PyObject_GC_UNTRACK()``"
msgstr ""

#: ../../peps/pep-0670.rst:413
msgid "``_Py_Dealloc()``"
msgstr ""

#: ../../peps/pep-0670.rst:416
msgid "Macros converted to regular functions"
msgstr ""

#: ../../peps/pep-0670.rst:418
msgid "Python 3.9:"
msgstr ""

#: ../../peps/pep-0670.rst:420
msgid "``PyIndex_Check()``"
msgstr ""

#: ../../peps/pep-0670.rst:421
msgid "``PyObject_CheckBuffer()``"
msgstr ""

#: ../../peps/pep-0670.rst:422
msgid "``PyObject_GET_WEAKREFS_LISTPTR()``"
msgstr ""

#: ../../peps/pep-0670.rst:423
msgid "``PyObject_IS_GC()``"
msgstr ""

#: ../../peps/pep-0670.rst:424
msgid "``PyObject_NEW()``: alias to ``PyObject_New()``"
msgstr ""

#: ../../peps/pep-0670.rst:425
msgid "``PyObject_NEW_VAR()``: alias to ``PyObjectVar_New()``"
msgstr ""

#: ../../peps/pep-0670.rst:427
msgid ""
"To avoid performance slowdown on Python built without LTO, private static"
" inline functions have been added to the internal C API:"
msgstr ""

#: ../../peps/pep-0670.rst:430
msgid "``_PyIndex_Check()``"
msgstr ""

#: ../../peps/pep-0670.rst:431
msgid "``_PyObject_IS_GC()``"
msgstr ""

#: ../../peps/pep-0670.rst:432
msgid "``_PyType_HasFeature()``"
msgstr ""

#: ../../peps/pep-0670.rst:433
msgid "``_PyType_IS_GC()``"
msgstr ""

#: ../../peps/pep-0670.rst:437
msgid "Static inline functions converted to regular functions"
msgstr ""

#: ../../peps/pep-0670.rst:439
msgid "Python 3.11:"
msgstr ""

#: ../../peps/pep-0670.rst:441
msgid "``PyObject_CallOneArg()``"
msgstr ""

#: ../../peps/pep-0670.rst:442
msgid "``PyObject_Vectorcall()``"
msgstr ""

#: ../../peps/pep-0670.rst:443
msgid "``PyVectorcall_Function()``"
msgstr ""

#: ../../peps/pep-0670.rst:444
msgid "``_PyObject_FastCall()``"
msgstr ""

#: ../../peps/pep-0670.rst:446
msgid ""
"To avoid performance slowdown on Python built without LTO, a private "
"static inline function has been added to the internal C API:"
msgstr ""

#: ../../peps/pep-0670.rst:449
msgid "``_PyVectorcall_FunctionInline()``"
msgstr ""

#: ../../peps/pep-0670.rst:453
msgid "Incompatible changes"
msgstr ""

#: ../../peps/pep-0670.rst:455
msgid ""
"While other converted macros didn't break the backward compatibility, "
"there is an exception."
msgstr ""

#: ../../peps/pep-0670.rst:458
msgid ""
"The 3 macros ``Py_REFCNT()``, ``Py_TYPE()`` and ``Py_SIZE()`` have been "
"converted to static inline functions in Python 3.10 and 3.11 to disallow "
"using them as l-value in assignment. It is an incompatible change made on"
" purpose: see `bpo-39573 <https://bugs.python.org/issue39573>`_ for the "
"rationale."
msgstr ""

#: ../../peps/pep-0670.rst:464
msgid ""
"This PEP does not propose converting macros which can be used as l-value "
"to avoid introducing new incompatible changes."
msgstr ""

#: ../../peps/pep-0670.rst:469
msgid "Performance concerns and benchmarks"
msgstr ""

#: ../../peps/pep-0670.rst:471
msgid ""
"There have been concerns that converting macros to functions can degrade "
"performance."
msgstr ""

#: ../../peps/pep-0670.rst:474
msgid ""
"This section explains performance concerns and shows benchmark results "
"using `PR 29728 <https://github.com/python/cpython/pull/29728>`_, which "
"replaces the following static inline functions with macros:"
msgstr ""

#: ../../peps/pep-0670.rst:478
msgid "``PyObject_TypeCheck()``"
msgstr ""

#: ../../peps/pep-0670.rst:479
msgid "``PyType_Check()``, ``PyType_CheckExact()``"
msgstr ""

#: ../../peps/pep-0670.rst:480
msgid "``PyType_HasFeature()``"
msgstr ""

#: ../../peps/pep-0670.rst:481
msgid "``PyVectorcall_NARGS()``"
msgstr ""

#: ../../peps/pep-0670.rst:482
msgid "``Py_DECREF()``, ``Py_XDECREF()``"
msgstr ""

#: ../../peps/pep-0670.rst:483
msgid "``Py_INCREF()``, ``Py_XINCREF()``"
msgstr ""

#: ../../peps/pep-0670.rst:484
msgid "``Py_IS_TYPE()``"
msgstr ""

#: ../../peps/pep-0670.rst:485
msgid "``Py_NewRef()``"
msgstr ""

#: ../../peps/pep-0670.rst:486
msgid "``Py_REFCNT()``, ``Py_TYPE()``, ``Py_SIZE()``"
msgstr ""

#: ../../peps/pep-0670.rst:489
msgid ""
"The benchmarks were run on Fedora 35 (Linux) with GCC 11 on a laptop with"
" 8 logical CPUs (4 physical CPU cores)."
msgstr ""

#: ../../peps/pep-0670.rst:494
msgid "Static inline functions"
msgstr ""

#: ../../peps/pep-0670.rst:496
msgid ""
"First of all, converting macros to *static inline* functions has "
"negligible impact on performance: the measured differences are consistent"
" with noise due to unrelated factors."
msgstr ""

#: ../../peps/pep-0670.rst:500
msgid ""
"Static inline functions are a new feature in the C99 standard. Modern C "
"compilers have efficient heuristics to decide if a function should be "
"inlined or not."
msgstr ""

#: ../../peps/pep-0670.rst:504
msgid ""
"When a C compiler decides to not inline, there is likely a good reason. "
"For example, inlining would reuse a register which requires to "
"save/restore the register value on the stack and so increases the stack "
"memory usage, or be less efficient."
msgstr ""

#: ../../peps/pep-0670.rst:509
msgid ""
"Benchmark of the ``./python -m test -j5`` command on Python built in "
"release mode with ``gcc -O3``, LTO and PGO:"
msgstr ""

#: ../../peps/pep-0670.rst:512
msgid "Macros (PR 29728): 361 sec +- 1 sec"
msgstr ""

#: ../../peps/pep-0670.rst:513
msgid "Static inline functions (reference): 361 sec +- 1 sec"
msgstr ""

#: ../../peps/pep-0670.rst:515
msgid ""
"There is **no significant performance difference** between macros and "
"static inline functions when static inline functions **are inlined**."
msgstr ""

#: ../../peps/pep-0670.rst:520
msgid "Debug build"
msgstr ""

#: ../../peps/pep-0670.rst:522
msgid ""
"Performance in debug builds *can* suffer when macros are converted to "
"functions. This is compensated by better debuggability: debuggers can "
"retrieve function names, set breakpoints inside functions, etc."
msgstr ""

#: ../../peps/pep-0670.rst:526
msgid ""
"On Windows, when Python is built in debug mode by Visual Studio, static "
"inline functions are not inlined."
msgstr ""

#: ../../peps/pep-0670.rst:529
msgid ""
"On other platforms, ``./configure --with-pydebug`` uses the ``-Og`` "
"compiler option on compilers that support it (including GCC and LLVM "
"Clang). ``-Og`` means “optimize debugging experience”. Otherwise, the "
"``-O0`` compiler option is used. ``-O0`` means “disable most "
"optimizations”."
msgstr ""

#: ../../peps/pep-0670.rst:535
msgid ""
"With GCC 11, ``gcc -Og`` can inline static inline functions, whereas "
"``gcc -O0`` does not inline static inline functions."
msgstr ""

#: ../../peps/pep-0670.rst:538
msgid ""
"Benchmark of the ``./python -m test -j10`` command on Python built in "
"debug mode with ``gcc -O0`` (that is, compiler optimizations, including "
"inlining, are explicitly disabled):"
msgstr ""

#: ../../peps/pep-0670.rst:542
msgid "Macros (PR 29728): 345 sec ± 5 sec"
msgstr ""

#: ../../peps/pep-0670.rst:543
msgid "Static inline functions (reference): 360 sec ± 6 sec"
msgstr ""

#: ../../peps/pep-0670.rst:545
msgid ""
"Replacing macros with static inline functions makes Python **1.04x "
"slower** when the compiler **does not inline** static inline functions."
msgstr ""

#: ../../peps/pep-0670.rst:549
msgid ""
"Note that benchmarks should not be run on a Python debug build. Moreover,"
" using link-time optimization (LTO) and profile-guided optimization (PGO)"
" is recommended for best performance and reliable benchmarks. PGO helps "
"the compiler to decide if functions should be inlined or not."
msgstr ""

#: ../../peps/pep-0670.rst:556
msgid "Force inlining"
msgstr ""

#: ../../peps/pep-0670.rst:558
msgid ""
"The ``Py_ALWAYS_INLINE`` macro can be used to force inlining. This macro "
"uses ``__attribute__((always_inline))`` with GCC and Clang, and "
"``__forceinline`` with MSC."
msgstr ""

#: ../../peps/pep-0670.rst:562
msgid ""
"Previous attempts to use ``Py_ALWAYS_INLINE`` didn't show any benefit, "
"and were abandoned. See for example `bpo-45094 "
"<https://bugs.python.org/issue45094>`_ \"Consider using ``__forceinline``"
" and ``__attribute__((always_inline))`` on static inline functions "
"(``Py_INCREF``, ``Py_TYPE``) for debug build\"."
msgstr ""

#: ../../peps/pep-0670.rst:567
msgid ""
"When the ``Py_INCREF()`` macro was converted to a static inline function "
"in 2018 (`commit "
"<https://github.com/python/cpython/commit/2aaf0c12041bcaadd7f2cc5a54450eefd7a6ff12>`__),"
" it was decided not to force inlining. The machine code was analyzed with"
" multiple C compilers and compiler options, and ``Py_INCREF()`` was "
"always inlined without having to force inlining. The only case where it "
"was not inlined was the debug build. See discussion in `bpo-35059 "
"<https://bugs.python.org/issue35059>`_ \"Convert ``Py_INCREF()`` and "
"``PyObject_INIT()`` to inlined functions\"."
msgstr ""

#: ../../peps/pep-0670.rst:579
msgid "Disabling inlining"
msgstr ""

#: ../../peps/pep-0670.rst:581
msgid ""
"On the other side, the ``Py_NO_INLINE`` macro can be used to disable "
"inlining.  It can be used to reduce the stack memory usage, or to prevent"
" inlining on LTO+PGO builds, which generally inline code more "
"aggressively: see `bpo-33720 <https://bugs.python.org/issue33720>`_. The "
"``Py_NO_INLINE`` macro uses ``__attribute__ ((noinline))`` with GCC and "
"Clang, and ``__declspec(noinline)`` with MSC."
msgstr ""

#: ../../peps/pep-0670.rst:588
msgid ""
"This technique is available, though we currently don't know a concrete "
"function for which it would be useful. Note that with macros, it is not "
"possible to disable inlining at all."
msgstr ""

#: ../../peps/pep-0670.rst:594
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/pep-0670.rst:597
msgid "Keep macros, but fix some macro issues"
msgstr ""

#: ../../peps/pep-0670.rst:599
msgid "Macros are always \"inlined\" with any C compiler."
msgstr ""

#: ../../peps/pep-0670.rst:601
msgid ""
"The duplication of side effects can be worked around in the caller of the"
" macro."
msgstr ""

#: ../../peps/pep-0670.rst:604
msgid ""
"People using macros should be considered \"consenting adults\". People "
"who feel unsafe with macros should simply not use them."
msgstr ""

#: ../../peps/pep-0670.rst:607
msgid ""
"These ideas are rejected because macros *are* error prone, and it is too "
"easy to miss a macro pitfall when writing and reviewing macro code. "
"Moreover, macros are harder to read and maintain than functions."
msgstr ""

#: ../../peps/pep-0670.rst:613
msgid "Post History"
msgstr ""

#: ../../peps/pep-0670.rst:615
msgid "python-dev mailing list threads:"
msgstr ""

#: ../../peps/pep-0670.rst:617
msgid ""
"`Version 2 of PEP 670 - Convert macros to functions in the Python C API "
"<https://mail.python.org/archives/list/python-"
"dev@python.org/thread/VM6I3UHVMME6QRSUOYLK6N2OZHP454W6/>`_ (February "
"2022)"
msgstr ""

#: ../../peps/pep-0670.rst:620
msgid ""
"`Steering Council reply to PEP 670 -- Convert macros to functions in the "
"Python C API <https://mail.python.org/archives/list/python-"
"dev@python.org/message/IJ3IBVY3JDPROKX55YNDT6XZTVTTPGOP/>`_ (February "
"2022)"
msgstr ""

#: ../../peps/pep-0670.rst:624
msgid ""
"`PEP 670: Convert macros to functions in the Python C API "
"<https://mail.python.org/archives/list/python-"
"dev@python.org/thread/2GN646CGWGTO6ZHHU7JTA5XWDF4ULM77/>`_ (October 2021)"
msgstr ""

#: ../../peps/pep-0670.rst:630
msgid "References"
msgstr "Referências"

#: ../../peps/pep-0670.rst:633
msgid ""
"`bpo-45490 <https://bugs.python.org/issue45490>`_: [C API] PEP 670: "
"Convert macros to functions in the Python C API (October 2021)."
msgstr ""

#: ../../peps/pep-0670.rst:636
msgid ""
"`What to do with unsafe macros <https://discuss.python.org/t/what-to-do-"
"with-unsafe-macros/7771>`_ (March 2021)."
msgstr ""

#: ../../peps/pep-0670.rst:639
msgid ""
"`bpo-43502 <https://bugs.python.org/issue43502>`_: [C-API] Convert "
"obvious unsafe macros to static inline functions (March 2021)."
msgstr ""

#: ../../peps/pep-0670.rst:645
msgid "Version History"
msgstr ""

#: ../../peps/pep-0670.rst:647
msgid "Version 2:"
msgstr ""

#: ../../peps/pep-0670.rst:649
msgid "Stricter policy on not changing argument types and return type."
msgstr ""

#: ../../peps/pep-0670.rst:650
msgid ""
"Better explain why pointer arguments require a cast to not emit new "
"compiler warnings."
msgstr ""

#: ../../peps/pep-0670.rst:652
msgid "Macros which can be used as l-values are no longer modified by the PEP."
msgstr ""

#: ../../peps/pep-0670.rst:654
msgid "Macros having multiple return types are no longer modified by the PEP."
msgstr ""

#: ../../peps/pep-0670.rst:656
msgid "Limited C API version 3.11 no longer casts pointer arguments."
msgstr ""

#: ../../peps/pep-0670.rst:657
msgid ""
"No longer remove return values of macros \"which should not have a return"
" value\"."
msgstr ""

#: ../../peps/pep-0670.rst:659
msgid "Add \"Macros converted to functions since Python 3.8\" section."
msgstr ""

#: ../../peps/pep-0670.rst:660
msgid "Add \"Benchmark comparing macros and static inline functions\" section."
msgstr ""

#: ../../peps/pep-0670.rst:663
msgid "Version 1: First public version"
msgstr ""

#: ../../peps/pep-0670.rst:667
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-0670.rst:669
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

#~ msgid ""
#~ "Erlend Egeberg Aasland "
#~ "<erlend.aasland@protonmail.com>, Victor Stinner "
#~ "<vstinner@python.org>"
#~ msgstr ""

#~ msgid ""
#~ "Performance in debug builds *can* suffer"
#~ " when macros are converted to "
#~ "functions. This is compensated by better"
#~ " debuggability: debuggers can retreive "
#~ "function names, set breakpoints inside "
#~ "functions, etc."
#~ msgstr ""

