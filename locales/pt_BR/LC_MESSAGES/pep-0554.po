# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-14 02:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../peps/peps/pep-0554.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/peps/pep-0554.rst:3
msgid "Eric Snow <ericsnowcurrently@gmail.com>"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/peps/pep-0554.rst:4
msgid ""
"https://discuss.python.org/t/pep-554-multiple-interpreters-in-the-"
"stdlib/24855"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Status"
msgstr "Status"

#: ../../peps/peps/pep-0554.rst:5
msgid "Superseded"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/peps/pep-0554.rst:6
msgid "Standards Track"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/peps/pep-0554.rst:8
msgid "05-Sep-2017"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/peps/pep-0554.rst:9
msgid "3.13"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/peps/pep-0554.rst:10
msgid ""
"`07-Sep-2017 <https://mail.python.org/archives/list/python-ideas@python.org/"
"thread/HQQWEE527HG3ILJVKQTXVSJIQO6NUSIA/>`__, `08-Sep-2017 <https://mail."
"python.org/archives/list/python-dev@python.org/thread/"
"NBWMA6LVD22XOUYC5ZMPBFWDQOECRP77/>`__, `13-Sep-2017 <https://mail.python.org/"
"archives/list/python-dev@python.org/thread/EG4FSFG5E3O22FTIUQOXMQ6X6B5X3DP7/"
">`__, `05-Dec-2017 <https://mail.python.org/archives/list/python-dev@python."
"org/thread/BCSRGAMCYB3NGXNU42U66J56XNZVMQP2/>`__, `04-May-2020 <https://mail."
"python.org/archives/list/python-dev@python.org/thread/"
"X2KPCSRVBD2QD5GP5IMXXZTGZ46OXD3D/>`__, `14-Mar-2023 <https://discuss.python."
"org/t/pep-554-multiple-interpreters-in-the-stdlib/24855/2/>`__, `01-Nov-2023 "
"<https://discuss.python.org/t/pep-554-multiple-interpreters-in-the-"
"stdlib/24855/26/>`__,"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Superseded-By"
msgstr ""

#: ../../peps/peps/pep-0554.rst:17
msgid "734"
msgstr ""

#: ../../peps/peps/pep-0554.rst:21
msgid ""
"This PEP effectively continues in a cleaner form in :pep:`734`. This PEP is "
"kept as-is for the sake of the various sections of background information "
"and deferred/rejected ideas that have been stripped from :pep:`734`."
msgstr ""

#: ../../peps/peps/pep-0554.rst:28
msgid "Abstract"
msgstr ""

#: ../../peps/peps/pep-0554.rst:30
msgid ""
"CPython has supported multiple interpreters in the same process (AKA "
"\"subinterpreters\") since version 1.5 (1997).  The feature has been "
"available via the C-API. [c-api]_  Multiple interpreters operate in "
"`relative isolation from one another <Interpreter Isolation_>`_, which "
"facilitates novel alternative approaches to `concurrency <Concurrency_>`_."
msgstr ""

#: ../../peps/peps/pep-0554.rst:37
msgid ""
"This proposal introduces the stdlib ``interpreters`` module.  It exposes the "
"basic functionality of multiple interpreters already provided by the C-API, "
"along with basic support for communicating between interpreters. This module "
"is especially relevant since :pep:`684` introduced a per-interpreter GIL in "
"Python 3.12."
msgstr ""

#: ../../peps/peps/pep-0554.rst:45
msgid "Proposal"
msgstr ""

#: ../../peps/peps/pep-0554.rst:47
msgid "Summary:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:49
msgid "add a new stdlib module: \"interpreters\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:50
msgid "add concurrent.futures.InterpreterPoolExecutor"
msgstr ""

#: ../../peps/peps/pep-0554.rst:51
msgid "help for extension module maintainers"
msgstr ""

#: ../../peps/peps/pep-0554.rst:55
msgid "The \"interpreters\" Module"
msgstr ""

#: ../../peps/peps/pep-0554.rst:57
msgid ""
"The ``interpreters`` module will provide a high-level interface to the "
"multiple interpreter functionality, and wrap a new low-level "
"``_interpreters`` (in the same way as the ``threading`` module). See the "
"`Examples`_ section for concrete usage and use cases."
msgstr ""

#: ../../peps/peps/pep-0554.rst:62
msgid ""
"Along with exposing the existing (in CPython) multiple interpreter support, "
"the module will also support a basic mechanism for passing data between "
"interpreters.  That involves setting \"shareable\" objects in the "
"``__main__`` module of a target subinterpreter.  Some such objects, like  "
"``os.pipe()``, may be used to communicate further. The module will also "
"provide a minimal implementation of \"channels\" as a demonstration of cross-"
"interpreter communication."
msgstr ""

#: ../../peps/peps/pep-0554.rst:70
msgid ""
"Note that *objects* are not shared between interpreters since they are tied "
"to the interpreter in which they were created.  Instead, the objects' *data* "
"is passed between interpreters.  See the `Shared Data`_ and `API For "
"Communication`_ sections for more details about sharing/communicating "
"between interpreters."
msgstr ""

#: ../../peps/peps/pep-0554.rst:77
msgid "API summary for interpreters module"
msgstr ""

#: ../../peps/peps/pep-0554.rst:79
msgid ""
"Here is a summary of the API for the ``interpreters`` module.  For a more in-"
"depth explanation of the proposed classes and functions, see the "
"`\"interpreters\" Module API`_ section below."
msgstr ""

#: ../../peps/peps/pep-0554.rst:83
msgid "For creating and using interpreters:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:86 ../../peps/peps/pep-0554.rst:100
#: ../../peps/peps/pep-0554.rst:124
msgid "signature"
msgstr ""

#: ../../peps/peps/pep-0554.rst:86 ../../peps/peps/pep-0554.rst:100
#: ../../peps/peps/pep-0554.rst:124
msgid "description"
msgstr ""

#: ../../peps/peps/pep-0554.rst:88
msgid "``list_all() -> [Interpreter]``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:88
msgid "Get all existing interpreters."
msgstr ""

#: ../../peps/peps/pep-0554.rst:90
msgid "``get_current() -> Interpreter``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:90
msgid "Get the currently running interpreter."
msgstr ""

#: ../../peps/peps/pep-0554.rst:92
msgid "``get_main() -> Interpreter``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:92
msgid "Get the main interpreter."
msgstr ""

#: ../../peps/peps/pep-0554.rst:94
msgid "``create() -> Interpreter``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:94
msgid "Initialize a new (idle) Python interpreter."
msgstr ""

#: ../../peps/peps/pep-0554.rst:102
msgid "``class Interpreter``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:102
msgid "A single interpreter."
msgstr ""

#: ../../peps/peps/pep-0554.rst:104
msgid "``.id``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:104
msgid "The interpreter's ID (read-only)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:106
msgid "``.is_running() -> bool``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:106
msgid "Is the interpreter currently executing code?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:108
msgid "``.close()``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:108
msgid "Finalize and destroy the interpreter."
msgstr ""

#: ../../peps/peps/pep-0554.rst:110
msgid "``.set_main_attrs(**kwargs)``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:110
msgid "Bind \"shareable\" objects in ``__main__``."
msgstr ""

#: ../../peps/peps/pep-0554.rst:112
msgid "``.get_main_attr(name)``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:112
msgid "Get a \"shareable\" object from ``__main__``."
msgstr ""

#: ../../peps/peps/pep-0554.rst:114
msgid "``.exec(src_str, /)``"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Run the given source code in the interpreter"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "(in the current thread)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:121
msgid "For communicating between interpreters:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:126
msgid "``is_shareable(obj) -> Bool``"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Can the object's data be passed"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "between interpreters?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:129
msgid "``create_channel() -> (RecvChannel, SendChannel)``"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "Create a new channel for passing"
msgstr ""

#: ../../peps/peps/pep-0554.rst
msgid "data between interpreters."
msgstr ""

#: ../../peps/peps/pep-0554.rst:134
msgid "concurrent.futures.InterpreterPoolExecutor"
msgstr ""

#: ../../peps/peps/pep-0554.rst:136
msgid ""
"An executor will be added that extends ``ThreadPoolExecutor`` to run per-"
"thread tasks in subinterpreters.  Initially, the only supported tasks will "
"be whatever ``Interpreter.exec()`` takes (e.g. a ``str`` script).  However, "
"we may also support some functions, as well as eventually a separate method "
"for pickling the task and arguments, to reduce friction (at the expense of "
"performance for short-running tasks)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:145
msgid "Help for Extension Module Maintainers"
msgstr ""

#: ../../peps/peps/pep-0554.rst:147
msgid ""
"In practice, an extension that implements multi-phase init (:pep:`489`) is "
"considered isolated and thus compatible with multiple interpreters. "
"Otherwise it is \"incompatible\"."
msgstr ""

#: ../../peps/peps/pep-0554.rst:151
msgid ""
"Many extension modules are still incompatible.  The maintainers and users of "
"such extension modules will both benefit when they are updated to support "
"multiple interpreters.  In the meantime, users may become confused by "
"failures when using multiple interpreters, which could negatively impact "
"extension maintainers.  See `Concerns`_ below."
msgstr ""

#: ../../peps/peps/pep-0554.rst:157
msgid ""
"To mitigate that impact and accelerate compatibility, we will do the "
"following:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:160
msgid ""
"be clear that extension modules are *not* required to support use in "
"multiple interpreters"
msgstr ""

#: ../../peps/peps/pep-0554.rst:162
msgid ""
"raise ``ImportError`` when an incompatible module is imported in a "
"subinterpreter"
msgstr ""

#: ../../peps/peps/pep-0554.rst:164
msgid "provide resources (e.g. docs) to help maintainers reach compatibility"
msgstr ""

#: ../../peps/peps/pep-0554.rst:165
msgid ""
"reach out to the maintainers of Cython and of the most used extension "
"modules (on PyPI) to get feedback and possibly provide assistance"
msgstr ""

#: ../../peps/peps/pep-0554.rst:170
msgid "Examples"
msgstr ""

#: ../../peps/peps/pep-0554.rst:173
msgid "Run isolated code in current OS thread"
msgstr ""

#: ../../peps/peps/pep-0554.rst:183
msgid "Run in a different thread"
msgstr ""

#: ../../peps/peps/pep-0554.rst:197
msgid "Pre-populate an interpreter"
msgstr ""

#: ../../peps/peps/pep-0554.rst:213
msgid "Handling an exception"
msgstr ""

#: ../../peps/peps/pep-0554.rst:226
msgid "Re-raising an exception"
msgstr ""

#: ../../peps/peps/pep-0554.rst:241
msgid "Note that this pattern is a candidate for later improvement."
msgstr ""

#: ../../peps/peps/pep-0554.rst:244
msgid "Interact with the __main__ namespace"
msgstr ""

#: ../../peps/peps/pep-0554.rst:256
msgid "Synchronize using an OS pipe"
msgstr ""

#: ../../peps/peps/pep-0554.rst:282
msgid "Sharing a file descriptor"
msgstr ""

#: ../../peps/peps/pep-0554.rst:296
msgid "Passing objects via pickle"
msgstr ""

#: ../../peps/peps/pep-0554.rst:325
msgid "Capturing an interpreter's stdout"
msgstr ""

#: ../../peps/peps/pep-0554.rst:348
msgid "A pipe (``os.pipe()``) could be used similarly."
msgstr ""

#: ../../peps/peps/pep-0554.rst:351
msgid "Running a module"
msgstr ""

#: ../../peps/peps/pep-0554.rst:360
msgid "Running as script (including zip archives & directories)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:369
msgid "Using a channel to communicate"
msgstr ""

#: ../../peps/peps/pep-0554.rst:411
msgid "Sharing a memoryview (imagine map-reduce)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:455
msgid "Rationale"
msgstr ""

#: ../../peps/peps/pep-0554.rst:457
msgid ""
"Running code in multiple interpreters provides a useful level of isolation "
"within the same process.  This can be leveraged in a number of ways.  "
"Furthermore, subinterpreters provide a well-defined framework in which such "
"isolation may extended.  (See :pep:`684`.)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:462
msgid ""
"Alyssa (Nick) Coghlan explained some of the benefits through a comparison "
"with multi-processing [benefits]_::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:483
msgid ""
"CPython has supported multiple interpreters, with increasing levels of "
"support, since version 1.5.  While the feature has the potential to be a "
"powerful tool, it has suffered from neglect because the multiple interpreter "
"capabilities are not readily available directly from Python.  Exposing the "
"existing functionality in the stdlib will help reverse the situation."
msgstr ""

#: ../../peps/peps/pep-0554.rst:490
msgid ""
"This proposal is focused on enabling the fundamental capability of multiple "
"interpreters, isolated from each other, in the same Python process.  This is "
"a new area for Python so there is relative uncertainly about the best tools "
"to provide as companions to interpreters.  Thus we minimize the "
"functionality we add in the proposal as much as possible."
msgstr ""

#: ../../peps/peps/pep-0554.rst:498
msgid "Concerns"
msgstr ""

#: ../../peps/peps/pep-0554.rst:500
msgid "\"subinterpreters are not worth the trouble\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:502
msgid ""
"Some have argued that subinterpreters do not add sufficient benefit to "
"justify making them an official part of Python.  Adding features to the "
"language (or stdlib) has a cost in increasing the size of the language.  So "
"an addition must pay for itself."
msgstr ""

#: ../../peps/peps/pep-0554.rst:507
msgid ""
"In this case, multiple interpreter support provide a novel concurrency model "
"focused on isolated threads of execution.  Furthermore, they provide an "
"opportunity for changes in CPython that will allow simultaneous use of "
"multiple CPU cores (currently prevented by the GIL--see :pep:`684`)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:513
msgid ""
"Alternatives to subinterpreters include threading, async, and "
"multiprocessing.  Threading is limited by the GIL and async isn't the right "
"solution for every problem (nor for every person). Multiprocessing is "
"likewise valuable in some but not all situations. Direct IPC (rather than "
"via the multiprocessing module) provides similar benefits but with the same "
"caveat."
msgstr ""

#: ../../peps/peps/pep-0554.rst:520
msgid ""
"Notably, subinterpreters are not intended as a replacement for any of the "
"above.  Certainly they overlap in some areas, but the benefits of "
"subinterpreters include isolation and (potentially) performance.  In "
"particular, subinterpreters provide a direct route to an alternate "
"concurrency model (e.g. CSP) which has found success elsewhere and will "
"appeal to some Python users.  That is the core value that the "
"``interpreters`` module will provide."
msgstr ""

#: ../../peps/peps/pep-0554.rst:528
msgid ""
"\"stdlib support for multiple interpreters adds extra burden on C extension "
"authors\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:531
msgid ""
"In the `Interpreter Isolation`_ section below we identify ways in which "
"isolation in CPython's subinterpreters is incomplete.  Most notable is "
"extension modules that use C globals to store internal state.  (:pep:`3121` "
"and :pep:`489` provide a solution to that problem, followed by some extra "
"APIs that improve efficiency, e.g. :pep:`573`)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:537
msgid ""
"Consequently, projects that publish extension modules may face an increased "
"maintenance burden as their users start using subinterpreters, where their "
"modules may break.  This situation is limited to modules that use C globals "
"(or use libraries that use C globals) to store internal state.  For numpy, "
"the reported-bug rate is one every 6 months. [bug-rate]_"
msgstr ""

#: ../../peps/peps/pep-0554.rst:544
msgid ""
"Ultimately this comes down to a question of how often it will be a problem "
"in practice: how many projects would be affected, how often their users will "
"be affected, what the additional maintenance burden will be for projects, "
"and what the overall benefit of subinterpreters is to offset those costs.  "
"The position of this PEP is that the actual extra maintenance burden will be "
"small and well below the threshold at which subinterpreters are worth it."
msgstr ""

#: ../../peps/peps/pep-0554.rst:552
msgid ""
"\"creating a new concurrency API deserves much more thought and "
"experimentation, so the new module shouldn't go into the stdlib right away, "
"if ever\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:556
msgid ""
"Introducing an API for a new concurrency model, like happened with asyncio, "
"is an extremely large project that requires a lot of careful consideration.  "
"It is not something that can be done as simply as this PEP proposes and "
"likely deserves significant time on PyPI to mature. (See `Nathaniel's post "
"<nathaniel-asyncio_>`_ on python-dev.)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:562
msgid ""
"However, this PEP does not propose any new concurrency API. At most it "
"exposes minimal tools (e.g. subinterpreters, channels) which may be used to "
"write code that follows patterns associated with (relatively) new-to-Python "
"`concurrency models <Concurrency_>`_. Those tools could also be used as the "
"basis for APIs for such concurrency models.  Again, this PEP does not "
"propose any such API."
msgstr ""

#: ../../peps/peps/pep-0554.rst:569
msgid ""
"\"there is no point to exposing subinterpreters if they still share the GIL\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:571
msgid "\"the effort to make the GIL per-interpreter is disruptive and risky\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:573
msgid ""
"A common misconception is that this PEP also includes a promise that "
"interpreters will no longer share the GIL.  When that is clarified, the next "
"question is \"what is the point?\".  This is already answered at length in "
"this PEP.  Just to be clear, the value lies in::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:584
msgid ""
"\"data sharing can have a negative impact on cache performance in multi-core "
"scenarios\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:587
msgid "(See [cache-line-ping-pong]_.)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:589
msgid ""
"This shouldn't be a problem for now as we have no immediate plans to "
"actually share data between interpreters, instead focusing on copying."
msgstr ""

#: ../../peps/peps/pep-0554.rst:595
msgid "About Subinterpreters"
msgstr ""

#: ../../peps/peps/pep-0554.rst:598
msgid "Concurrency"
msgstr ""

#: ../../peps/peps/pep-0554.rst:600
msgid ""
"Concurrency is a challenging area of software development.  Decades of "
"research and practice have led to a wide variety of concurrency models, each "
"with different goals.  Most center on correctness and usability."
msgstr ""

#: ../../peps/peps/pep-0554.rst:604
msgid ""
"One class of concurrency models focuses on isolated threads of execution "
"that interoperate through some message passing scheme.  A notable example is "
"Communicating Sequential Processes [CSP]_ (upon which Go's concurrency is "
"roughly based).  The intended isolation inherent to CPython's interpreters "
"makes them well-suited to this approach."
msgstr ""

#: ../../peps/peps/pep-0554.rst:612
msgid "Shared Data"
msgstr ""

#: ../../peps/peps/pep-0554.rst:614
msgid ""
"CPython's interpreters are inherently isolated (with caveats explained "
"below), in contrast to threads.  So the same communicate-via-shared-memory "
"approach doesn't work.  Without an alternative, effective use of concurrency "
"via multiple interpreters is significantly limited."
msgstr ""

#: ../../peps/peps/pep-0554.rst:620
msgid ""
"The key challenge here is that sharing objects between interpreters faces "
"complexity due to various constraints on object ownership, visibility, and "
"mutability.  At a conceptual level it's easier to reason about concurrency "
"when objects only exist in one interpreter at a time.  At a technical level, "
"CPython's current memory model limits how Python *objects* may be shared "
"safely between interpreters; effectively, objects are bound to the "
"interpreter in which they were created.  Furthermore, the complexity of "
"*object* sharing increases as interpreters become more isolated, e.g. after "
"GIL removal (though this is mitigated somewhat for some \"immortal\" objects "
"(see :pep:`683`)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:631
msgid ""
"Consequently, the mechanism for sharing needs to be carefully considered. "
"There are a number of valid solutions, several of which may be appropriate "
"to support in Python's stdlib and C-API.  Any such solution is likely to "
"share many characteristics with the others."
msgstr ""

#: ../../peps/peps/pep-0554.rst:636
msgid ""
"In the meantime, we propose here a minimal solution (``Interpreter."
"set_main_attrs()``), which sets some precedent for how objects are shared.  "
"More importantly, it facilitates the introduction of more advanced "
"approaches later and allows them to coexist and cooperate. In part to "
"demonstrate that, we will provide a basic implementation of \"channels\", as "
"a somewhat more advanced sharing solution."
msgstr ""

#: ../../peps/peps/pep-0554.rst:643
msgid "Separate proposals may cover:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:645
msgid ""
"the addition of a public C-API based on the implementation ``Interpreter."
"set_main_attrs()``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:647
msgid "the addition of other sharing approaches to the \"interpreters\" module"
msgstr ""

#: ../../peps/peps/pep-0554.rst:649
msgid ""
"The fundamental enabling feature for communication is that most objects can "
"be converted to some encoding of underlying raw data, which is safe to be "
"passed between interpreters.  For example, an ``int`` object can be turned "
"into a C ``long`` value, sent to another interpreter, and turned back into "
"an ``int`` object there.  As another example, ``None`` may be passed as-is."
msgstr ""

#: ../../peps/peps/pep-0554.rst:656
msgid ""
"Regardless, the effort to determine the best way forward here is mostly "
"outside the scope of this PEP.  In the meantime, this proposal describes a "
"basic interim solution using pipes (``os.pipe()``), as well as providing a "
"dedicated capability (\"channels\"). See `API For Communication`_ below."
msgstr ""

#: ../../peps/peps/pep-0554.rst:663
msgid "Interpreter Isolation"
msgstr ""

#: ../../peps/peps/pep-0554.rst:665
msgid ""
"CPython's interpreters are intended to be strictly isolated from each "
"other.  Each interpreter has its own copy of all modules, classes, "
"functions, and variables.  The same applies to state in C, including in "
"extension modules.  The CPython C-API docs explain more. [caveats]_"
msgstr ""

#: ../../peps/peps/pep-0554.rst:670
msgid ""
"However, there are ways in which interpreters do share some state. First of "
"all, some process-global state remains shared:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:673
msgid "file descriptors"
msgstr ""

#: ../../peps/peps/pep-0554.rst:674
msgid "low-level env vars"
msgstr ""

#: ../../peps/peps/pep-0554.rst:675
msgid "process memory (though allocators *are* isolated)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:676
msgid "builtin types (e.g. dict, bytes)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:677
msgid "singletons (e.g. None)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:678
msgid ""
"underlying static module data (e.g. functions) for builtin/extension/frozen "
"modules"
msgstr ""

#: ../../peps/peps/pep-0554.rst:681
msgid "There are no plans to change this."
msgstr ""

#: ../../peps/peps/pep-0554.rst:683
msgid ""
"Second, some isolation is faulty due to bugs or implementations that did not "
"take subinterpreters into account.  This includes things like extension "
"modules that rely on C globals. [cryptography]_  In these cases bugs should "
"be opened (some are already):"
msgstr ""

#: ../../peps/peps/pep-0554.rst:688
msgid "readline module hook functions (http://bugs.python.org/issue4202)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:689
msgid "memory leaks on re-init (http://bugs.python.org/issue21387)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:691
msgid ""
"Finally, some potential isolation is missing due to the current design of "
"CPython.  Improvements are currently going on to address gaps in this area:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:695
msgid ""
"extensions using the ``PyGILState_*`` API are somewhat incompatible "
"[gilstate]_"
msgstr ""

#: ../../peps/peps/pep-0554.rst:698
msgid "Existing Usage"
msgstr ""

#: ../../peps/peps/pep-0554.rst:700
msgid ""
"Multiple interpreter support has not been a widely used feature. In fact, "
"there have been only a handful of documented cases of widespread usage, "
"including `mod_wsgi <https://github.com/GrahamDumpleton/mod_wsgi>`_, "
"`OpenStack Ceph <https://github.com/ceph/ceph/pull/14971>`_, and `JEP "
"<https://github.com/ninia/jep>`_.  On the one hand, these cases provide "
"confidence that existing multiple interpreter support is relatively stable.  "
"On the other hand, there isn't much of a sample size from which to judge the "
"utility of the feature."
msgstr ""

#: ../../peps/peps/pep-0554.rst:712
msgid "Alternate Python Implementations"
msgstr ""

#: ../../peps/peps/pep-0554.rst:714
msgid ""
"I've solicited feedback from various Python implementors about support for "
"subinterpreters.  Each has indicated that they would be able to support "
"multiple interpreters in the same process (if they choose to) without a lot "
"of trouble.  Here are the projects I contacted:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:719
msgid "jython  ([jython]_)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:720
msgid "ironpython  (personal correspondence)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:721
msgid "pypy  (personal correspondence)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:722
msgid "micropython  (personal correspondence)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:732
msgid "\"interpreters\" Module API"
msgstr ""

#: ../../peps/peps/pep-0554.rst:734
msgid "The module provides the following functions::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:764
msgid "The module also provides the following class::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:868
msgid ""
"In addition to the functionality of ``Interpreter.set_main_attrs()``, the "
"module provides a related way to pass data between interpreters: channels.  "
"See `Channels`_ below."
msgstr ""

#: ../../peps/peps/pep-0554.rst:873
msgid "Uncaught Exceptions"
msgstr ""

#: ../../peps/peps/pep-0554.rst:875
msgid ""
"Regarding uncaught exceptions in ``Interpreter.exec()``, we noted that they "
"are \"effectively\" propagated into the code where ``interp.exec()`` was "
"called.  To prevent leaking exceptions (and tracebacks) between "
"interpreters, we create a surrogate of the exception and its traceback (see :"
"class:`traceback.TracebackException`), set it to ``__cause__`` on a new "
"``interpreters.RunFailedError``, and raise that."
msgstr ""

#: ../../peps/peps/pep-0554.rst:882
msgid ""
"Directly raising (a proxy of) the exception is problematic since it's harder "
"to distinguish between an error in the ``interp.exec()`` call and an "
"uncaught exception from the subinterpreter."
msgstr ""

#: ../../peps/peps/pep-0554.rst:888
msgid "Interpreter Restrictions"
msgstr ""

#: ../../peps/peps/pep-0554.rst:890
msgid ""
"Every new interpreter created by ``interpreters.create()`` now has specific "
"restrictions on any code it runs.  This includes the following:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:894
msgid ""
"importing an extension module fails if it does not implement multi-phase init"
msgstr ""

#: ../../peps/peps/pep-0554.rst:896
msgid "daemon threads may not be created"
msgstr ""

#: ../../peps/peps/pep-0554.rst:897
msgid "``os.fork()`` is not allowed (so no ``multiprocessing``)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:898
msgid ""
"``os.exec*()`` is not allowed (but \"fork+exec\", a la ``subprocess`` is "
"okay)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:901
msgid ""
"Note that interpreters created with the existing C-API do not have these "
"restrictions.  The same is true for the \"main\" interpreter, so existing "
"use of Python will not change."
msgstr ""

#: ../../peps/peps/pep-0554.rst:907
msgid ""
"We may choose to later loosen some of the above restrictions or provide a "
"way to enable/disable granular restrictions individually.  Regardless, "
"requiring multi-phase init from extension modules will always be a default "
"restriction."
msgstr ""

#: ../../peps/peps/pep-0554.rst:914
msgid "API For Communication"
msgstr ""

#: ../../peps/peps/pep-0554.rst:916
msgid ""
"As discussed in `Shared Data`_ above, multiple interpreter support is less "
"useful without a mechanism for sharing data (communicating) between them.  "
"Sharing actual Python objects between interpreters, however, has enough "
"potential problems that we are avoiding support for that in this proposal.  "
"Nor, as mentioned earlier, are we adding anything more than a basic "
"mechanism for communication."
msgstr ""

#: ../../peps/peps/pep-0554.rst:923
msgid ""
"That mechanism is the ``Interpreter.set_main_attrs()`` method. It may be "
"used to set up global variables before ``Interpreter.exec()`` is called.  "
"The name-value pairs passed to ``set_main_attrs()`` are bound as attributes "
"of the interpreter's ``__main__`` module. The values must be \"shareable\".  "
"See `Shareable Types`_ below."
msgstr ""

#: ../../peps/peps/pep-0554.rst:929
msgid ""
"Additional approaches to communicating and sharing objects are enabled "
"through ``Interpreter.set_main_attrs()``.  A shareable object could be "
"implemented which works like a queue, but with cross-interpreter safety. In "
"fact, this PEP does include an example of such an approach: channels."
msgstr ""

#: ../../peps/peps/pep-0554.rst:935
msgid "Shareable Types"
msgstr ""

#: ../../peps/peps/pep-0554.rst:937
msgid ""
"An object is \"shareable\" if its type supports shareable instances. The "
"type must implement a new internal protocol, which is used to convert an "
"object to interpreter-independent data and then converted back to an object "
"on the other side.  Also see `is_shareable() <interpreters-is-shareable_>`_ "
"above."
msgstr ""

#: ../../peps/peps/pep-0554.rst:943
msgid ""
"A minimal set of simple, immutable builtin types will be supported "
"initially, including:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:946
msgid "``None``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:947
msgid "``bool``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:948
msgid "``bytes``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:949
msgid "``str``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:950
msgid "``int``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:951
msgid "``float``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:953
msgid "We will also support a small number of complex types initially:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:955
msgid "``memoryview``, to allow sharing :pep:`3118` buffers"
msgstr ""

#: ../../peps/peps/pep-0554.rst:956
msgid "`channels <Channels_>`_"
msgstr ""

#: ../../peps/peps/pep-0554.rst:958
msgid ""
"Further builtin types may be supported later, complex or not. Limiting the "
"initial shareable types is a practical matter, reducing the potential "
"complexity of the initial implementation.  There are a number of strategies "
"we may pursue in the future to expand supported objects, once we have more "
"experience with interpreter isolation."
msgstr ""

#: ../../peps/peps/pep-0554.rst:964
msgid ""
"In the meantime, a separate proposal will discuss making the internal "
"protocol (and C-API) used by ``Interpreter.set_main_attrs()`` public. With "
"that protocol, support for other types could be added by extension modules."
msgstr ""

#: ../../peps/peps/pep-0554.rst:970
msgid "Communicating Through OS Pipes"
msgstr ""

#: ../../peps/peps/pep-0554.rst:972
msgid ""
"Even without a dedicated object for communication, users may already use "
"existing tools.  For example, one basic approach for sending data between "
"interpreters is to use a pipe (see ``os.pipe()``):"
msgstr ""

#: ../../peps/peps/pep-0554.rst:976
msgid ""
"interpreter A calls ``os.pipe()`` to get a read/write pair of file "
"descriptors (both ``int`` objects)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:978
msgid ""
"interpreter A calls ``interp.set_main_attrs()``, binding the read FD (or "
"embeds it using string formatting)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:980
msgid "interpreter A calls ``interp.exec()`` on interpreter B"
msgstr ""

#: ../../peps/peps/pep-0554.rst:981
msgid "interpreter A writes some bytes to the write FD"
msgstr ""

#: ../../peps/peps/pep-0554.rst:982
msgid "interpreter B reads those bytes"
msgstr ""

#: ../../peps/peps/pep-0554.rst:984
msgid ""
"Several of the earlier examples demonstrate this, such as `Synchronize using "
"an OS pipe`_."
msgstr ""

#: ../../peps/peps/pep-0554.rst:992
msgid "Channels"
msgstr ""

#: ../../peps/peps/pep-0554.rst:994
msgid ""
"The ``interpreters`` module will include a dedicated solution for passing "
"object data between interpreters: channels.  They are included in the module "
"in part to provide an easier mechanism than using ``os.pipe()`` and in part "
"to demonstrate how libraries may take advantage of ``Interpreter."
"set_main_attrs()`` and the protocol it uses."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1001
msgid ""
"A channel is a simplex FIFO.  It is a basic, opt-in data sharing mechanism "
"that draws inspiration from pipes, queues, and CSP's channels. [fifo]_ The "
"main difference from pipes is that channels can be associated with zero or "
"more interpreters on either end.  Like queues, which are also many-to-many, "
"channels are buffered (though they also offer methods with unbuffered "
"semantics)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1008
msgid ""
"Channels have two operations: send and receive.  A key characteristic of "
"those operations is that channels transmit data derived from Python objects "
"rather than the objects themselves.  When objects are sent, their data is "
"extracted.  When the \"object\" is received in the other interpreter, the "
"data is converted back into an object owned by that interpreter."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1015
msgid ""
"To make this work, the mutable shared state will be managed by the Python "
"runtime, not by any of the interpreters.  Initially we will support only one "
"type of objects for shared state: the channels provided by ``interpreters."
"create_channel()``.  Channels, in turn, will carefully manage passing "
"objects between interpreters."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1021
msgid ""
"This approach, including keeping the API minimal, helps us avoid further "
"exposing any underlying complexity to Python users."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1024
msgid ""
"The ``interpreters`` module provides the following function related to "
"channels::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1036
msgid "The module also provides the following channel-related classes::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1099
msgid "Caveats For Shared Objects"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1101
msgid ""
"Again, Python objects are not shared between interpreters. However, in some "
"cases data those objects wrap is actually shared and not just copied.  One "
"example might be :pep:`3118` buffers."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1105
msgid ""
"In those cases the object in the original interpreter is kept alive until "
"the shared data in the other interpreter is no longer used. Then object "
"destruction can happen like normal in the original interpreter, along with "
"the previously shared data."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1112
msgid "Documentation"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1114
msgid ""
"The new stdlib docs page for the ``interpreters`` module will include the "
"following:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1117
msgid ""
"(at the top) a clear note that support for multiple interpreters is not "
"required from extension modules"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1119
msgid "some explanation about what subinterpreters are"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1120
msgid ""
"brief examples of how to use multiple interpreters (and communicating "
"between them)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1122
msgid "a summary of the limitations of using multiple interpreters"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1123
msgid ""
"(for extension maintainers) a link to the resources for ensuring multiple "
"interpreters compatibility"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1125
msgid "much of the API information in this PEP"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1127
msgid ""
"Docs about resources for extension maintainers already exist on the "
"`Isolating Extension Modules <isolation-howto_>`_ howto page.  Any extra "
"help will be added there.  For example, it may prove helpful to discuss "
"strategies for dealing with linked libraries that keep their own "
"subinterpreter-incompatible global state."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1136
msgid ""
"Note that the documentation will play a large part in mitigating any "
"negative impact that the new ``interpreters`` module might have on extension "
"module maintainers."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1140
msgid ""
"Also, the ``ImportError`` for incompatible extension modules will be updated "
"to clearly say it is due to missing multiple interpreters compatibility and "
"that extensions are not required to provide it.  This will help set user "
"expectations properly."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1146
msgid "Alternative Solutions"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1148
msgid ""
"One possible alternative to a new module is to add support for interpreters "
"to ``concurrent.futures``.  There are several reasons why that wouldn't work:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1151
msgid ""
"the obvious place to look for multiple interpreters support is an "
"\"interpreters\" module, much as with \"threading\", etc."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1153
msgid ""
"``concurrent.futures`` is all about executing functions but currently we "
"don't have a good way to run a function from one interpreter in another"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1157
msgid ""
"Similar reasoning applies for support in the ``multiprocessing`` module."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1161
msgid "Open Questions"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1163
msgid ""
"will is be too confusing that ``interp.exec()`` runs in the current thread?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1164
msgid ""
"should we add pickling fallbacks right now for ``interp.exec()``, and/or "
"``Interpreter.set_main_attrs()`` and ``Interpreter.get_main_attr()``?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1166
msgid "should we support (limited) functions in ``interp.exec()`` right now?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1167
msgid "rename ``Interpreter.close()`` to ``Interpreter.destroy()``?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1168
msgid "drop ``Interpreter.get_main_attr()``, since we have channels?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1169
msgid "should channels be its own PEP?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1173
msgid "Deferred Functionality"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1175
msgid ""
"In the interest of keeping this proposal minimal, the following "
"functionality has been left out for future consideration.  Note that this is "
"not a judgement against any of said capability, but rather a deferment.  "
"That said, each is arguably valid."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1181
msgid "Add convenience API"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1183
msgid ""
"There are a number of things I can imagine would smooth out *hypothetical* "
"rough edges with the new module:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1186
msgid ""
"add something like ``Interpreter.run()`` or ``Interpreter.call()`` that "
"calls ``interp.exec()`` and falls back to pickle"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1188
msgid ""
"fall back to pickle in ``Interpreter.set_main_attrs()`` and ``Interpreter."
"get_main_attr()``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1191
msgid "These would be easy to do if this proves to be a pain point."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1194
msgid ""
"Avoid possible confusion about interpreters running in the current thread"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1196
msgid ""
"One regular point of confusion has been that ``Interpreter.exec()`` executes "
"in the current OS thread, temporarily blocking the current Python thread.  "
"It may be worth doing something to avoid that confusion."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1200
msgid "Some possible solutions for this hypothetical problem:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1202
msgid "by default, run in a new thread?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1203
msgid "add ``Interpreter.exec_in_thread()``?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1204
msgid "add ``Interpreter.exec_in_current_thread()``?"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1206
msgid ""
"In earlier versions of this PEP the method was ``interp.run()``. The simple "
"change to ``interp.exec()`` alone will probably reduce confusion "
"sufficiently, when coupled with educating users via the docs.  It it turns "
"out to be a real problem, we can pursue one of the alternatives at that "
"point."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1213
msgid "Clarify \"running\" vs. \"has threads\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:1215
msgid ""
"``Interpreter.is_running()`` refers specifically to whether or not "
"``Interpreter.exec()`` (or similar) is running somewhere.  It does not say "
"anything about if the interpreter has any subthreads running.  That "
"information might be helpful."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1220
msgid "Some things we could do:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1222
msgid ""
"rename ``Interpreter.is_running()`` to ``Interpreter.is_running_main()``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1223
msgid ""
"add ``Interpreter.has_threads()``, to complement ``Interpreter.is_running()``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1224
msgid "expand to ``Interpreter.is_running(main=True, threads=False)``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1226
msgid "None of these are urgent and any could be done later, if desired."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1229
msgid "A Dunder Method For Sharing"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1231
msgid ""
"We could add a special method, like ``__xid__`` to correspond to ``tp_xid``. "
"At the very least, it would allow Python types to convert their instances to "
"some other type that implements ``tp_xid``."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1235
msgid ""
"The problem is that exposing this capability to Python code presents a "
"degree of complixity that hasn't been explored yet, nor is there a "
"compelling case to investigate that complexity."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1240
msgid "Interpreter.call()"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1242
msgid ""
"It would be convenient to run existing functions in subinterpreters "
"directly.  ``Interpreter.exec()`` could be adjusted to support this or a "
"``call()`` method could be added::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1248
msgid ""
"This suffers from the same problem as sharing objects between interpreters "
"via queues.  The minimal solution (running a source string) is sufficient "
"for us to get the feature out where it can be explored."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1253
msgid "Interpreter.run_in_thread()"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1255
msgid ""
"This method would make a ``interp.exec()`` call for you in a thread. Doing "
"this using only ``threading.Thread`` and ``interp.exec()`` is relatively "
"trivial so we've left it out."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1260
msgid "Synchronization Primitives"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1262
msgid ""
"The ``threading`` module provides a number of synchronization primitives for "
"coordinating concurrent operations.  This is especially necessary due to the "
"shared-state nature of threading.  In contrast, interpreters do not share "
"state.  Data sharing is restricted to the runtime's shareable objects "
"capability, which does away with the need for explicit synchronization.  If "
"any sort of opt-in shared state support is added to CPython's interpreters "
"in the future, that same effort can introduce synchronization primitives to "
"meet that need."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1272
msgid "CSP Library"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1274
msgid ""
"A ``csp`` module would not be a large step away from the functionality "
"provided by this PEP.  However, adding such a module is outside the "
"minimalist goals of this proposal."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1279
msgid "Syntactic Support"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1281
msgid ""
"The ``Go`` language provides a concurrency model based on CSP, so it's "
"similar to the concurrency model that multiple interpreters support.  "
"However, ``Go`` also provides syntactic support, as well as several builtin "
"concurrency primitives, to make concurrency a first-class feature.  "
"Conceivably, similar syntactic (and builtin) support could be added to "
"Python using interpreters.  However, that is *way* outside the scope of this "
"PEP!"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1290
msgid "Multiprocessing"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1292
msgid ""
"The ``multiprocessing`` module could support interpreters in the same way it "
"supports threads and processes.  In fact, the module's maintainer, Davin "
"Potts, has indicated this is a reasonable feature request.  However, it is "
"outside the narrow scope of this PEP."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1298
msgid "C-extension opt-in/opt-out"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1300
msgid ""
"By using the ``PyModuleDef_Slot`` introduced by :pep:`489`, we could easily "
"add a mechanism by which C-extension modules could opt out of multiple "
"interpreter support.  Then the import machinery, when operating in a "
"subinterpreter, would need to check the module for support. It would raise "
"an ImportError if unsupported."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1306
msgid ""
"Alternately we could support opting in to multiple interpreters support. "
"However, that would probably exclude many more modules (unnecessarily) than "
"the opt-out approach.  Also, note that :pep:`489` defined that an "
"extension's use of the PEP's machinery implies multiple interpreters support."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1312
msgid ""
"The scope of adding the ModuleDef slot and fixing up the import machinery is "
"non-trivial, but could be worth it.  It all depends on how many extension "
"modules break under subinterpreters.  Given that there are relatively few "
"cases we know of through mod_wsgi, we can leave this for later."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1319
msgid "Poisoning channels"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1321
msgid ""
"CSP has the concept of poisoning a channel.  Once a channel has been "
"poisoned, any ``send()`` or ``recv()`` call on it would raise a special "
"exception, effectively ending execution in the interpreter that tried to use "
"the poisoned channel."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1326
msgid ""
"This could be accomplished by adding a ``poison()`` method to both ends of "
"the channel.  The ``close()`` method can be used in this way (mostly), but "
"these semantics are relatively specialized and can wait."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1331
msgid "Resetting __main__"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1333
msgid ""
"As proposed, every call to ``Interpreter.exec()`` will execute in the "
"namespace of the interpreter's existing ``__main__`` module.  This means "
"that data persists there between ``interp.exec()`` calls.  Sometimes this "
"isn't desirable and you want to execute in a fresh ``__main__``. Also, you "
"don't necessarily want to leak objects there that you aren't using any more."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1340
msgid ""
"Note that the following won't work right because it will clear too much (e."
"g. ``__name__`` and the other \"__dunder__\" attributes::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1345
msgid "Possible solutions include:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1347
msgid ""
"a ``create()`` arg to indicate resetting ``__main__`` after each ``interp."
"exec()`` call"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1349
msgid ""
"an ``Interpreter.reset_main`` flag to support opting in or out after the fact"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1351
msgid "an ``Interpreter.reset_main()`` method to opt in when desired"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1352
msgid "``importlib.util.reset_globals()`` [reset_globals]_"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1354
msgid ""
"Also note that resetting ``__main__`` does nothing about state stored in "
"other modules.  So any solution would have to be clear about the scope of "
"what is being reset.  Conceivably we could invent a mechanism by which any "
"(or every) module could be reset, unlike ``reload()`` which does not clear "
"the module before loading into it."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1360
msgid ""
"Regardless, since ``__main__`` is the execution namespace of the "
"interpreter, resetting it has a much more direct correlation to interpreters "
"and their dynamic state than does resetting other modules. So a more generic "
"module reset mechanism may prove unnecessary."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1365
msgid ""
"This isn't a critical feature initially.  It can wait until later if "
"desirable."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1369
msgid "Resetting an interpreter's state"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1371
msgid ""
"It may be nice to re-use an existing subinterpreter instead of spinning up a "
"new one.  Since an interpreter has substantially more state than just the "
"``__main__`` module, it isn't so easy to put an interpreter back into a "
"pristine/fresh state.  In fact, there *may* be parts of the state that "
"cannot be reset from Python code."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1377
msgid ""
"A possible solution is to add an ``Interpreter.reset()`` method.  This would "
"put the interpreter back into the state it was in when newly created.  If "
"called on a running interpreter it would fail (hence the main interpreter "
"could never be reset).  This would likely be more efficient than creating a "
"new interpreter, though that depends on what optimizations will be made "
"later to interpreter creation."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1384
msgid ""
"While this would potentially provide functionality that is not otherwise "
"available from Python code, it isn't a fundamental functionality.  So in the "
"spirit of minimalism here, this can wait. Regardless, I doubt it would be "
"controversial to add it post-PEP."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1390
msgid "Copy an existing interpreter's state"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1392
msgid ""
"Relatedly, it may be useful to support creating a new interpreter based on "
"an existing one, e.g. ``Interpreter.copy()``.  This ties into the idea that "
"a snapshot could be made of an interpreter's memory, which would make "
"starting up CPython, or creating new interpreters, faster in general.  The "
"same mechanism could be used for a hypothetical ``Interpreter.reset()``, as "
"described previously."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1400
msgid "Shareable file descriptors and sockets"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1402
msgid ""
"Given that file descriptors and sockets are process-global resources, making "
"them shareable is a reasonable idea.  They would be a good candidate for the "
"first effort at expanding the supported shareable types.  They aren't "
"strictly necessary for the initial API."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1408
msgid "Integration with async"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1410
msgid "Per Antoine Pitrou [async]_::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1420
msgid ""
"The basic functionality of multiple interpreters support does not depend on "
"async and can be added later."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1423
msgid ""
"A possible solution is to provide async implementations of the blocking "
"channel methods (``recv()``, and ``send()``)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1426
msgid ""
"Alternately, \"readiness callbacks\" could be used to simplify use in async "
"scenarios.  This would mean adding an optional ``callback`` (kw-only) "
"parameter to the ``recv_nowait()`` and ``send_nowait()`` channel methods.  "
"The callback would be called once the object was sent or received "
"(respectively)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1432
msgid ""
"(Note that making channels buffered makes readiness callbacks less "
"important.)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1436
msgid "Support for iteration"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1438
msgid ""
"Supporting iteration on ``RecvChannel`` (via ``__iter__()`` or "
"``_next__()``) may be useful.  A trivial implementation would use the "
"``recv()`` method, similar to how files do iteration.  Since this isn't a "
"fundamental capability and has a simple analog, adding iteration support can "
"wait until later."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1445
msgid "Channel context managers"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1447
msgid ""
"Context manager support on ``RecvChannel`` and ``SendChannel`` may be "
"helpful.  The implementation would be simple, wrapping a call to ``close()`` "
"(or maybe ``release()``) like files do.  As with iteration, this can wait."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1453
msgid "Pipes and Queues"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1455
msgid ""
"With the proposed object passing mechanism of \"os.pipe()\", other similar "
"basic types aren't strictly required to achieve the minimal useful "
"functionality of multiple interpreters.  Such types include pipes (like "
"unbuffered channels, but one-to-one) and queues (like channels, but more "
"generic).  See below in `Rejected Ideas`_ for more information."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1461
msgid ""
"Even though these types aren't part of this proposal, they may still be "
"useful in the context of concurrency.  Adding them later is entirely "
"reasonable.  The could be trivially implemented as wrappers around "
"channels.  Alternatively they could be implemented for efficiency at the "
"same low level as channels."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1468
msgid "Return a lock from send()"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1470
msgid ""
"When sending an object through a channel, you don't have a way of knowing "
"when the object gets received on the other end.  One way to work around this "
"is to return a locked ``threading.Lock`` from ``SendChannel.send()`` that "
"unlocks once the object is received."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1475
msgid ""
"Alternately, the proposed ``SendChannel.send()`` (blocking) and "
"``SendChannel.send_nowait()`` provide an explicit distinction that is less "
"likely to confuse users."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1479
msgid ""
"Note that returning a lock would matter for buffered channels (i.e. "
"queues).  For unbuffered channels it is a non-issue."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1483
msgid "Support prioritization in channels"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1485
msgid "A simple example is ``queue.PriorityQueue`` in the stdlib."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1488
msgid "Support inheriting settings (and more?)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1490
msgid ""
"Folks might find it useful, when creating a new interpreter, to be able to "
"indicate that they would like some things \"inherited\" by the new "
"interpreter.  The mechanism could be a strict copy or it could be copy-on-"
"write.  The motivating example is with the warnings module (e.g. copy the "
"filters)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1496
msgid ""
"The feature isn't critical, nor would it be widely useful, so it can wait "
"until there's interest.  Notably, both suggested solutions will require "
"significant work, especially when it comes to complex objects and most "
"especially for mutable containers of mutable complex objects."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1503
msgid "Make exceptions shareable"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1505
msgid ""
"Exceptions are propagated out of ``run()`` calls, so it isn't a big leap to "
"make them shareable.  However, as noted elsewhere, it isn't essential or "
"(particularly common) so we can wait on doing that."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1511
msgid "Make everything shareable through serialization"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1513
msgid ""
"We could use pickle (or marshal) to serialize everything and thus make them "
"shareable.  Doing this is potentially inefficient, but it may be a matter of "
"convenience in the end. We can add it later, but trying to remove it later "
"would be significantly more painful."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1520
msgid "Make RunFailedError.__cause__ lazy"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1522
msgid ""
"An uncaught exception in a subinterpreter (from ``interp.exec()``) is copied "
"to the calling interpreter and set as ``__cause__`` on a ``RunFailedError`` "
"which is then raised.  That copying part involves some sort of "
"deserialization in the calling interpreter, which can be expensive (e.g. due "
"to imports) yet is not always necessary."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1528
msgid ""
"So it may be useful to use an ``ExceptionProxy`` type to wrap the serialized "
"exception and only deserialize it when needed.  That could be via "
"``ExceptionProxy__getattribute__()`` or perhaps through ``RunFailedError."
"resolve()`` (which would raise the deserialized exception and set "
"``RunFailedError.__cause__`` to the exception."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1534
msgid ""
"It may also make sense to have ``RunFailedError.__cause__`` be a descriptor "
"that does the lazy deserialization (and set ``__cause__``) on the "
"``RunFailedError`` instance."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1539
msgid "Return a value from ``interp.exec()``"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1541
msgid ""
"Currently ``interp.exec()`` always returns None.  One idea is to return the "
"return value from whatever the subinterpreter ran.  However, for now it "
"doesn't make sense.  The only thing folks can run is a string of code (i.e. "
"a script).  This is equivalent to ``PyRun_StringFlags()``, ``exec()``, or a "
"module body.  None of those \"return\" anything.  We can revisit this once "
"``interp.exec()`` supports functions, etc."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1549
msgid "Add a shareable synchronization primitive"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1551
msgid ""
"This would be ``_threading.Lock`` (or something like it) where interpreters "
"would actually share the underlying mutex.  The main concern is that locks "
"and isolated interpreters may not mix well (as learned in Go)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1556
msgid "We can add this later if it proves desirable without much trouble."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1559
msgid "Propagate SystemExit and KeyboardInterrupt Differently"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1561
msgid ""
"The exception types that inherit from ``BaseException`` (aside from "
"``Exception``) are usually treated specially.  These types are: "
"``KeyboardInterrupt``, ``SystemExit``, and ``GeneratorExit``.  It may make "
"sense to treat them specially when it comes to propagation from ``interp."
"exec()``.  Here are some options::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1572
msgid ""
"We aren't going to worry about handling them differently.  Threads already "
"ignore ``SystemExit``, so for now we will follow that pattern."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1576
msgid "Add an explicit release() and close() to channel end classes"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1578
msgid ""
"It can be convenient to have an explicit way to close a channel against "
"further global use.  Likewise it could be useful to have an explicit way to "
"release one of the channel ends relative to the current interpreter.  Among "
"other reasons, such a mechanism is useful for communicating overall state "
"between interpreters without the extra boilerplate that passing objects "
"through a channel directly would require."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1586
msgid ""
"The challenge is getting automatic release/close right without making it "
"hard to understand.  This is especially true when dealing with a non-empty "
"channel.  We should be able to get by without release/close for now."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1592
msgid "Add SendChannel.send_buffer()"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1594
msgid ""
"This method would allow no-copy sending of an object through a channel if it "
"supports the :pep:`3118` buffer protocol (e.g. memoryview)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1597
msgid ""
"Support for this is not fundamental to channels and can be added on later "
"without much disruption."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1601
msgid "Auto-run in a thread"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1603
msgid ""
"The PEP proposes a hard separation between subinterpreters and threads: if "
"you want to run in a thread you must create the thread yourself and call "
"``interp.exec()`` in it.  However, it might be convenient if ``interp."
"exec()`` could do that for you, meaning there would be less boilerplate."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1609
msgid ""
"Furthermore, we anticipate that users will want to run in a thread much more "
"often than not.  So it would make sense to make this the default behavior.  "
"We would add a kw-only param \"threaded\" (default ``True``) to ``interp."
"exec()`` to allow the run-in-the-current-thread operation."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1616
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1619
msgid "Explicit channel association"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1621
msgid ""
"Interpreters are implicitly associated with channels upon ``recv()`` and "
"``send()`` calls.  They are de-associated with ``release()`` calls.  The "
"alternative would be explicit methods.  It would be either ``add_channel()`` "
"and ``remove_channel()`` methods on ``Interpreter`` objects or something "
"similar on channel objects."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1627
msgid ""
"In practice, this level of management shouldn't be necessary for users. So "
"adding more explicit support would only add clutter to the API."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1631
msgid "Add an API based on pipes"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1633
msgid ""
"A pipe would be a simplex FIFO between exactly two interpreters.  For most "
"use cases this would be sufficient.  It could potentially simplify the "
"implementation as well.  However, it isn't a big step to supporting a many-"
"to-many simplex FIFO via channels.  Also, with pipes the API ends up being "
"slightly more complicated, requiring naming the pipes."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1640
msgid "Add an API based on queues"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1642
msgid ""
"Queues and buffered channels are almost the same thing.  The main difference "
"is that channels have a stronger relationship with context (i.e. the "
"associated interpreter)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1646
msgid ""
"The name \"Channel\" was used instead of \"Queue\" to avoid confusion with "
"the stdlib ``queue.Queue``."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1650
msgid "\"enumerate\""
msgstr ""

#: ../../peps/peps/pep-0554.rst:1652
msgid ""
"The ``list_all()`` function provides the list of all interpreters. In the "
"threading module, which partly inspired the proposed API, the function is "
"called ``enumerate()``.  The name is different here to avoid confusing "
"Python users that are not already familiar with the threading API.  For them "
"\"enumerate\" is rather unclear, whereas \"list_all\" is clear."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1660
msgid "Alternate solutions to prevent leaking exceptions across interpreters"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1662
msgid ""
"In function calls, uncaught exceptions propagate to the calling frame. The "
"same approach could be taken with ``interp.exec()``.  However, this would "
"mean that exception objects would leak across the inter-interpreter "
"boundary.  Likewise, the frames in the traceback would potentially leak."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1667
msgid ""
"While that might not be a problem currently, it would be a problem once "
"interpreters get better isolation relative to memory management (which is "
"necessary to stop sharing the GIL between interpreters).  We've resolved the "
"semantics of how the exceptions propagate by raising a ``RunFailedError`` "
"instead, for which ``__cause__`` wraps a safe proxy for the original "
"exception and traceback."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1674
msgid "Rejected possible solutions:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1676
msgid ""
"reproduce the exception and traceback in the original interpreter and raise "
"that."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1678
msgid ""
"raise a subclass of RunFailedError that proxies the original exception and "
"traceback."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1680
msgid "raise RuntimeError instead of RunFailedError"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1681
msgid ""
"convert at the boundary (a la ``subprocess.CalledProcessError``) (requires a "
"cross-interpreter representation)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1683
msgid ""
"support customization via ``Interpreter.excepthook`` (requires a cross-"
"interpreter representation)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1685
msgid ""
"wrap in a proxy at the boundary (including with support for something like "
"``err.raise()`` to propagate the traceback)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1687
msgid ""
"return the exception (or its proxy) from ``interp.exec()`` instead of "
"raising it"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1689
msgid ""
"return a result object (like ``subprocess`` does) [result-object]_ "
"(unnecessary complexity?)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1691
msgid ""
"throw the exception away and expect users to deal with unhandled exceptions "
"explicitly in the script they pass to ``interp.exec()`` (they can pass error "
"info out via channels); with threads you have to do something similar"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1697
msgid "Always associate each new interpreter with its own thread"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1699
msgid ""
"As implemented in the C-API, an interpreter is not inherently tied to any "
"thread.  Furthermore, it will run in any existing thread, whether created by "
"Python or not.  You only have to activate one of its thread states "
"(``PyThreadState``) in the thread first.  This means that the same thread "
"may run more than one interpreter (though obviously not at the same time)."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1706
msgid ""
"The proposed module maintains this behavior.  Interpreters are not tied to "
"threads.  Only calls to ``Interpreter.exec()`` are.  However, one of the key "
"objectives of this PEP is to provide a more human-centric concurrency "
"model.  With that in mind, from a conceptual standpoint the module *might* "
"be easier to understand if each interpreter were associated with its own "
"thread."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1713
msgid ""
"That would mean ``interpreters.create()`` would create a new thread and "
"``Interpreter.exec()`` would only execute in that thread (and nothing else "
"would).  The benefit is that users would not have to wrap ``Interpreter."
"exec()`` calls in a new ``threading.Thread``.  Nor would they be in a "
"position to accidentally pause the current interpreter (in the current "
"thread) while their interpreter executes."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1721
msgid ""
"The idea is rejected because the benefit is small and the cost is high. The "
"difference from the capability in the C-API would be potentially confusing.  "
"The implicit creation of threads is magical.  The early creation of threads "
"is potentially wasteful.  The inability to run arbitrary interpreters in an "
"existing thread would prevent some valid use cases, frustrating users.  "
"Tying interpreters to threads would require extra runtime modifications.  It "
"would also make the module's implementation overly complicated.  Finally, it "
"might not even make the module easier to understand."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1732
msgid "Only associate interpreters upon use"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1734
msgid ""
"Associate interpreters with channel ends only once ``recv()``, ``send()``, "
"etc. are called."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1737
msgid ""
"Doing this is potentially confusing and also can lead to unexpected races "
"where a channel is auto-closed before it can be used in the original "
"(creating) interpreter."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1742
msgid "Allow multiple simultaneous calls to Interpreter.exec()"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1744
msgid ""
"This would make sense especially if ``Interpreter.exec()`` were to manage "
"new threads for you (which we've rejected).  Essentially, each call would "
"run independently, which would be mostly fine from a narrow technical "
"standpoint, since each interpreter can have multiple threads."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1750
msgid ""
"The problem is that the interpreter has only one ``__main__`` module and "
"simultaneous ``Interpreter.exec()`` calls would have to sort out sharing "
"``__main__`` or we'd have to invent a new mechanism.  Neither would be "
"simple enough to be worth doing."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1756
msgid "Add a \"reraise\" method to RunFailedError"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1758
msgid ""
"While having ``__cause__`` set on ``RunFailedError`` helps produce a more "
"useful traceback, it's less helpful when handling the original error.  To "
"help facilitate this, we could add ``RunFailedError.reraise()``.  This "
"method would enable the following pattern::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1772
msgid ""
"This would be made even simpler if there existed a ``__reraise__`` protocol."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1775
msgid ""
"All that said, this is completely unnecessary.  Using ``__cause__`` is good "
"enough::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1786
msgid "Note that in extreme cases it may require a little extra boilerplate::"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1800
msgid "Implementation"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1802
msgid "The implementation of the PEP has 4 parts:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1804
msgid ""
"the high-level module described in this PEP (mostly a light wrapper around a "
"low-level C extension"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1806
msgid "the low-level C extension module"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1807
msgid "additions to the internal C-API needed by the low-level module"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1808
msgid ""
"secondary fixes/changes in the CPython runtime that facilitate the low-level "
"module (among other benefits)"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1811
msgid ""
"These are at various levels of completion, with more done the lower you go:"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1814
msgid ""
"the high-level module has been, at best, roughly implemented. However, fully "
"implementing it will be almost trivial."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1816
msgid ""
"the low-level module is mostly complete.  The bulk of the implementation was "
"merged into master in December 2018 as the \"_xxsubinterpreters\" module "
"(for the sake of testing multiple interpreters functionality).  Only the "
"exception propagation implementation remains to be finished, which will not "
"require extensive work."
msgstr ""

#: ../../peps/peps/pep-0554.rst:1822
msgid "all necessary C-API work has been finished"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1823
msgid "all anticipated work in the runtime has been finished"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1825
msgid ""
"The implementation effort for :pep:`554` is being tracked as part of a "
"larger project aimed at improving multi-core support in CPython. [multi-core-"
"project]_"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1831
msgid "References"
msgstr "Referências"

#: ../../peps/peps/pep-0554.rst:1834
msgid "https://docs.python.org/3/c-api/init.html#sub-interpreter-support"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1837
msgid ""
"https://en.wikipedia.org/wiki/Communicating_sequential_processes https://"
"github.com/futurecore/python-csp"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1841
msgid ""
"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe "
"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue "
"https://docs.python.org/3/library/queue.html#module-queue http://stackless."
"readthedocs.io/en/2.7-slp/library/stackless/channels.html https://golang.org/"
"doc/effective_go.html#sharing http://www.jtolds.com/writing/2016/03/go-"
"channels-are-bad-and-you-should-feel-bad/"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1849
msgid "https://docs.python.org/3/c-api/init.html#bugs-and-caveats"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1852
msgid "https://github.com/pyca/cryptography/issues/2299"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1855
msgid "https://bugs.python.org/issue10915 http://bugs.python.org/issue15751"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1859
msgid ""
"https://mail.python.org/pipermail/python-ideas/2017-September/047094.html"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1862
msgid ""
"https://mail.python.org/pipermail/python-ideas/2017-September/047122.html"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1865
msgid "https://mail.python.org/pipermail/python-dev/2017-September/149545.html"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1868
msgid ""
"https://mail.python.org/pipermail/python-dev/2017-September/149420.html "
"https://mail.python.org/pipermail/python-dev/2017-September/149585.html"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1872
msgid "https://mail.python.org/pipermail/python-dev/2017-September/149562.html"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1875
msgid "https://mail.python.org/pipermail/python-ideas/2017-May/045771.html"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1878
msgid "https://github.com/ericsnowcurrently/multi-core-python"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1881
msgid ""
"https://mail.python.org/archives/list/python-dev@python.org/"
"message/3HVRFWHDMWPNR367GXBILZ4JJAUQ2STZ/"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1886
msgid "mp-conn"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1887
msgid ""
"https://docs.python.org/3/library/multiprocessing.html#connection-objects"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1889
msgid "main-thread"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1890
msgid ""
"https://mail.python.org/pipermail/python-ideas/2017-September/047144.html "
"https://mail.python.org/pipermail/python-dev/2017-September/149566.html"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1893
msgid "petr-c-ext"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1894
msgid ""
"https://mail.python.org/pipermail/import-sig/2016-June/001062.html https://"
"mail.python.org/pipermail/python-ideas/2016-April/039748.html"
msgstr ""

#: ../../peps/peps/pep-0554.rst:1898
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/peps/pep-0554.rst:1900
msgid "This document has been placed in the public domain."
msgstr "Este documento foi colocado em domínio público."
