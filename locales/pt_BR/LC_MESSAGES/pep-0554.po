# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0554.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-0554.rst:3
msgid "Eric Snow <ericsnowcurrently@gmail.com>"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/pep-0554.rst:4
msgid ""
"https://discuss.python.org/t/pep-554-multiple-interpreters-in-the-"
"stdlib/24855"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-0554.rst:5
msgid "Draft"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-0554.rst:6
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-0554.rst:8
msgid "05-Sep-2017"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0554.rst:9
msgid "3.13"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-0554.rst:10
msgid ""
"`07-Sep-2017 <https://mail.python.org/archives/list/python-"
"ideas@python.org/thread/HQQWEE527HG3ILJVKQTXVSJIQO6NUSIA/>`__, "
"`08-Sep-2017 <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/NBWMA6LVD22XOUYC5ZMPBFWDQOECRP77/>`__, `13-Sep-2017"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/EG4FSFG5E3O22FTIUQOXMQ6X6B5X3DP7/>`__, `05-Dec-2017"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/BCSRGAMCYB3NGXNU42U66J56XNZVMQP2/>`__, `04-May-2020"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/X2KPCSRVBD2QD5GP5IMXXZTGZ46OXD3D/>`__, `14-Mar-2023"
" <https://discuss.python.org/t/pep-554-multiple-interpreters-in-the-"
"stdlib/24855/2/>`__,"
msgstr ""

#: ../../peps/pep-0554.rst:19
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0554.rst:21
msgid ""
"CPython has supported multiple interpreters in the same process (AKA "
"\"subinterpreters\") since version 1.5 (1997).  The feature has been "
"available via the C-API. [c-api]_  Multiple interpreters operate in "
"`relative isolation from one another <Interpreter Isolation_>`_, which "
"facilitates novel alternative approaches to `concurrency "
"<Concurrency_>`_."
msgstr ""

#: ../../peps/pep-0554.rst:28
msgid ""
"This proposal introduces the stdlib ``interpreters`` module.  It exposes "
"the basic functionality of multiple interpreters already provided by the "
"C-API, along with basic support for communicating between interpreters. "
"This module is especially relevant since :pep:`684` introduced a per-"
"interpreter GIL in Python 3.12."
msgstr ""

#: ../../peps/pep-0554.rst:36
msgid "Proposal"
msgstr ""

#: ../../peps/pep-0554.rst:38
msgid "Summary:"
msgstr ""

#: ../../peps/pep-0554.rst:40
msgid "add a new stdlib module: \"interpreters\""
msgstr ""

#: ../../peps/pep-0554.rst:41
msgid "add concurrent.futures.InterpreterPoolExecutor"
msgstr ""

#: ../../peps/pep-0554.rst:42
msgid "help for extension module maintainers"
msgstr ""

#: ../../peps/pep-0554.rst:46
msgid "The \"interpreters\" Module"
msgstr ""

#: ../../peps/pep-0554.rst:48
msgid ""
"The ``interpreters`` module will provide a high-level interface to the "
"multiple interpreter functionality, and wrap a new low-level "
"``_interpreters`` (in the same way as the ``threading`` module). See the "
"`Examples`_ section for concrete usage and use cases."
msgstr ""

#: ../../peps/pep-0554.rst:53
msgid ""
"Along with exposing the existing (in CPython) multiple interpreter "
"support, the module will also support a basic mechanism for passing data "
"between interpreters.  That involves setting \"shareable\" objects in the"
" ``__main__`` module of a target subinterpreter.  Some such objects, like"
"  ``os.pipe()``, may be used to communicate further. The module will also"
" provide a minimal implementation of \"channels\" as a demonstration of "
"cross-interpreter communication."
msgstr ""

#: ../../peps/pep-0554.rst:61
msgid ""
"Note that *objects* are not shared between interpreters since they are "
"tied to the interpreter in which they were created.  Instead, the "
"objects' *data* is passed between interpreters.  See the `Shared Data`_ "
"and `API For Communication`_ sections for more details about "
"sharing/communicating between interpreters."
msgstr ""

#: ../../peps/pep-0554.rst:68
msgid "API summary for interpreters module"
msgstr ""

#: ../../peps/pep-0554.rst:70
msgid ""
"Here is a summary of the API for the ``interpreters`` module.  For a more"
" in-depth explanation of the proposed classes and functions, see the "
"`\"interpreters\" Module API`_ section below."
msgstr ""

#: ../../peps/pep-0554.rst:74
msgid "For creating and using interpreters:"
msgstr ""

#: ../../peps/pep-0554.rst:77 ../../peps/pep-0554.rst:91
#: ../../peps/pep-0554.rst:115
msgid "signature"
msgstr ""

#: ../../peps/pep-0554.rst:77 ../../peps/pep-0554.rst:91
#: ../../peps/pep-0554.rst:115
msgid "description"
msgstr ""

#: ../../peps/pep-0554.rst:79
msgid "``list_all() -> [Interpreter]``"
msgstr ""

#: ../../peps/pep-0554.rst:79
msgid "Get all existing interpreters."
msgstr ""

#: ../../peps/pep-0554.rst:81
msgid "``get_current() -> Interpreter``"
msgstr ""

#: ../../peps/pep-0554.rst:81
msgid "Get the currently running interpreter."
msgstr ""

#: ../../peps/pep-0554.rst:83
msgid "``get_main() -> Interpreter``"
msgstr ""

#: ../../peps/pep-0554.rst:83
msgid "Get the main interpreter."
msgstr ""

#: ../../peps/pep-0554.rst:85
msgid "``create() -> Interpreter``"
msgstr ""

#: ../../peps/pep-0554.rst:85
msgid "Initialize a new (idle) Python interpreter."
msgstr ""

#: ../../peps/pep-0554.rst:93
msgid "``class Interpreter``"
msgstr ""

#: ../../peps/pep-0554.rst:93
msgid "A single interpreter."
msgstr ""

#: ../../peps/pep-0554.rst:95
msgid "``.id``"
msgstr ""

#: ../../peps/pep-0554.rst:95
msgid "The interpreter's ID (read-only)."
msgstr ""

#: ../../peps/pep-0554.rst:97
msgid "``.is_running() -> bool``"
msgstr ""

#: ../../peps/pep-0554.rst:97
msgid "Is the interpreter currently executing code?"
msgstr ""

#: ../../peps/pep-0554.rst:99
msgid "``.close()``"
msgstr ""

#: ../../peps/pep-0554.rst:99
msgid "Finalize and destroy the interpreter."
msgstr ""

#: ../../peps/pep-0554.rst:101
msgid "``.set_main_attrs(**kwargs)``"
msgstr ""

#: ../../peps/pep-0554.rst:101
msgid "Bind \"shareable\" objects in ``__main__``."
msgstr ""

#: ../../peps/pep-0554.rst:103
msgid "``.get_main_attr(name)``"
msgstr ""

#: ../../peps/pep-0554.rst:103
msgid "Get a \"shareable\" object from ``__main__``."
msgstr ""

#: ../../peps/pep-0554.rst:105
msgid "``.exec(src_str, /)``"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Run the given source code in the interpreter"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "(in the current thread)."
msgstr ""

#: ../../peps/pep-0554.rst:112
msgid "For communicating between interpreters:"
msgstr ""

#: ../../peps/pep-0554.rst:117
msgid "``is_shareable(obj) -> Bool``"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Can the object's data be passed"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "between interpreters?"
msgstr ""

#: ../../peps/pep-0554.rst:120
msgid "``create_channel() -> (RecvChannel, SendChannel)``"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "Create a new channel for passing"
msgstr ""

#: ../../peps/pep-0554.rst
msgid "data between interpreters."
msgstr ""

#: ../../peps/pep-0554.rst:125
msgid "concurrent.futures.InterpreterPoolExecutor"
msgstr ""

#: ../../peps/pep-0554.rst:127
msgid ""
"An executor will be added that extends ``ThreadPoolExecutor`` to run per-"
"thread tasks in subinterpreters.  Initially, the only supported tasks "
"will be whatever ``Interpreter.exec()`` takes (e.g. a ``str`` script).  "
"However, we may also support some functions, as well as eventually a "
"separate method for pickling the task and arguments, to reduce friction "
"(at the expense of performance for short-running tasks)."
msgstr ""

#: ../../peps/pep-0554.rst:136
msgid "Help for Extension Module Maintainers"
msgstr ""

#: ../../peps/pep-0554.rst:138
msgid ""
"In practice, an extension that implements multi-phase init (:pep:`489`) "
"is considered isolated and thus compatible with multiple interpreters. "
"Otherwise it is \"incompatible\"."
msgstr ""

#: ../../peps/pep-0554.rst:142
msgid ""
"Many extension modules are still incompatible.  The maintainers and users"
" of such extension modules will both benefit when they are updated to "
"support multiple interpreters.  In the meantime, users may become "
"confused by failures when using multiple interpreters, which could "
"negatively impact extension maintainers.  See `Concerns`_ below."
msgstr ""

#: ../../peps/pep-0554.rst:148
msgid ""
"To mitigate that impact and accelerate compatibility, we will do the "
"following:"
msgstr ""

#: ../../peps/pep-0554.rst:151
msgid ""
"be clear that extension modules are *not* required to support use in "
"multiple interpreters"
msgstr ""

#: ../../peps/pep-0554.rst:153
msgid ""
"raise ``ImportError`` when an incompatible module is imported in a "
"subinterpreter"
msgstr ""

#: ../../peps/pep-0554.rst:155
msgid "provide resources (e.g. docs) to help maintainers reach compatibility"
msgstr ""

#: ../../peps/pep-0554.rst:156
msgid ""
"reach out to the maintainers of Cython and of the most used extension "
"modules (on PyPI) to get feedback and possibly provide assistance"
msgstr ""

#: ../../peps/pep-0554.rst:161
msgid "Examples"
msgstr ""

#: ../../peps/pep-0554.rst:164
msgid "Run isolated code in current OS thread"
msgstr ""

#: ../../peps/pep-0554.rst:174
msgid "Run in a different thread"
msgstr ""

#: ../../peps/pep-0554.rst:188
msgid "Pre-populate an interpreter"
msgstr ""

#: ../../peps/pep-0554.rst:204
msgid "Handling an exception"
msgstr ""

#: ../../peps/pep-0554.rst:217
msgid "Re-raising an exception"
msgstr ""

#: ../../peps/pep-0554.rst:232
msgid "Note that this pattern is a candidate for later improvement."
msgstr ""

#: ../../peps/pep-0554.rst:235
msgid "Interact with the __main__ namespace"
msgstr ""

#: ../../peps/pep-0554.rst:247
msgid "Synchronize using an OS pipe"
msgstr ""

#: ../../peps/pep-0554.rst:273
msgid "Sharing a file descriptor"
msgstr ""

#: ../../peps/pep-0554.rst:287
msgid "Passing objects via pickle"
msgstr ""

#: ../../peps/pep-0554.rst:316
msgid "Capturing an interpreter's stdout"
msgstr ""

#: ../../peps/pep-0554.rst:339
msgid "A pipe (``os.pipe()``) could be used similarly."
msgstr ""

#: ../../peps/pep-0554.rst:342
msgid "Running a module"
msgstr ""

#: ../../peps/pep-0554.rst:351
msgid "Running as script (including zip archives & directories)"
msgstr ""

#: ../../peps/pep-0554.rst:360
msgid "Using a channel to communicate"
msgstr ""

#: ../../peps/pep-0554.rst:402
msgid "Sharing a memoryview (imagine map-reduce)"
msgstr ""

#: ../../peps/pep-0554.rst:446
msgid "Rationale"
msgstr ""

#: ../../peps/pep-0554.rst:448
msgid ""
"Running code in multiple interpreters provides a useful level of "
"isolation within the same process.  This can be leveraged in a number of "
"ways.  Furthermore, subinterpreters provide a well-defined framework in "
"which such isolation may extended.  (See :pep:`684`.)"
msgstr ""

#: ../../peps/pep-0554.rst:453
msgid ""
"Alyssa (Nick) Coghlan explained some of the benefits through a comparison"
" with multi-processing [benefits]_::"
msgstr ""

#: ../../peps/pep-0554.rst:474
msgid ""
"CPython has supported multiple interpreters, with increasing levels of "
"support, since version 1.5.  While the feature has the potential to be a "
"powerful tool, it has suffered from neglect because the multiple "
"interpreter capabilities are not readily available directly from Python."
"  Exposing the existing functionality in the stdlib will help reverse the"
" situation."
msgstr ""

#: ../../peps/pep-0554.rst:481
msgid ""
"This proposal is focused on enabling the fundamental capability of "
"multiple interpreters, isolated from each other, in the same Python "
"process.  This is a new area for Python so there is relative uncertainly "
"about the best tools to provide as companions to interpreters.  Thus we "
"minimize the functionality we add in the proposal as much as possible."
msgstr ""

#: ../../peps/pep-0554.rst:489
msgid "Concerns"
msgstr ""

#: ../../peps/pep-0554.rst:491
msgid "\"subinterpreters are not worth the trouble\""
msgstr ""

#: ../../peps/pep-0554.rst:493
msgid ""
"Some have argued that subinterpreters do not add sufficient benefit to "
"justify making them an official part of Python.  Adding features to the "
"language (or stdlib) has a cost in increasing the size of the language.  "
"So an addition must pay for itself."
msgstr ""

#: ../../peps/pep-0554.rst:498
msgid ""
"In this case, multiple interpreter support provide a novel concurrency "
"model focused on isolated threads of execution.  Furthermore, they "
"provide an opportunity for changes in CPython that will allow "
"simultaneous use of multiple CPU cores (currently prevented by the GIL--"
"see :pep:`684`)."
msgstr ""

#: ../../peps/pep-0554.rst:504
msgid ""
"Alternatives to subinterpreters include threading, async, and "
"multiprocessing.  Threading is limited by the GIL and async isn't the "
"right solution for every problem (nor for every person). Multiprocessing "
"is likewise valuable in some but not all situations. Direct IPC (rather "
"than via the multiprocessing module) provides similar benefits but with "
"the same caveat."
msgstr ""

#: ../../peps/pep-0554.rst:511
msgid ""
"Notably, subinterpreters are not intended as a replacement for any of the"
" above.  Certainly they overlap in some areas, but the benefits of "
"subinterpreters include isolation and (potentially) performance.  In "
"particular, subinterpreters provide a direct route to an alternate "
"concurrency model (e.g. CSP) which has found success elsewhere and will "
"appeal to some Python users.  That is the core value that the "
"``interpreters`` module will provide."
msgstr ""

#: ../../peps/pep-0554.rst:519
msgid ""
"\"stdlib support for multiple interpreters adds extra burden on C "
"extension authors\""
msgstr ""

#: ../../peps/pep-0554.rst:522
msgid ""
"In the `Interpreter Isolation`_ section below we identify ways in which "
"isolation in CPython's subinterpreters is incomplete.  Most notable is "
"extension modules that use C globals to store internal state.  "
"(:pep:`3121` and :pep:`489` provide a solution to that problem, followed "
"by some extra APIs that improve efficiency, e.g. :pep:`573`)."
msgstr ""

#: ../../peps/pep-0554.rst:528
msgid ""
"Consequently, projects that publish extension modules may face an "
"increased maintenance burden as their users start using subinterpreters, "
"where their modules may break.  This situation is limited to modules that"
" use C globals (or use libraries that use C globals) to store internal "
"state.  For numpy, the reported-bug rate is one every 6 months. [bug-"
"rate]_"
msgstr ""

#: ../../peps/pep-0554.rst:535
msgid ""
"Ultimately this comes down to a question of how often it will be a "
"problem in practice: how many projects would be affected, how often their"
" users will be affected, what the additional maintenance burden will be "
"for projects, and what the overall benefit of subinterpreters is to "
"offset those costs.  The position of this PEP is that the actual extra "
"maintenance burden will be small and well below the threshold at which "
"subinterpreters are worth it."
msgstr ""

#: ../../peps/pep-0554.rst:543
msgid ""
"\"creating a new concurrency API deserves much more thought and "
"experimentation, so the new module shouldn't go into the stdlib right "
"away, if ever\""
msgstr ""

#: ../../peps/pep-0554.rst:547
msgid ""
"Introducing an API for a new concurrency model, like happened with "
"asyncio, is an extremely large project that requires a lot of careful "
"consideration.  It is not something that can be done as simply as this "
"PEP proposes and likely deserves significant time on PyPI to mature. (See"
" `Nathaniel's post <nathaniel-asyncio_>`_ on python-dev.)"
msgstr ""

#: ../../peps/pep-0554.rst:553
msgid ""
"However, this PEP does not propose any new concurrency API. At most it "
"exposes minimal tools (e.g. subinterpreters, channels) which may be used "
"to write code that follows patterns associated with (relatively) new-to-"
"Python `concurrency models <Concurrency_>`_. Those tools could also be "
"used as the basis for APIs for such concurrency models.  Again, this PEP "
"does not propose any such API."
msgstr ""

#: ../../peps/pep-0554.rst:560
msgid ""
"\"there is no point to exposing subinterpreters if they still share the "
"GIL\""
msgstr ""

#: ../../peps/pep-0554.rst:562
msgid "\"the effort to make the GIL per-interpreter is disruptive and risky\""
msgstr ""

#: ../../peps/pep-0554.rst:564
msgid ""
"A common misconception is that this PEP also includes a promise that "
"interpreters will no longer share the GIL.  When that is clarified, the "
"next question is \"what is the point?\".  This is already answered at "
"length in this PEP.  Just to be clear, the value lies in::"
msgstr ""

#: ../../peps/pep-0554.rst:575
msgid ""
"\"data sharing can have a negative impact on cache performance in multi-"
"core scenarios\""
msgstr ""

#: ../../peps/pep-0554.rst:578
msgid "(See [cache-line-ping-pong]_.)"
msgstr ""

#: ../../peps/pep-0554.rst:580
msgid ""
"This shouldn't be a problem for now as we have no immediate plans to "
"actually share data between interpreters, instead focusing on copying."
msgstr ""

#: ../../peps/pep-0554.rst:586
msgid "About Subinterpreters"
msgstr ""

#: ../../peps/pep-0554.rst:589
msgid "Concurrency"
msgstr ""

#: ../../peps/pep-0554.rst:591
msgid ""
"Concurrency is a challenging area of software development.  Decades of "
"research and practice have led to a wide variety of concurrency models, "
"each with different goals.  Most center on correctness and usability."
msgstr ""

#: ../../peps/pep-0554.rst:595
msgid ""
"One class of concurrency models focuses on isolated threads of execution "
"that interoperate through some message passing scheme.  A notable example"
" is Communicating Sequential Processes [CSP]_ (upon which Go's "
"concurrency is roughly based).  The intended isolation inherent to "
"CPython's interpreters makes them well-suited to this approach."
msgstr ""

#: ../../peps/pep-0554.rst:603
msgid "Shared Data"
msgstr ""

#: ../../peps/pep-0554.rst:605
msgid ""
"CPython's interpreters are inherently isolated (with caveats explained "
"below), in contrast to threads.  So the same communicate-via-shared-"
"memory approach doesn't work.  Without an alternative, effective use of "
"concurrency via multiple interpreters is significantly limited."
msgstr ""

#: ../../peps/pep-0554.rst:611
msgid ""
"The key challenge here is that sharing objects between interpreters faces"
" complexity due to various constraints on object ownership, visibility, "
"and mutability.  At a conceptual level it's easier to reason about "
"concurrency when objects only exist in one interpreter at a time.  At a "
"technical level, CPython's current memory model limits how Python "
"*objects* may be shared safely between interpreters; effectively, objects"
" are bound to the interpreter in which they were created.  Furthermore, "
"the complexity of *object* sharing increases as interpreters become more "
"isolated, e.g. after GIL removal (though this is mitigated somewhat for "
"some \"immortal\" objects (see :pep:`683`)."
msgstr ""

#: ../../peps/pep-0554.rst:622
msgid ""
"Consequently, the mechanism for sharing needs to be carefully considered."
" There are a number of valid solutions, several of which may be "
"appropriate to support in Python's stdlib and C-API.  Any such solution "
"is likely to share many characteristics with the others."
msgstr ""

#: ../../peps/pep-0554.rst:627
msgid ""
"In the meantime, we propose here a minimal solution "
"(``Interpreter.set_main_attrs()``), which sets some precedent for how "
"objects are shared.  More importantly, it facilitates the introduction of"
" more advanced approaches later and allows them to coexist and cooperate."
" In part to demonstrate that, we will provide a basic implementation of "
"\"channels\", as a somewhat more advanced sharing solution."
msgstr ""

#: ../../peps/pep-0554.rst:634
msgid "Separate proposals may cover:"
msgstr ""

#: ../../peps/pep-0554.rst:636
msgid ""
"the addition of a public C-API based on the implementation "
"``Interpreter.set_main_attrs()``"
msgstr ""

#: ../../peps/pep-0554.rst:638
msgid "the addition of other sharing approaches to the \"interpreters\" module"
msgstr ""

#: ../../peps/pep-0554.rst:640
msgid ""
"The fundamental enabling feature for communication is that most objects "
"can be converted to some encoding of underlying raw data, which is safe "
"to be passed between interpreters.  For example, an ``int`` object can be"
" turned into a C ``long`` value, sent to another interpreter, and turned "
"back into an ``int`` object there.  As another example, ``None`` may be "
"passed as-is."
msgstr ""

#: ../../peps/pep-0554.rst:647
msgid ""
"Regardless, the effort to determine the best way forward here is mostly "
"outside the scope of this PEP.  In the meantime, this proposal describes "
"a basic interim solution using pipes (``os.pipe()``), as well as "
"providing a dedicated capability (\"channels\"). See `API For "
"Communication`_ below."
msgstr ""

#: ../../peps/pep-0554.rst:654
msgid "Interpreter Isolation"
msgstr ""

#: ../../peps/pep-0554.rst:656
msgid ""
"CPython's interpreters are intended to be strictly isolated from each "
"other.  Each interpreter has its own copy of all modules, classes, "
"functions, and variables.  The same applies to state in C, including in "
"extension modules.  The CPython C-API docs explain more. [caveats]_"
msgstr ""

#: ../../peps/pep-0554.rst:661
msgid ""
"However, there are ways in which interpreters do share some state. First "
"of all, some process-global state remains shared:"
msgstr ""

#: ../../peps/pep-0554.rst:664
msgid "file descriptors"
msgstr ""

#: ../../peps/pep-0554.rst:665
msgid "low-level env vars"
msgstr ""

#: ../../peps/pep-0554.rst:666
msgid "process memory (though allocators *are* isolated)"
msgstr ""

#: ../../peps/pep-0554.rst:667
msgid "builtin types (e.g. dict, bytes)"
msgstr ""

#: ../../peps/pep-0554.rst:668
msgid "singletons (e.g. None)"
msgstr ""

#: ../../peps/pep-0554.rst:669
msgid ""
"underlying static module data (e.g. functions) for "
"builtin/extension/frozen modules"
msgstr ""

#: ../../peps/pep-0554.rst:672
msgid "There are no plans to change this."
msgstr ""

#: ../../peps/pep-0554.rst:674
msgid ""
"Second, some isolation is faulty due to bugs or implementations that did "
"not take subinterpreters into account.  This includes things like "
"extension modules that rely on C globals. [cryptography]_  In these cases"
" bugs should be opened (some are already):"
msgstr ""

#: ../../peps/pep-0554.rst:679
msgid "readline module hook functions (http://bugs.python.org/issue4202)"
msgstr ""

#: ../../peps/pep-0554.rst:680
msgid "memory leaks on re-init (http://bugs.python.org/issue21387)"
msgstr ""

#: ../../peps/pep-0554.rst:682
msgid ""
"Finally, some potential isolation is missing due to the current design of"
" CPython.  Improvements are currently going on to address gaps in this "
"area:"
msgstr ""

#: ../../peps/pep-0554.rst:686
msgid ""
"extensions using the ``PyGILState_*`` API are somewhat incompatible "
"[gilstate]_"
msgstr ""

#: ../../peps/pep-0554.rst:689
msgid "Existing Usage"
msgstr ""

#: ../../peps/pep-0554.rst:691
msgid ""
"Multiple interpreter support has not been a widely used feature. In fact,"
" there have been only a handful of documented cases of widespread usage, "
"including `mod_wsgi <https://github.com/GrahamDumpleton/mod_wsgi>`_, "
"`OpenStack Ceph <https://github.com/ceph/ceph/pull/14971>`_, and `JEP "
"<https://github.com/ninia/jep>`_.  On the one hand, these cases provide "
"confidence that existing multiple interpreter support is relatively "
"stable.  On the other hand, there isn't much of a sample size from which "
"to judge the utility of the feature."
msgstr ""

#: ../../peps/pep-0554.rst:703
msgid "Alternate Python Implementations"
msgstr ""

#: ../../peps/pep-0554.rst:705
msgid ""
"I've solicited feedback from various Python implementors about support "
"for subinterpreters.  Each has indicated that they would be able to "
"support multiple interpreters in the same process (if they choose to) "
"without a lot of trouble.  Here are the projects I contacted:"
msgstr ""

#: ../../peps/pep-0554.rst:710
msgid "jython  ([jython]_)"
msgstr ""

#: ../../peps/pep-0554.rst:711
msgid "ironpython  (personal correspondence)"
msgstr ""

#: ../../peps/pep-0554.rst:712
msgid "pypy  (personal correspondence)"
msgstr ""

#: ../../peps/pep-0554.rst:713
msgid "micropython  (personal correspondence)"
msgstr ""

#: ../../peps/pep-0554.rst:723
msgid "\"interpreters\" Module API"
msgstr ""

#: ../../peps/pep-0554.rst:725
msgid "The module provides the following functions::"
msgstr ""

#: ../../peps/pep-0554.rst:755
msgid "The module also provides the following class::"
msgstr ""

#: ../../peps/pep-0554.rst:859
msgid ""
"In addition to the functionality of ``Interpreter.set_main_attrs()``, the"
" module provides a related way to pass data between interpreters: "
"channels.  See `Channels`_ below."
msgstr ""

#: ../../peps/pep-0554.rst:864
msgid "Uncaught Exceptions"
msgstr ""

#: ../../peps/pep-0554.rst:866
msgid ""
"Regarding uncaught exceptions in ``Interpreter.exec()``, we noted that "
"they are \"effectively\" propagated into the code where ``interp.exec()``"
" was called.  To prevent leaking exceptions (and tracebacks) between "
"interpreters, we create a surrogate of the exception and its traceback "
"(see :class:`traceback.TracebackException`), set it to ``__cause__`` on a"
" new ``interpreters.RunFailedError``, and raise that."
msgstr ""

#: ../../peps/pep-0554.rst:873
msgid ""
"Directly raising (a proxy of) the exception is problematic since it's "
"harder to distinguish between an error in the ``interp.exec()`` call and "
"an uncaught exception from the subinterpreter."
msgstr ""

#: ../../peps/pep-0554.rst:879
msgid "Interpreter Restrictions"
msgstr ""

#: ../../peps/pep-0554.rst:881
msgid ""
"Every new interpreter created by ``interpreters.create()`` now has "
"specific restrictions on any code it runs.  This includes the following:"
msgstr ""

#: ../../peps/pep-0554.rst:885
msgid ""
"importing an extension module fails if it does not implement multi-phase "
"init"
msgstr ""

#: ../../peps/pep-0554.rst:887
msgid "daemon threads may not be created"
msgstr ""

#: ../../peps/pep-0554.rst:888
msgid "``os.fork()`` is not allowed (so no ``multiprocessing``)"
msgstr ""

#: ../../peps/pep-0554.rst:889
msgid ""
"``os.exec*()`` is not allowed (but \"fork+exec\", a la ``subprocess`` is "
"okay)"
msgstr ""

#: ../../peps/pep-0554.rst:892
msgid ""
"Note that interpreters created with the existing C-API do not have these "
"restrictions.  The same is true for the \"main\" interpreter, so existing"
" use of Python will not change."
msgstr ""

#: ../../peps/pep-0554.rst:898
msgid ""
"We may choose to later loosen some of the above restrictions or provide a"
" way to enable/disable granular restrictions individually.  Regardless, "
"requiring multi-phase init from extension modules will always be a "
"default restriction."
msgstr ""

#: ../../peps/pep-0554.rst:905
msgid "API For Communication"
msgstr ""

#: ../../peps/pep-0554.rst:907
msgid ""
"As discussed in `Shared Data`_ above, multiple interpreter support is "
"less useful without a mechanism for sharing data (communicating) between "
"them.  Sharing actual Python objects between interpreters, however, has "
"enough potential problems that we are avoiding support for that in this "
"proposal.  Nor, as mentioned earlier, are we adding anything more than a "
"basic mechanism for communication."
msgstr ""

#: ../../peps/pep-0554.rst:914
msgid ""
"That mechanism is the ``Interpreter.set_main_attrs()`` method. It may be "
"used to set up global variables before ``Interpreter.exec()`` is called."
"  The name-value pairs passed to ``set_main_attrs()`` are bound as "
"attributes of the interpreter's ``__main__`` module. The values must be "
"\"shareable\".  See `Shareable Types`_ below."
msgstr ""

#: ../../peps/pep-0554.rst:920
msgid ""
"Additional approaches to communicating and sharing objects are enabled "
"through ``Interpreter.set_main_attrs()``.  A shareable object could be "
"implemented which works like a queue, but with cross-interpreter safety. "
"In fact, this PEP does include an example of such an approach: channels."
msgstr ""

#: ../../peps/pep-0554.rst:926
msgid "Shareable Types"
msgstr ""

#: ../../peps/pep-0554.rst:928
msgid ""
"An object is \"shareable\" if its type supports shareable instances. The "
"type must implement a new internal protocol, which is used to convert an "
"object to interpreter-independent data and then coverted back to an "
"object on the other side.  Also see `is_shareable() <interpreters-is-"
"shareable_>`_ above."
msgstr ""

#: ../../peps/pep-0554.rst:934
msgid ""
"A minimal set of simple, immutable builtin types will be supported "
"initially, including:"
msgstr ""

#: ../../peps/pep-0554.rst:937
msgid "``None``"
msgstr ""

#: ../../peps/pep-0554.rst:938
msgid "``bool``"
msgstr ""

#: ../../peps/pep-0554.rst:939
msgid "``bytes``"
msgstr ""

#: ../../peps/pep-0554.rst:940
msgid "``str``"
msgstr ""

#: ../../peps/pep-0554.rst:941
msgid "``int``"
msgstr ""

#: ../../peps/pep-0554.rst:942
msgid "``float``"
msgstr ""

#: ../../peps/pep-0554.rst:944
msgid "We will also support a small number of complex types initially:"
msgstr ""

#: ../../peps/pep-0554.rst:946
msgid "``memoryview``, to allow sharing :pep:`3118` buffers"
msgstr ""

#: ../../peps/pep-0554.rst:947
msgid "`channels <Channels_>`_"
msgstr ""

#: ../../peps/pep-0554.rst:949
msgid ""
"Further builtin types may be supported later, complex or not. Limiting "
"the initial shareable types is a practical matter, reducing the potential"
" complexity of the initial implementation.  There are a number of "
"strategies we may pursue in the future to expand supported objects, once "
"we have more experience with interpreter isolation."
msgstr ""

#: ../../peps/pep-0554.rst:955
msgid ""
"In the meantime, a separate proposal will discuss making the internal "
"protocol (and C-API) used by ``Interpreter.set_main_attrs()`` public. "
"With that protocol, support for other types could be added by extension "
"modules."
msgstr ""

#: ../../peps/pep-0554.rst:961
msgid "Communicating Through OS Pipes"
msgstr ""

#: ../../peps/pep-0554.rst:963
msgid ""
"Even without a dedicated object for communication, users may already use "
"existing tools.  For example, one basic approach for sending data between"
" interpreters is to use a pipe (see ``os.pipe()``):"
msgstr ""

#: ../../peps/pep-0554.rst:967
msgid ""
"interpreter A calls ``os.pipe()`` to get a read/write pair of file "
"descriptors (both ``int`` objects)"
msgstr ""

#: ../../peps/pep-0554.rst:969
msgid ""
"interpreter A calls ``interp.set_main_attrs()``, binding the read FD (or "
"embeds it using string formatting)"
msgstr ""

#: ../../peps/pep-0554.rst:971
msgid "interpreter A calls ``interp.exec()`` on interpreter B"
msgstr ""

#: ../../peps/pep-0554.rst:972
msgid "interpreter A writes some bytes to the write FD"
msgstr ""

#: ../../peps/pep-0554.rst:973
msgid "interpreter B reads those bytes"
msgstr ""

#: ../../peps/pep-0554.rst:975
msgid ""
"Several of the earlier examples demonstrate this, such as `Synchronize "
"using an OS pipe`_."
msgstr ""

#: ../../peps/pep-0554.rst:983
msgid "Channels"
msgstr ""

#: ../../peps/pep-0554.rst:985
msgid ""
"The ``interpreters`` module will include a dedicated solution for passing"
" object data between interpreters: channels.  They are included in the "
"module in part to provide an easier mechanism than using ``os.pipe()`` "
"and in part to demonstrate how libraries may take advantage of "
"``Interpreter.set_main_attrs()`` and the protocol it uses."
msgstr ""

#: ../../peps/pep-0554.rst:992
msgid ""
"A channel is a simplex FIFO.  It is a basic, opt-in data sharing "
"mechanism that draws inspiration from pipes, queues, and CSP's channels. "
"[fifo]_ The main difference from pipes is that channels can be associated"
" with zero or more interpreters on either end.  Like queues, which are "
"also many-to-many, channels are buffered (though they also offer methods "
"with unbuffered semantics)."
msgstr ""

#: ../../peps/pep-0554.rst:999
msgid ""
"Channels have two operations: send and receive.  A key characteristic of "
"those operations is that channels transmit data derived from Python "
"objects rather than the objects themselves.  When objects are sent, their"
" data is extracted.  When the \"object\" is received in the other "
"interpreter, the data is converted back into an object owned by that "
"interpreter."
msgstr ""

#: ../../peps/pep-0554.rst:1006
msgid ""
"To make this work, the mutable shared state will be managed by the Python"
" runtime, not by any of the interpreters.  Initially we will support only"
" one type of objects for shared state: the channels provided by "
"``interpreters.create_channel()``.  Channels, in turn, will carefully "
"manage passing objects between interpreters."
msgstr ""

#: ../../peps/pep-0554.rst:1012
msgid ""
"This approach, including keeping the API minimal, helps us avoid further "
"exposing any underlying complexity to Python users."
msgstr ""

#: ../../peps/pep-0554.rst:1015
msgid ""
"The ``interpreters`` module provides the following function related to "
"channels::"
msgstr ""

#: ../../peps/pep-0554.rst:1027
msgid "The module also provides the following channel-related classes::"
msgstr ""

#: ../../peps/pep-0554.rst:1090
msgid "Caveats For Shared Objects"
msgstr ""

#: ../../peps/pep-0554.rst:1092
msgid ""
"Again, Python objects are not shared between interpreters. However, in "
"some cases data those objects wrap is actually shared and not just "
"copied.  One example might be :pep:`3118` buffers."
msgstr ""

#: ../../peps/pep-0554.rst:1096
msgid ""
"In those cases the object in the original interpreter is kept alive until"
" the shared data in the other interpreter is no longer used. Then object "
"destruction can happen like normal in the original interpreter, along "
"with the previously shared data."
msgstr ""

#: ../../peps/pep-0554.rst:1103
msgid "Documentation"
msgstr ""

#: ../../peps/pep-0554.rst:1105
msgid ""
"The new stdlib docs page for the ``interpreters`` module will include the"
" following:"
msgstr ""

#: ../../peps/pep-0554.rst:1108
msgid ""
"(at the top) a clear note that support for multiple interpreters is not "
"required from extension modules"
msgstr ""

#: ../../peps/pep-0554.rst:1110
msgid "some explanation about what subinterpreters are"
msgstr ""

#: ../../peps/pep-0554.rst:1111
msgid ""
"brief examples of how to use multiple interpreters (and communicating "
"between them)"
msgstr ""

#: ../../peps/pep-0554.rst:1113
msgid "a summary of the limitations of using multiple interpreters"
msgstr ""

#: ../../peps/pep-0554.rst:1114
msgid ""
"(for extension maintainers) a link to the resources for ensuring multiple"
" interpreters compatibility"
msgstr ""

#: ../../peps/pep-0554.rst:1116
msgid "much of the API information in this PEP"
msgstr ""

#: ../../peps/pep-0554.rst:1118
msgid ""
"Docs about resources for extension maintainers already exist on the "
"`Isolating Extension Modules <isolation-howto_>`_ howto page.  Any extra "
"help will be added there.  For example, it may prove helpful to discuss "
"strategies for dealing with linked libraries that keep their own "
"subinterpreter-incompatible global state."
msgstr ""

#: ../../peps/pep-0554.rst:1127
msgid ""
"Note that the documentation will play a large part in mitigating any "
"negative impact that the new ``interpreters`` module might have on "
"extension module maintainers."
msgstr ""

#: ../../peps/pep-0554.rst:1131
msgid ""
"Also, the ``ImportError`` for incompatible extension modules will be "
"updated to clearly say it is due to missing multiple interpreters "
"compatibility and that extensions are not required to provide it.  This "
"will help set user expectations properly."
msgstr ""

#: ../../peps/pep-0554.rst:1137
msgid "Alternative Solutions"
msgstr ""

#: ../../peps/pep-0554.rst:1139
msgid ""
"One possible alternative to a new module is to add support for "
"interpreters to ``concurrent.futures``.  There are several reasons why "
"that wouldn't work:"
msgstr ""

#: ../../peps/pep-0554.rst:1142
msgid ""
"the obvious place to look for multiple interpreters support is an "
"\"interpreters\" module, much as with \"threading\", etc."
msgstr ""

#: ../../peps/pep-0554.rst:1144
msgid ""
"``concurrent.futures`` is all about executing functions but currently we "
"don't have a good way to run a function from one interpreter in another"
msgstr ""

#: ../../peps/pep-0554.rst:1148
msgid "Similar reasoning applies for support in the ``multiprocessing`` module."
msgstr ""

#: ../../peps/pep-0554.rst:1152
msgid "Open Questions"
msgstr ""

#: ../../peps/pep-0554.rst:1154
msgid ""
"will is be too confusing that ``interp.exec()`` runs in the current "
"thread?"
msgstr ""

#: ../../peps/pep-0554.rst:1155
msgid ""
"should we add pickling fallbacks right now for ``interp.exec()``, and/or "
"``Interpreter.set_main_attrs()`` and ``Interpreter.get_main_attr()``?"
msgstr ""

#: ../../peps/pep-0554.rst:1157
msgid "should we support (limited) functions in ``interp.exec()`` right now?"
msgstr ""

#: ../../peps/pep-0554.rst:1158
msgid "rename ``Interpreter.close()`` to ``Interpreter.destroy()``?"
msgstr ""

#: ../../peps/pep-0554.rst:1159
msgid "drop ``Interpreter.get_main_attr()``, since we have channels?"
msgstr ""

#: ../../peps/pep-0554.rst:1160
msgid "should channels be its own PEP?"
msgstr ""

#: ../../peps/pep-0554.rst:1164
msgid "Deferred Functionality"
msgstr ""

#: ../../peps/pep-0554.rst:1166
msgid ""
"In the interest of keeping this proposal minimal, the following "
"functionality has been left out for future consideration.  Note that this"
" is not a judgement against any of said capability, but rather a "
"deferment.  That said, each is arguably valid."
msgstr ""

#: ../../peps/pep-0554.rst:1172
msgid "Add convenience API"
msgstr ""

#: ../../peps/pep-0554.rst:1174
msgid ""
"There are a number of things I can imagine would smooth out "
"*hypothetical* rough edges with the new module:"
msgstr ""

#: ../../peps/pep-0554.rst:1177
msgid ""
"add something like ``Interpreter.run()`` or ``Interpreter.call()`` that "
"calls ``interp.exec()`` and falls back to pickle"
msgstr ""

#: ../../peps/pep-0554.rst:1179
msgid ""
"fall back to pickle in ``Interpreter.set_main_attrs()`` and "
"``Interpreter.get_main_attr()``"
msgstr ""

#: ../../peps/pep-0554.rst:1182
msgid "These would be easy to do if this proves to be a pain point."
msgstr ""

#: ../../peps/pep-0554.rst:1185
msgid "Avoid possible confusion about interpreters running in the current thread"
msgstr ""

#: ../../peps/pep-0554.rst:1187
msgid ""
"One regular point of confusion has been that ``Interpreter.exec()`` "
"executes in the current OS thread, temporarily blocking the current "
"Python thread.  It may be worth doing something to avoid that confusion."
msgstr ""

#: ../../peps/pep-0554.rst:1191
msgid "Some possible solutions for this hypothetical problem:"
msgstr ""

#: ../../peps/pep-0554.rst:1193
msgid "by default, run in a new thread?"
msgstr ""

#: ../../peps/pep-0554.rst:1194
msgid "add ``Interpreter.exec_in_thread()``?"
msgstr ""

#: ../../peps/pep-0554.rst:1195
msgid "add ``Interpreter.exec_in_current_thread()``?"
msgstr ""

#: ../../peps/pep-0554.rst:1197
msgid ""
"In earlier versions of this PEP the method was ``interp.run()``. The "
"simple change to ``interp.exec()`` alone will probably reduce confusion "
"sufficiently, when coupled with educating users via the docs.  It it "
"turns out to be a real problem, we can pursue one of the alternatives at "
"that point."
msgstr ""

#: ../../peps/pep-0554.rst:1204
msgid "Clarify \"running\" vs. \"has threads\""
msgstr ""

#: ../../peps/pep-0554.rst:1206
msgid ""
"``Interpreter.is_running()`` refers specifically to whether or not "
"``Interpreter.exec()`` (or similar) is running somewhere.  It does not "
"say anything about if the interpreter has any subthreads running.  That "
"information might be helpful."
msgstr ""

#: ../../peps/pep-0554.rst:1211
msgid "Some things we could do:"
msgstr ""

#: ../../peps/pep-0554.rst:1213
msgid "rename ``Interpreter.is_running()`` to ``Interpreter.is_running_main()``"
msgstr ""

#: ../../peps/pep-0554.rst:1214
msgid ""
"add ``Interpreter.has_threads()``, to complement "
"``Interpreter.is_running()``"
msgstr ""

#: ../../peps/pep-0554.rst:1215
msgid "expand to ``Interpreter.is_running(main=True, threads=False)``"
msgstr ""

#: ../../peps/pep-0554.rst:1217
msgid "None of these are urgent and any could be done later, if desired."
msgstr ""

#: ../../peps/pep-0554.rst:1220
msgid "A Dunder Method For Sharing"
msgstr ""

#: ../../peps/pep-0554.rst:1222
msgid ""
"We could add a special method, like ``__xid__`` to correspond to "
"``tp_xid``. At the very least, it would allow Python types to convert "
"their instances to some other type that implements ``tp_xid``."
msgstr ""

#: ../../peps/pep-0554.rst:1226
msgid ""
"The problem is that exposing this capability to Python code presents a "
"degree of complixity that hasn't been explored yet, nor is there a "
"compelling case to investigate that complexity."
msgstr ""

#: ../../peps/pep-0554.rst:1231
msgid "Interpreter.call()"
msgstr ""

#: ../../peps/pep-0554.rst:1233
msgid ""
"It would be convenient to run existing functions in subinterpreters "
"directly.  ``Interpreter.exec()`` could be adjusted to support this or a "
"``call()`` method could be added::"
msgstr ""

#: ../../peps/pep-0554.rst:1239
msgid ""
"This suffers from the same problem as sharing objects between "
"interpreters via queues.  The minimal solution (running a source string) "
"is sufficient for us to get the feature out where it can be explored."
msgstr ""

#: ../../peps/pep-0554.rst:1244
msgid "Interpreter.run_in_thread()"
msgstr ""

#: ../../peps/pep-0554.rst:1246
msgid ""
"This method would make a ``interp.exec()`` call for you in a thread. "
"Doing this using only ``threading.Thread`` and ``interp.exec()`` is "
"relatively trivial so we've left it out."
msgstr ""

#: ../../peps/pep-0554.rst:1251
msgid "Synchronization Primitives"
msgstr ""

#: ../../peps/pep-0554.rst:1253
msgid ""
"The ``threading`` module provides a number of synchronization primitives "
"for coordinating concurrent operations.  This is especially necessary due"
" to the shared-state nature of threading.  In contrast, interpreters do "
"not share state.  Data sharing is restricted to the runtime's shareable "
"objects capability, which does away with the need for explicit "
"synchronization.  If any sort of opt-in shared state support is added to "
"CPython's interpreters in the future, that same effort can introduce "
"synchronization primitives to meet that need."
msgstr ""

#: ../../peps/pep-0554.rst:1263
msgid "CSP Library"
msgstr ""

#: ../../peps/pep-0554.rst:1265
msgid ""
"A ``csp`` module would not be a large step away from the functionality "
"provided by this PEP.  However, adding such a module is outside the "
"minimalist goals of this proposal."
msgstr ""

#: ../../peps/pep-0554.rst:1270
msgid "Syntactic Support"
msgstr ""

#: ../../peps/pep-0554.rst:1272
msgid ""
"The ``Go`` language provides a concurrency model based on CSP, so it's "
"similar to the concurrency model that multiple interpreters support.  "
"However, ``Go`` also provides syntactic support, as well as several "
"builtin concurrency primitives, to make concurrency a first-class "
"feature.  Conceivably, similar syntactic (and builtin) support could be "
"added to Python using interpreters.  However, that is *way* outside the "
"scope of this PEP!"
msgstr ""

#: ../../peps/pep-0554.rst:1281
msgid "Multiprocessing"
msgstr ""

#: ../../peps/pep-0554.rst:1283
msgid ""
"The ``multiprocessing`` module could support interpreters in the same way"
" it supports threads and processes.  In fact, the module's maintainer, "
"Davin Potts, has indicated this is a reasonable feature request.  "
"However, it is outside the narrow scope of this PEP."
msgstr ""

#: ../../peps/pep-0554.rst:1289
msgid "C-extension opt-in/opt-out"
msgstr ""

#: ../../peps/pep-0554.rst:1291
msgid ""
"By using the ``PyModuleDef_Slot`` introduced by :pep:`489`, we could "
"easily add a mechanism by which C-extension modules could opt out of "
"multiple interpreter support.  Then the import machinery, when operating "
"in a subinterpreter, would need to check the module for support. It would"
" raise an ImportError if unsupported."
msgstr ""

#: ../../peps/pep-0554.rst:1297
msgid ""
"Alternately we could support opting in to multiple interpreters support. "
"However, that would probably exclude many more modules (unnecessarily) "
"than the opt-out approach.  Also, note that :pep:`489` defined that an "
"extension's use of the PEP's machinery implies multiple interpreters "
"support."
msgstr ""

#: ../../peps/pep-0554.rst:1303
msgid ""
"The scope of adding the ModuleDef slot and fixing up the import machinery"
" is non-trivial, but could be worth it.  It all depends on how many "
"extension modules break under subinterpreters.  Given that there are "
"relatively few cases we know of through mod_wsgi, we can leave this for "
"later."
msgstr ""

#: ../../peps/pep-0554.rst:1310
msgid "Poisoning channels"
msgstr ""

#: ../../peps/pep-0554.rst:1312
msgid ""
"CSP has the concept of poisoning a channel.  Once a channel has been "
"poisoned, any ``send()`` or ``recv()`` call on it would raise a special "
"exception, effectively ending execution in the interpreter that tried to "
"use the poisoned channel."
msgstr ""

#: ../../peps/pep-0554.rst:1317
msgid ""
"This could be accomplished by adding a ``poison()`` method to both ends "
"of the channel.  The ``close()`` method can be used in this way (mostly),"
" but these semantics are relatively specialized and can wait."
msgstr ""

#: ../../peps/pep-0554.rst:1322
msgid "Resetting __main__"
msgstr ""

#: ../../peps/pep-0554.rst:1324
msgid ""
"As proposed, every call to ``Interpreter.exec()`` will execute in the "
"namespace of the interpreter's existing ``__main__`` module.  This means "
"that data persists there between ``interp.exec()`` calls.  Sometimes this"
" isn't desirable and you want to execute in a fresh ``__main__``. Also, "
"you don't necessarily want to leak objects there that you aren't using "
"any more."
msgstr ""

#: ../../peps/pep-0554.rst:1331
msgid ""
"Note that the following won't work right because it will clear too much "
"(e.g. ``__name__`` and the other \"__dunder__\" attributes::"
msgstr ""

#: ../../peps/pep-0554.rst:1336
msgid "Possible solutions include:"
msgstr ""

#: ../../peps/pep-0554.rst:1338
msgid ""
"a ``create()`` arg to indicate resetting ``__main__`` after each "
"``interp.exec()`` call"
msgstr ""

#: ../../peps/pep-0554.rst:1340
msgid ""
"an ``Interpreter.reset_main`` flag to support opting in or out after the "
"fact"
msgstr ""

#: ../../peps/pep-0554.rst:1342
msgid "an ``Interpreter.reset_main()`` method to opt in when desired"
msgstr ""

#: ../../peps/pep-0554.rst:1343
msgid "``importlib.util.reset_globals()`` [reset_globals]_"
msgstr ""

#: ../../peps/pep-0554.rst:1345
msgid ""
"Also note that resetting ``__main__`` does nothing about state stored in "
"other modules.  So any solution would have to be clear about the scope of"
" what is being reset.  Conceivably we could invent a mechanism by which "
"any (or every) module could be reset, unlike ``reload()`` which does not "
"clear the module before loading into it."
msgstr ""

#: ../../peps/pep-0554.rst:1351
msgid ""
"Regardless, since ``__main__`` is the execution namespace of the "
"interpreter, resetting it has a much more direct correlation to "
"interpreters and their dynamic state than does resetting other modules. "
"So a more generic module reset mechanism may prove unnecessary."
msgstr ""

#: ../../peps/pep-0554.rst:1356
msgid ""
"This isn't a critical feature initially.  It can wait until later if "
"desirable."
msgstr ""

#: ../../peps/pep-0554.rst:1360
msgid "Resetting an interpreter's state"
msgstr ""

#: ../../peps/pep-0554.rst:1362
msgid ""
"It may be nice to re-use an existing subinterpreter instead of spinning "
"up a new one.  Since an interpreter has substantially more state than "
"just the ``__main__`` module, it isn't so easy to put an interpreter back"
" into a pristine/fresh state.  In fact, there *may* be parts of the state"
" that cannot be reset from Python code."
msgstr ""

#: ../../peps/pep-0554.rst:1368
msgid ""
"A possible solution is to add an ``Interpreter.reset()`` method.  This "
"would put the interpreter back into the state it was in when newly "
"created.  If called on a running interpreter it would fail (hence the "
"main interpreter could never be reset).  This would likely be more "
"efficient than creating a new interpreter, though that depends on what "
"optimizations will be made later to interpreter creation."
msgstr ""

#: ../../peps/pep-0554.rst:1375
msgid ""
"While this would potentially provide functionality that is not otherwise "
"available from Python code, it isn't a fundamental functionality.  So in "
"the spirit of minimalism here, this can wait. Regardless, I doubt it "
"would be controversial to add it post-PEP."
msgstr ""

#: ../../peps/pep-0554.rst:1381
msgid "Copy an existing interpreter's state"
msgstr ""

#: ../../peps/pep-0554.rst:1383
msgid ""
"Relatedly, it may be useful to support creating a new interpreter based "
"on an existing one, e.g. ``Interpreter.copy()``.  This ties into the idea"
" that a snapshot could be made of an interpreter's memory, which would "
"make starting up CPython, or creating new interpreters, faster in "
"general.  The same mechanism could be used for a hypothetical "
"``Interpreter.reset()``, as described previously."
msgstr ""

#: ../../peps/pep-0554.rst:1391
msgid "Shareable file descriptors and sockets"
msgstr ""

#: ../../peps/pep-0554.rst:1393
msgid ""
"Given that file descriptors and sockets are process-global resources, "
"making them shareable is a reasonable idea.  They would be a good "
"candidate for the first effort at expanding the supported shareable "
"types.  They aren't strictly necessary for the initial API."
msgstr ""

#: ../../peps/pep-0554.rst:1399
msgid "Integration with async"
msgstr ""

#: ../../peps/pep-0554.rst:1401
msgid "Per Antoine Pitrou [async]_::"
msgstr ""

#: ../../peps/pep-0554.rst:1411
msgid ""
"The basic functionality of multiple interpreters support does not depend "
"on async and can be added later."
msgstr ""

#: ../../peps/pep-0554.rst:1414
msgid ""
"A possible solution is to provide async implementations of the blocking "
"channel methods (``recv()``, and ``send()``)."
msgstr ""

#: ../../peps/pep-0554.rst:1417
msgid ""
"Alternately, \"readiness callbacks\" could be used to simplify use in "
"async scenarios.  This would mean adding an optional ``callback`` (kw-"
"only) parameter to the ``recv_nowait()`` and ``send_nowait()`` channel "
"methods.  The callback would be called once the object was sent or "
"received (respectively)."
msgstr ""

#: ../../peps/pep-0554.rst:1423
msgid ""
"(Note that making channels buffered makes readiness callbacks less "
"important.)"
msgstr ""

#: ../../peps/pep-0554.rst:1427
msgid "Support for iteration"
msgstr ""

#: ../../peps/pep-0554.rst:1429
msgid ""
"Supporting iteration on ``RecvChannel`` (via ``__iter__()`` or "
"``_next__()``) may be useful.  A trivial implementation would use the "
"``recv()`` method, similar to how files do iteration.  Since this isn't a"
" fundamental capability and has a simple analog, adding iteration support"
" can wait until later."
msgstr ""

#: ../../peps/pep-0554.rst:1436
msgid "Channel context managers"
msgstr ""

#: ../../peps/pep-0554.rst:1438
msgid ""
"Context manager support on ``RecvChannel`` and ``SendChannel`` may be "
"helpful.  The implementation would be simple, wrapping a call to "
"``close()`` (or maybe ``release()``) like files do.  As with iteration, "
"this can wait."
msgstr ""

#: ../../peps/pep-0554.rst:1444
msgid "Pipes and Queues"
msgstr ""

#: ../../peps/pep-0554.rst:1446
msgid ""
"With the proposed object passing mechanism of \"os.pipe()\", other "
"similar basic types aren't strictly required to achieve the minimal "
"useful functionality of multiple interpreters.  Such types include pipes "
"(like unbuffered channels, but one-to-one) and queues (like channels, but"
" more generic).  See below in `Rejected Ideas`_ for more information."
msgstr ""

#: ../../peps/pep-0554.rst:1452
msgid ""
"Even though these types aren't part of this proposal, they may still be "
"useful in the context of concurrency.  Adding them later is entirely "
"reasonable.  The could be trivially implemented as wrappers around "
"channels.  Alternatively they could be implemented for efficiency at the "
"same low level as channels."
msgstr ""

#: ../../peps/pep-0554.rst:1459
msgid "Return a lock from send()"
msgstr ""

#: ../../peps/pep-0554.rst:1461
msgid ""
"When sending an object through a channel, you don't have a way of knowing"
" when the object gets received on the other end.  One way to work around "
"this is to return a locked ``threading.Lock`` from ``SendChannel.send()``"
" that unlocks once the object is received."
msgstr ""

#: ../../peps/pep-0554.rst:1466
msgid ""
"Alternately, the proposed ``SendChannel.send()`` (blocking) and "
"``SendChannel.send_nowait()`` provide an explicit distinction that is "
"less likely to confuse users."
msgstr ""

#: ../../peps/pep-0554.rst:1470
msgid ""
"Note that returning a lock would matter for buffered channels (i.e. "
"queues).  For unbuffered channels it is a non-issue."
msgstr ""

#: ../../peps/pep-0554.rst:1474
msgid "Support prioritization in channels"
msgstr ""

#: ../../peps/pep-0554.rst:1476
msgid "A simple example is ``queue.PriorityQueue`` in the stdlib."
msgstr ""

#: ../../peps/pep-0554.rst:1479
msgid "Support inheriting settings (and more?)"
msgstr ""

#: ../../peps/pep-0554.rst:1481
msgid ""
"Folks might find it useful, when creating a new interpreter, to be able "
"to indicate that they would like some things \"inherited\" by the new "
"interpreter.  The mechanism could be a strict copy or it could be copy-"
"on-write.  The motivating example is with the warnings module (e.g. copy "
"the filters)."
msgstr ""

#: ../../peps/pep-0554.rst:1487
msgid ""
"The feature isn't critical, nor would it be widely useful, so it can wait"
" until there's interest.  Notably, both suggested solutions will require "
"significant work, especially when it comes to complex objects and most "
"especially for mutable containers of mutable complex objects."
msgstr ""

#: ../../peps/pep-0554.rst:1494
msgid "Make exceptions shareable"
msgstr ""

#: ../../peps/pep-0554.rst:1496
msgid ""
"Exceptions are propagated out of ``run()`` calls, so it isn't a big leap "
"to make them shareable.  However, as noted elsewhere, it isn't essential "
"or (particularly common) so we can wait on doing that."
msgstr ""

#: ../../peps/pep-0554.rst:1502
msgid "Make everything shareable through serialization"
msgstr ""

#: ../../peps/pep-0554.rst:1504
msgid ""
"We could use pickle (or marshal) to serialize everything and thus make "
"them shareable.  Doing this is potentially inefficient, but it may be a "
"matter of convenience in the end. We can add it later, but trying to "
"remove it later would be significantly more painful."
msgstr ""

#: ../../peps/pep-0554.rst:1511
msgid "Make RunFailedError.__cause__ lazy"
msgstr ""

#: ../../peps/pep-0554.rst:1513
msgid ""
"An uncaught exception in a subinterpreter (from ``interp.exec()``) is "
"copied to the calling interpreter and set as ``__cause__`` on a "
"``RunFailedError`` which is then raised.  That copying part involves some"
" sort of deserialization in the calling interpreter, which can be "
"expensive (e.g. due to imports) yet is not always necessary."
msgstr ""

#: ../../peps/pep-0554.rst:1519
msgid ""
"So it may be useful to use an ``ExceptionProxy`` type to wrap the "
"serialized exception and only deserialize it when needed.  That could be "
"via ``ExceptionProxy__getattribute__()`` or perhaps through "
"``RunFailedError.resolve()`` (which would raise the deserialized "
"exception and set ``RunFailedError.__cause__`` to the exception."
msgstr ""

#: ../../peps/pep-0554.rst:1525
msgid ""
"It may also make sense to have ``RunFailedError.__cause__`` be a "
"descriptor that does the lazy deserialization (and set ``__cause__``) on "
"the ``RunFailedError`` instance."
msgstr ""

#: ../../peps/pep-0554.rst:1530
msgid "Return a value from ``interp.exec()``"
msgstr ""

#: ../../peps/pep-0554.rst:1532
msgid ""
"Currently ``interp.exec()`` always returns None.  One idea is to return "
"the return value from whatever the subinterpreter ran.  However, for now "
"it doesn't make sense.  The only thing folks can run is a string of code "
"(i.e. a script).  This is equivalent to ``PyRun_StringFlags()``, "
"``exec()``, or a module body.  None of those \"return\" anything.  We can"
" revisit this once ``interp.exec()`` supports functions, etc."
msgstr ""

#: ../../peps/pep-0554.rst:1540
msgid "Add a shareable synchronization primitive"
msgstr ""

#: ../../peps/pep-0554.rst:1542
msgid ""
"This would be ``_threading.Lock`` (or something like it) where "
"interpreters would actually share the underlying mutex.  The main concern"
" is that locks and isolated interpreters may not mix well (as learned in "
"Go)."
msgstr ""

#: ../../peps/pep-0554.rst:1547
msgid "We can add this later if it proves desirable without much trouble."
msgstr ""

#: ../../peps/pep-0554.rst:1550
msgid "Propagate SystemExit and KeyboardInterrupt Differently"
msgstr ""

#: ../../peps/pep-0554.rst:1552
msgid ""
"The exception types that inherit from ``BaseException`` (aside from "
"``Exception``) are usually treated specially.  These types are: "
"``KeyboardInterrupt``, ``SystemExit``, and ``GeneratorExit``.  It may "
"make sense to treat them specially when it comes to propagation from "
"``interp.exec()``.  Here are some options::"
msgstr ""

#: ../../peps/pep-0554.rst:1563
msgid ""
"We aren't going to worry about handling them differently.  Threads "
"already ignore ``SystemExit``, so for now we will follow that pattern."
msgstr ""

#: ../../peps/pep-0554.rst:1567
msgid "Add an explicit release() and close() to channel end classes"
msgstr ""

#: ../../peps/pep-0554.rst:1569
msgid ""
"It can be convenient to have an explicit way to close a channel against "
"further global use.  Likewise it could be useful to have an explicit way "
"to release one of the channel ends relative to the current interpreter.  "
"Among other reasons, such a mechanism is useful for communicating overall"
" state between interpreters without the extra boilerplate that passing "
"objects through a channel directly would require."
msgstr ""

#: ../../peps/pep-0554.rst:1577
msgid ""
"The challenge is getting automatic release/close right without making it "
"hard to understand.  This is especially true when dealing with a non-"
"empty channel.  We should be able to get by without release/close for "
"now."
msgstr ""

#: ../../peps/pep-0554.rst:1583
msgid "Add SendChannel.send_buffer()"
msgstr ""

#: ../../peps/pep-0554.rst:1585
msgid ""
"This method would allow no-copy sending of an object through a channel if"
" it supports the :pep:`3118` buffer protocol (e.g. memoryview)."
msgstr ""

#: ../../peps/pep-0554.rst:1588
msgid ""
"Support for this is not fundamental to channels and can be added on later"
" without much disruption."
msgstr ""

#: ../../peps/pep-0554.rst:1592
msgid "Auto-run in a thread"
msgstr ""

#: ../../peps/pep-0554.rst:1594
msgid ""
"The PEP proposes a hard separation between subinterpreters and threads: "
"if you want to run in a thread you must create the thread yourself and "
"call ``interp.exec()`` in it.  However, it might be convenient if "
"``interp.exec()`` could do that for you, meaning there would be less "
"boilerplate."
msgstr ""

#: ../../peps/pep-0554.rst:1600
msgid ""
"Furthermore, we anticipate that users will want to run in a thread much "
"more often than not.  So it would make sense to make this the default "
"behavior.  We would add a kw-only param \"threaded\" (default ``True``) "
"to ``interp.exec()`` to allow the run-in-the-current-thread operation."
msgstr ""

#: ../../peps/pep-0554.rst:1607
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/pep-0554.rst:1610
msgid "Explicit channel association"
msgstr ""

#: ../../peps/pep-0554.rst:1612
msgid ""
"Interpreters are implicitly associated with channels upon ``recv()`` and "
"``send()`` calls.  They are de-associated with ``release()`` calls.  The "
"alternative would be explicit methods.  It would be either "
"``add_channel()`` and ``remove_channel()`` methods on ``Interpreter`` "
"objects or something similar on channel objects."
msgstr ""

#: ../../peps/pep-0554.rst:1618
msgid ""
"In practice, this level of management shouldn't be necessary for users. "
"So adding more explicit support would only add clutter to the API."
msgstr ""

#: ../../peps/pep-0554.rst:1622
msgid "Add an API based on pipes"
msgstr ""

#: ../../peps/pep-0554.rst:1624
msgid ""
"A pipe would be a simplex FIFO between exactly two interpreters.  For "
"most use cases this would be sufficient.  It could potentially simplify "
"the implementation as well.  However, it isn't a big step to supporting a"
" many-to-many simplex FIFO via channels.  Also, with pipes the API ends "
"up being slightly more complicated, requiring naming the pipes."
msgstr ""

#: ../../peps/pep-0554.rst:1631
msgid "Add an API based on queues"
msgstr ""

#: ../../peps/pep-0554.rst:1633
msgid ""
"Queues and buffered channels are almost the same thing.  The main "
"difference is that channels have a stronger relationship with context "
"(i.e. the associated interpreter)."
msgstr ""

#: ../../peps/pep-0554.rst:1637
msgid ""
"The name \"Channel\" was used instead of \"Queue\" to avoid confusion "
"with the stdlib ``queue.Queue``."
msgstr ""

#: ../../peps/pep-0554.rst:1641
msgid "\"enumerate\""
msgstr ""

#: ../../peps/pep-0554.rst:1643
msgid ""
"The ``list_all()`` function provides the list of all interpreters. In the"
" threading module, which partly inspired the proposed API, the function "
"is called ``enumerate()``.  The name is different here to avoid confusing"
" Python users that are not already familiar with the threading API.  For "
"them \"enumerate\" is rather unclear, whereas \"list_all\" is clear."
msgstr ""

#: ../../peps/pep-0554.rst:1651
msgid "Alternate solutions to prevent leaking exceptions across interpreters"
msgstr ""

#: ../../peps/pep-0554.rst:1653
msgid ""
"In function calls, uncaught exceptions propagate to the calling frame. "
"The same approach could be taken with ``interp.exec()``.  However, this "
"would mean that exception objects would leak across the inter-interpreter"
" boundary.  Likewise, the frames in the traceback would potentially leak."
msgstr ""

#: ../../peps/pep-0554.rst:1658
msgid ""
"While that might not be a problem currently, it would be a problem once "
"interpreters get better isolation relative to memory management (which is"
" necessary to stop sharing the GIL between interpreters).  We've resolved"
" the semantics of how the exceptions propagate by raising a "
"``RunFailedError`` instead, for which ``__cause__`` wraps a safe proxy "
"for the original exception and traceback."
msgstr ""

#: ../../peps/pep-0554.rst:1665
msgid "Rejected possible solutions:"
msgstr ""

#: ../../peps/pep-0554.rst:1667
msgid ""
"reproduce the exception and traceback in the original interpreter and "
"raise that."
msgstr ""

#: ../../peps/pep-0554.rst:1669
msgid ""
"raise a subclass of RunFailedError that proxies the original exception "
"and traceback."
msgstr ""

#: ../../peps/pep-0554.rst:1671
msgid "raise RuntimeError instead of RunFailedError"
msgstr ""

#: ../../peps/pep-0554.rst:1672
msgid ""
"convert at the boundary (a la ``subprocess.CalledProcessError``) "
"(requires a cross-interpreter representation)"
msgstr ""

#: ../../peps/pep-0554.rst:1674
msgid ""
"support customization via ``Interpreter.excepthook`` (requires a cross-"
"interpreter representation)"
msgstr ""

#: ../../peps/pep-0554.rst:1676
msgid ""
"wrap in a proxy at the boundary (including with support for something "
"like ``err.raise()`` to propagate the traceback)."
msgstr ""

#: ../../peps/pep-0554.rst:1678
msgid ""
"return the exception (or its proxy) from ``interp.exec()`` instead of "
"raising it"
msgstr ""

#: ../../peps/pep-0554.rst:1680
msgid ""
"return a result object (like ``subprocess`` does) [result-object]_ "
"(unnecessary complexity?)"
msgstr ""

#: ../../peps/pep-0554.rst:1682
msgid ""
"throw the exception away and expect users to deal with unhandled "
"exceptions explicitly in the script they pass to ``interp.exec()`` (they "
"can pass error info out via channels); with threads you have to do "
"something similar"
msgstr ""

#: ../../peps/pep-0554.rst:1688
msgid "Always associate each new interpreter with its own thread"
msgstr ""

#: ../../peps/pep-0554.rst:1690
msgid ""
"As implemented in the C-API, an interpreter is not inherently tied to any"
" thread.  Furthermore, it will run in any existing thread, whether "
"created by Python or not.  You only have to activate one of its thread "
"states (``PyThreadState``) in the thread first.  This means that the same"
" thread may run more than one interpreter (though obviously not at the "
"same time)."
msgstr ""

#: ../../peps/pep-0554.rst:1697
msgid ""
"The proposed module maintains this behavior.  Interpreters are not tied "
"to threads.  Only calls to ``Interpreter.exec()`` are.  However, one of "
"the key objectives of this PEP is to provide a more human-centric "
"concurrency model.  With that in mind, from a conceptual standpoint the "
"module *might* be easier to understand if each interpreter were "
"associated with its own thread."
msgstr ""

#: ../../peps/pep-0554.rst:1704
msgid ""
"That would mean ``interpreters.create()`` would create a new thread and "
"``Interpreter.exec()`` would only execute in that thread (and nothing "
"else would).  The benefit is that users would not have to wrap "
"``Interpreter.exec()`` calls in a new ``threading.Thread``.  Nor would "
"they be in a position to accidentally pause the current interpreter (in "
"the current thread) while their interpreter executes."
msgstr ""

#: ../../peps/pep-0554.rst:1712
msgid ""
"The idea is rejected because the benefit is small and the cost is high. "
"The difference from the capability in the C-API would be potentially "
"confusing.  The implicit creation of threads is magical.  The early "
"creation of threads is potentially wasteful.  The inability to run "
"arbitrary interpreters in an existing thread would prevent some valid use"
" cases, frustrating users.  Tying interpreters to threads would require "
"extra runtime modifications.  It would also make the module's "
"implementation overly complicated.  Finally, it might not even make the "
"module easier to understand."
msgstr ""

#: ../../peps/pep-0554.rst:1723
msgid "Only associate interpreters upon use"
msgstr ""

#: ../../peps/pep-0554.rst:1725
msgid ""
"Associate interpreters with channel ends only once ``recv()``, "
"``send()``, etc. are called."
msgstr ""

#: ../../peps/pep-0554.rst:1728
msgid ""
"Doing this is potentially confusing and also can lead to unexpected races"
" where a channel is auto-closed before it can be used in the original "
"(creating) interpreter."
msgstr ""

#: ../../peps/pep-0554.rst:1733
msgid "Allow multiple simultaneous calls to Interpreter.exec()"
msgstr ""

#: ../../peps/pep-0554.rst:1735
msgid ""
"This would make sense especially if ``Interpreter.exec()`` were to manage"
" new threads for you (which we've rejected).  Essentially, each call "
"would run independently, which would be mostly fine from a narrow "
"technical standpoint, since each interpreter can have multiple threads."
msgstr ""

#: ../../peps/pep-0554.rst:1741
msgid ""
"The problem is that the interpreter has only one ``__main__`` module and "
"simultaneous ``Interpreter.exec()`` calls would have to sort out sharing "
"``__main__`` or we'd have to invent a new mechanism.  Neither would be "
"simple enough to be worth doing."
msgstr ""

#: ../../peps/pep-0554.rst:1747
msgid "Add a \"reraise\" method to RunFailedError"
msgstr ""

#: ../../peps/pep-0554.rst:1749
msgid ""
"While having ``__cause__`` set on ``RunFailedError`` helps produce a more"
" useful traceback, it's less helpful when handling the original error.  "
"To help facilitate this, we could add ``RunFailedError.reraise()``.  This"
" method would enable the following pattern::"
msgstr ""

#: ../../peps/pep-0554.rst:1763
msgid ""
"This would be made even simpler if there existed a ``__reraise__`` "
"protocol."
msgstr ""

#: ../../peps/pep-0554.rst:1766
msgid ""
"All that said, this is completely unnecessary.  Using ``__cause__`` is "
"good enough::"
msgstr ""

#: ../../peps/pep-0554.rst:1777
msgid "Note that in extreme cases it may require a little extra boilerplate::"
msgstr ""

#: ../../peps/pep-0554.rst:1791
msgid "Implementation"
msgstr ""

#: ../../peps/pep-0554.rst:1793
msgid "The implementation of the PEP has 4 parts:"
msgstr ""

#: ../../peps/pep-0554.rst:1795
msgid ""
"the high-level module described in this PEP (mostly a light wrapper "
"around a low-level C extension"
msgstr ""

#: ../../peps/pep-0554.rst:1797
msgid "the low-level C extension module"
msgstr ""

#: ../../peps/pep-0554.rst:1798
msgid "additions to the internal C-API needed by the low-level module"
msgstr ""

#: ../../peps/pep-0554.rst:1799
msgid ""
"secondary fixes/changes in the CPython runtime that facilitate the low-"
"level module (among other benefits)"
msgstr ""

#: ../../peps/pep-0554.rst:1802
msgid ""
"These are at various levels of completion, with more done the lower you "
"go:"
msgstr ""

#: ../../peps/pep-0554.rst:1805
msgid ""
"the high-level module has been, at best, roughly implemented. However, "
"fully implementing it will be almost trivial."
msgstr ""

#: ../../peps/pep-0554.rst:1807
msgid ""
"the low-level module is mostly complete.  The bulk of the implementation "
"was merged into master in December 2018 as the \"_xxsubinterpreters\" "
"module (for the sake of testing multiple interpreters functionality).  "
"Only the exception propagation implementation remains to be finished, "
"which will not require extensive work."
msgstr ""

#: ../../peps/pep-0554.rst:1813
msgid "all necessary C-API work has been finished"
msgstr ""

#: ../../peps/pep-0554.rst:1814
msgid "all anticipated work in the runtime has been finished"
msgstr ""

#: ../../peps/pep-0554.rst:1816
msgid ""
"The implementation effort for :pep:`554` is being tracked as part of a "
"larger project aimed at improving multi-core support in CPython. [multi-"
"core-project]_"
msgstr ""

#: ../../peps/pep-0554.rst:1822
msgid "References"
msgstr "Referências"

#: ../../peps/pep-0554.rst:1825
msgid "https://docs.python.org/3/c-api/init.html#sub-interpreter-support"
msgstr ""

#: ../../peps/pep-0554.rst:1828
msgid ""
"https://en.wikipedia.org/wiki/Communicating_sequential_processes "
"https://github.com/futurecore/python-csp"
msgstr ""

#: ../../peps/pep-0554.rst:1832
msgid ""
"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe"
" "
"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue"
" https://docs.python.org/3/library/queue.html#module-queue "
"http://stackless.readthedocs.io/en/2.7-slp/library/stackless/channels.html"
" https://golang.org/doc/effective_go.html#sharing "
"http://www.jtolds.com/writing/2016/03/go-channels-are-bad-and-you-should-"
"feel-bad/"
msgstr ""

#: ../../peps/pep-0554.rst:1840
msgid "https://docs.python.org/3/c-api/init.html#bugs-and-caveats"
msgstr ""

#: ../../peps/pep-0554.rst:1843
msgid "https://github.com/pyca/cryptography/issues/2299"
msgstr ""

#: ../../peps/pep-0554.rst:1846
msgid "https://bugs.python.org/issue10915 http://bugs.python.org/issue15751"
msgstr ""

#: ../../peps/pep-0554.rst:1850
msgid "https://mail.python.org/pipermail/python-ideas/2017-September/047094.html"
msgstr ""

#: ../../peps/pep-0554.rst:1853
msgid "https://mail.python.org/pipermail/python-ideas/2017-September/047122.html"
msgstr ""

#: ../../peps/pep-0554.rst:1856
msgid "https://mail.python.org/pipermail/python-dev/2017-September/149545.html"
msgstr ""

#: ../../peps/pep-0554.rst:1859
msgid ""
"https://mail.python.org/pipermail/python-dev/2017-September/149420.html "
"https://mail.python.org/pipermail/python-dev/2017-September/149585.html"
msgstr ""

#: ../../peps/pep-0554.rst:1863
msgid "https://mail.python.org/pipermail/python-dev/2017-September/149562.html"
msgstr ""

#: ../../peps/pep-0554.rst:1866
msgid "https://mail.python.org/pipermail/python-ideas/2017-May/045771.html"
msgstr ""

#: ../../peps/pep-0554.rst:1869
msgid "https://github.com/ericsnowcurrently/multi-core-python"
msgstr ""

#: ../../peps/pep-0554.rst:1872
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/message/3HVRFWHDMWPNR367GXBILZ4JJAUQ2STZ/"
msgstr ""

#: ../../peps/pep-0554.rst:1878
msgid "mp-conn"
msgstr ""

#: ../../peps/pep-0554.rst:1878
msgid "https://docs.python.org/3/library/multiprocessing.html#connection-objects"
msgstr ""

#: ../../peps/pep-0554.rst:1882
msgid "main-thread"
msgstr ""

#: ../../peps/pep-0554.rst:1881
msgid ""
"https://mail.python.org/pipermail/python-ideas/2017-September/047144.html"
" https://mail.python.org/pipermail/python-dev/2017-September/149566.html"
msgstr ""

#: ../../peps/pep-0554.rst:1886
msgid "petr-c-ext"
msgstr ""

#: ../../peps/pep-0554.rst:1885
msgid ""
"https://mail.python.org/pipermail/import-sig/2016-June/001062.html "
"https://mail.python.org/pipermail/python-ideas/2016-April/039748.html"
msgstr ""

#: ../../peps/pep-0554.rst:1889
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-0554.rst:1891
msgid "This document has been placed in the public domain."
msgstr "Este documento foi colocado em domínio público."

#~ msgid "BDFL-Delegate"
#~ msgstr ""

#~ msgid "Antoine Pitrou <antoine@python.org>"
#~ msgstr ""

#~ msgid "3.12"
#~ msgstr ""

#~ msgid ""
#~ "07-Sep-2017, 08-Sep-2017, 13-Sep-2017, 05-Dec-2017,"
#~ " 09-May-2018, 20-Apr-2020, 04-May-2020"
#~ msgstr ""

#~ msgid ""
#~ "CPython has supported multiple interpreters"
#~ " in the same process (AKA "
#~ "\"subinterpreters\") since version 1.5 (1997)."
#~ "  The feature has been available via"
#~ " the C-API. [c-api]_  Subinterpreters "
#~ "operate in `relative isolation from one"
#~ " another <Interpreter Isolation_>`_, which "
#~ "facilitates novel alternative approaches to"
#~ " `concurrency <Concurrency_>`_."
#~ msgstr ""

#~ msgid ""
#~ "This proposal introduces the stdlib "
#~ "``interpreters`` module.  The module will "
#~ "be `provisional <Provisional Status_>`_.  It"
#~ " exposes the basic functionality of "
#~ "subinterpreters already provided by the "
#~ "C-API, along with new (basic) "
#~ "functionality for sharing data between "
#~ "interpreters."
#~ msgstr ""

#~ msgid "A Disclaimer about the GIL"
#~ msgstr ""

#~ msgid ""
#~ "To avoid any confusion up front:  "
#~ "This PEP is unrelated to any "
#~ "efforts to stop sharing the GIL "
#~ "between subinterpreters.  At most this "
#~ "proposal will allow users to take "
#~ "advantage of any results of work "
#~ "on the GIL. The position here is"
#~ " that exposing subinterpreters to Python"
#~ " code is worth doing, even if "
#~ "they still share the GIL."
#~ msgstr ""

#~ msgid ""
#~ "The ``interpreters`` module will be "
#~ "added to the stdlib.  To help "
#~ "authors of extension modules, a new "
#~ "page will be added to the "
#~ "`Extending Python <extension-docs_>`_ docs."
#~ "  More information on both is found"
#~ " in the immediately following sections."
#~ msgstr ""

#~ msgid ""
#~ "The ``interpreters`` module will provide "
#~ "a high-level interface to "
#~ "subinterpreters and wrap a new low-"
#~ "level ``_interpreters`` (in the same way"
#~ " as the ``threading`` module).  See "
#~ "the `Examples`_ section for concrete "
#~ "usage and use cases."
#~ msgstr ""

#~ msgid ""
#~ "Along with exposing the existing (in "
#~ "CPython) subinterpreter support, the module"
#~ " will also provide a mechanism for"
#~ " sharing data between interpreters.  This"
#~ " mechanism centers around \"channels\", "
#~ "which are similar to queues and "
#~ "pipes."
#~ msgstr ""

#~ msgid ""
#~ "Note that *objects* are not shared "
#~ "between interpreters since they are tied"
#~ " to the interpreter in which they "
#~ "were created.  Instead, the objects' "
#~ "*data* is passed between interpreters.  "
#~ "See the `Shared data`_ section for "
#~ "more details about sharing between "
#~ "interpreters."
#~ msgstr ""

#~ msgid "At first only the following types will be supported for sharing:"
#~ msgstr ""

#~ msgid "None"
#~ msgstr ""

#~ msgid "bytes"
#~ msgstr ""

#~ msgid "str"
#~ msgstr ""

#~ msgid "int"
#~ msgstr ""

#~ msgid ":pep:`554` channels"
#~ msgstr ""

#~ msgid ""
#~ "Support for other basic types (e.g. "
#~ "bool, float, Ellipsis) will be added "
#~ "later."
#~ msgstr ""

#~ msgid "``create(*, isolated=True) -> Interpreter``"
#~ msgstr ""

#~ msgid "``class Interpreter(id)``"
#~ msgstr ""

#~ msgid "``.isolated``"
#~ msgstr ""

#~ msgid "The interpreter's mode (read-only)."
#~ msgstr ""

#~ msgid "``.run(src_str, /, *, channels=None)``"
#~ msgstr ""

#~ msgid "Run the given source code in the interpreter."
#~ msgstr ""

#~ msgid "(This blocks the current thread until done.)"
#~ msgstr ""

#~ msgid "exception"
#~ msgstr ""

#~ msgid "base"
#~ msgstr ""

#~ msgid "``RunFailedError``"
#~ msgstr ""

#~ msgid "``RuntimeError``"
#~ msgstr ""

#~ msgid "Interpreter.run() resulted in an uncaught exception."
#~ msgstr ""

#~ msgid "For sharing data between interpreters:"
#~ msgstr ""

#~ msgid "Can the object's data be shared"
#~ msgstr ""

#~ msgid "``list_all_channels() -> [(RecvChannel, SendChannel)]``"
#~ msgstr ""

#~ msgid "Get all open channels."
#~ msgstr ""

#~ msgid "``class RecvChannel(id)``"
#~ msgstr ""

#~ msgid "The receiving end of a channel."
#~ msgstr ""

#~ msgid "The channel's unique ID."
#~ msgstr ""

#~ msgid "``.recv() -> object``"
#~ msgstr ""

#~ msgid "Get the next object from the channel,"
#~ msgstr ""

#~ msgid "and wait if none have been sent."
#~ msgstr ""

#~ msgid "``.recv_nowait(default=None) -> object``"
#~ msgstr ""

#~ msgid "Like recv(), but return the default"
#~ msgstr ""

#~ msgid "instead of waiting."
#~ msgstr ""

#~ msgid "``class SendChannel(id)``"
#~ msgstr ""

#~ msgid "The sending end of a channel."
#~ msgstr ""

#~ msgid "``.send(obj)``"
#~ msgstr ""

#~ msgid "Send the object (i.e. its data) to the"
#~ msgstr ""

#~ msgid "receiving end of the channel and wait."
#~ msgstr ""

#~ msgid "``.send_nowait(obj)``"
#~ msgstr ""

#~ msgid "Like send(), but return False if not received."
#~ msgstr ""

#~ msgid "``ChannelError``"
#~ msgstr ""

#~ msgid "``Exception``"
#~ msgstr ""

#~ msgid "The base class for channel-related exceptions."
#~ msgstr ""

#~ msgid "``ChannelNotFoundError``"
#~ msgstr ""

#~ msgid "The identified channel was not found."
#~ msgstr ""

#~ msgid "``ChannelEmptyError``"
#~ msgstr ""

#~ msgid "The channel was unexpectedly empty."
#~ msgstr ""

#~ msgid "``ChannelNotEmptyError``"
#~ msgstr ""

#~ msgid "The channel was unexpectedly not empty."
#~ msgstr ""

#~ msgid "``NotReceivedError``"
#~ msgstr ""

#~ msgid "Nothing was waiting to receive a sent object."
#~ msgstr ""

#~ msgid ""
#~ "Many extension modules do not support"
#~ " use in subinterpreters yet.  The "
#~ "maintainers and users of such extension"
#~ " modules will both benefit when they"
#~ " are updated to support subinterpreters."
#~ "  In the meantime users may become"
#~ " confused by failures when using "
#~ "subinterpreters, which could negatively impact"
#~ " extension maintainers.  See `Concerns`_ "
#~ "below."
#~ msgstr ""

#~ msgid ""
#~ "be clear that extension modules are "
#~ "*not* required to support use in "
#~ "subinterpreters"
#~ msgstr ""

#~ msgid ""
#~ "raise ``ImportError`` when an incompatible "
#~ "(no :pep:`489` support) module is "
#~ "imported in a subinterpreter"
#~ msgstr ""

#~ msgid "Run isolated code"
#~ msgstr ""

#~ msgid "Run in a thread"
#~ msgstr ""

#~ msgid "Synchronize using a channel"
#~ msgstr ""

#~ msgid "Passing objects via marshal"
#~ msgstr ""

#~ msgid "Running in a thread pool executor"
#~ msgstr ""

#~ msgid ""
#~ "Running code in multiple interpreters "
#~ "provides a useful level of isolation "
#~ "within the same process.  This can "
#~ "be leveraged in a number of ways."
#~ "  Furthermore, subinterpreters provide a "
#~ "well-defined framework in which such "
#~ "isolation may extended."
#~ msgstr ""

#~ msgid ""
#~ "Nick Coghlan explained some of the "
#~ "benefits through a comparison with "
#~ "multi-processing [benefits]_::"
#~ msgstr ""

#~ msgid ""
#~ "CPython has supported subinterpreters, with"
#~ " increasing levels of support, since "
#~ "version 1.5.  While the feature has "
#~ "the potential to be a powerful "
#~ "tool, subinterpreters have suffered from "
#~ "neglect because they are not available"
#~ " directly from Python.  Exposing the "
#~ "existing functionality in the stdlib "
#~ "will help reverse the situation."
#~ msgstr ""

#~ msgid ""
#~ "This proposal is focused on enabling "
#~ "the fundamental capability of multiple "
#~ "isolated interpreters in the same Python"
#~ " process.  This is a new area "
#~ "for Python so there is relative "
#~ "uncertainly about the best tools to "
#~ "provide as companions to subinterpreters.  "
#~ "Thus we minimize the functionality we"
#~ " add in the proposal as much as"
#~ " possible."
#~ msgstr ""

#~ msgid ""
#~ "Some have argued that subinterpreters do"
#~ " not add sufficient benefit to "
#~ "justify making them an official part "
#~ "of Python.  Adding features to the "
#~ "language (or stdlib) has a cost in"
#~ " increasing the size of the language."
#~ "  So an addition must pay for "
#~ "itself.  In this case, subinterpreters "
#~ "provide a novel concurrency model "
#~ "focused on isolated threads of "
#~ "execution.  Furthermore, they provide an "
#~ "opportunity for changes in CPython that"
#~ " will allow simultaneous use of "
#~ "multiple CPU cores (currently prevented "
#~ "by the GIL)."
#~ msgstr ""

#~ msgid ""
#~ "\"stdlib support for subinterpreters adds "
#~ "extra burden on C extension authors\""
#~ msgstr ""

#~ msgid ""
#~ "In the `Interpreter Isolation`_ section "
#~ "below we identify ways in which "
#~ "isolation in CPython's subinterpreters is "
#~ "incomplete.  Most notable is extension "
#~ "modules that use C globals to "
#~ "store internal state.  :pep:`3121` and "
#~ ":pep:`489` provide a solution for most"
#~ " of the problem, but one still "
#~ "remains. [petr-c-ext]_  Until that is "
#~ "resolved (see :pep:`573`), C extension "
#~ "authors will face extra difficulty to"
#~ " support subinterpreters."
#~ msgstr ""

#~ msgid ""
#~ "Introducing an API for a new "
#~ "concurrency model, like happened with "
#~ "asyncio, is an extremely large project"
#~ " that requires a lot of careful "
#~ "consideration.  It is not something that"
#~ " can be done a simply as this"
#~ " PEP proposes and likely deserves "
#~ "significant time on PyPI to mature. "
#~ "(See `Nathaniel's post <nathaniel-asyncio_>`_"
#~ " on python-dev.)"
#~ msgstr ""

#~ msgid ""
#~ "However, this PEP does not propose "
#~ "any new concurrency API.  At most "
#~ "it exposes minimal tools (e.g. "
#~ "subinterpreters, channels) which may be "
#~ "used to write code that follows "
#~ "patterns associated with (relatively) new-"
#~ "to-Python `concurrency models "
#~ "<Concurrency_>`_.  Those tools could also "
#~ "be used as the basis for APIs "
#~ "for such concurrency models. Again, this"
#~ " PEP does not propose any such "
#~ "API."
#~ msgstr ""

#~ msgid ""
#~ "A common misconception is that this "
#~ "PEP also includes a promise that "
#~ "subinterpreters will no longer share the"
#~ " GIL.  When that is clarified, the"
#~ " next question is \"what is the "
#~ "point?\".  This is already answered at"
#~ " length in this PEP.  Just to "
#~ "be clear, the value lies in::"
#~ msgstr ""

#~ msgid ""
#~ "One class of concurrency models focuses"
#~ " on isolated threads of execution "
#~ "that interoperate through some message "
#~ "passing scheme.  A notable example is"
#~ " Communicating Sequential Processes [CSP]_ "
#~ "(upon which Go's concurrency is roughly"
#~ " based).  The isolation inherent to "
#~ "subinterpreters makes them well-suited "
#~ "to this approach."
#~ msgstr ""

#~ msgid "Shared data"
#~ msgstr ""

#~ msgid ""
#~ "Subinterpreters are inherently isolated (with"
#~ " caveats explained below), in contrast "
#~ "to threads.  So the same communicate-"
#~ "via-shared-memory approach doesn't work."
#~ "  Without an alternative, effective use "
#~ "of concurrency via subinterpreters is "
#~ "significantly limited."
#~ msgstr ""

#~ msgid ""
#~ "The key challenge here is that "
#~ "sharing objects between interpreters faces "
#~ "complexity due to various constraints on"
#~ " object ownership, visibility, and "
#~ "mutability.  At a conceptual level it's"
#~ " easier to reason about concurrency "
#~ "when objects only exist in one "
#~ "interpreter at a time.  At a "
#~ "technical level, CPython's current memory "
#~ "model limits how Python *objects* may"
#~ " be shared safely between interpreters; "
#~ "effectively objects are bound to the "
#~ "interpreter in which they were created."
#~ "  Furthermore, the complexity of *object*"
#~ " sharing increases as subinterpreters "
#~ "become more isolated, e.g. after GIL "
#~ "removal."
#~ msgstr ""

#~ msgid ""
#~ "Consequently,the mechanism for sharing needs"
#~ " to be carefully considered. There "
#~ "are a number of valid solutions, "
#~ "several of which may be appropriate "
#~ "to support in Python.  This proposal "
#~ "provides a single basic solution: "
#~ "\"channels\".  Ultimately, any other solution"
#~ " will look similar to the proposed"
#~ " one, which will set the precedent."
#~ "  Note that the implementation of "
#~ "``Interpreter.run()`` will be done in a"
#~ " way that allows for multiple "
#~ "solutions to coexist, but doing so "
#~ "is not technically a part of the"
#~ " proposal here."
#~ msgstr ""

#~ msgid ""
#~ "Regarding the proposed solution, \"channels\","
#~ " it is a basic, opt-in data "
#~ "sharing mechanism that draws inspiration "
#~ "from pipes, queues, and CSP's channels."
#~ " [fifo]_"
#~ msgstr ""

#~ msgid ""
#~ "As simply described earlier by the "
#~ "API summary, channels have two "
#~ "operations: send and receive.  A key "
#~ "characteristic of those operations is "
#~ "that channels transmit data derived from"
#~ " Python objects rather than the "
#~ "objects themselves.  When objects are "
#~ "sent, their data is extracted.  When "
#~ "the \"object\" is received in the "
#~ "other interpreter, the data is converted"
#~ " back into an object owned by "
#~ "that interpreter."
#~ msgstr ""

#~ msgid ""
#~ "To make this work, the mutable "
#~ "shared state will be managed by "
#~ "the Python runtime, not by any of"
#~ " the interpreters.  Initially we will "
#~ "support only one type of objects "
#~ "for shared state: the channels provided"
#~ " by ``create_channel()``.  Channels, in "
#~ "turn, will carefully manage passing "
#~ "objects between interpreters."
#~ msgstr ""

#~ msgid ""
#~ "This approach, including keeping the API"
#~ " minimal, helps us avoid further "
#~ "exposing any underlying complexity to "
#~ "Python users.  Along those same lines,"
#~ " we will initially restrict the types"
#~ " that may be passed through channels"
#~ " to the following:"
#~ msgstr ""

#~ msgid "channels"
#~ msgstr ""

#~ msgid ""
#~ "Limiting the initial shareable types is"
#~ " a practical matter, reducing the "
#~ "potential complexity of the initial "
#~ "implementation.  There are a number of"
#~ " strategies we may pursue in the "
#~ "future to expand supported objects and"
#~ " object sharing strategies."
#~ msgstr ""

#~ msgid ""
#~ "However, there are ways in which "
#~ "interpreters share some state.  First of"
#~ " all, some process-global state "
#~ "remains shared:"
#~ msgstr ""

#~ msgid "GC is not run per-interpreter [global-gc]_"
#~ msgstr ""

#~ msgid "at-exit handlers are not run per-interpreter [global-atexit]_"
#~ msgstr ""

#~ msgid "extensions using the ``PyGILState_*`` API are incompatible [gilstate]_"
#~ msgstr ""

#~ msgid "interpreters share memory management (e.g. allocators, gc)"
#~ msgstr ""

#~ msgid "interpreters share the GIL"
#~ msgstr ""

#~ msgid ""
#~ "Subinterpreters are not a widely used"
#~ " feature.  In fact, the only "
#~ "documented cases of widespread usage are"
#~ " `mod_wsgi <https://github.com/GrahamDumpleton/mod_wsgi>`_,"
#~ " `OpenStack Ceph "
#~ "<https://github.com/ceph/ceph/pull/14971>`_, and `JEP "
#~ "<https://github.com/ninia/jep>`_.  On the one "
#~ "hand, these cases provide confidence "
#~ "that existing subinterpreter support is "
#~ "relatively stable.  On the other hand,"
#~ " there isn't much of a sample "
#~ "size from which to judge the "
#~ "utility of the feature."
#~ msgstr ""

#~ msgid "Provisional Status"
#~ msgstr ""

#~ msgid ""
#~ "The new ``interpreters`` module will be"
#~ " added with \"provisional\" status (see "
#~ ":pep:`411`).  This allows Python users "
#~ "to experiment with the feature and "
#~ "provide feedback while still allowing us"
#~ " to adjust to that feedback. The "
#~ "module will be provisional in Python "
#~ "3.9 and we will make a decision"
#~ " before the 3.10 release whether to"
#~ " keep it provisional, graduate it, or"
#~ " remove it.  This PEP will be "
#~ "updated accordingly."
#~ msgstr ""

#~ msgid ""
#~ "While the module is provisional, any "
#~ "changes to the API (or to "
#~ "behavior) do not need to be "
#~ "reflected here, nor get approval by "
#~ "the BDFL-delegate. However, such changes"
#~ " will still need to go through "
#~ "the normal processes (BPO for smaller"
#~ " changes and python-dev/PEP for "
#~ "substantial ones)."
#~ msgstr ""

#~ msgid ""
#~ "I've solicited feedback from various "
#~ "Python implementors about support for "
#~ "subinterpreters.  Each has indicated that "
#~ "they would be able to support "
#~ "subinterpreters (if they choose to) "
#~ "without a lot of trouble.  Here "
#~ "are the projects I contacted:"
#~ msgstr ""

#~ msgid ""
#~ "Regarding uncaught exceptions in "
#~ "``Interpreter.run()``, we noted that they "
#~ "are \"effectively\" propagated into the "
#~ "code where ``run()`` was called.  To "
#~ "prevent leaking exceptions (and tracebacks)"
#~ " between interpreters, we create a "
#~ "surrogate of the exception and its "
#~ "traceback (see ``traceback.TracebackException``), "
#~ "set it to ``__cause__`` on a new"
#~ " ``RunFailedError``, and raise that."
#~ msgstr ""

#~ msgid ""
#~ "Raising (a proxy of) the exception "
#~ "directly is problematic since it's "
#~ "harder to distinguish between an error"
#~ " in the ``run()`` call and an "
#~ "uncaught exception from the subinterpreter."
#~ msgstr ""

#~ msgid "API for sharing data"
#~ msgstr ""

#~ msgid ""
#~ "Subinterpreters are less useful without "
#~ "a mechanism for sharing data between "
#~ "them.  Sharing actual Python objects "
#~ "between interpreters, however, has enough "
#~ "potential problems that we are avoiding"
#~ " support for that here.  Instead, "
#~ "only minimum set of types will be"
#~ " supported. Initially this will include "
#~ "``None``, ``bytes``, ``str``, ``int``, and "
#~ "channels.  Further types may be "
#~ "supported later."
#~ msgstr ""

#~ msgid ""
#~ "The ``interpreters`` module provides a "
#~ "function that users may call to "
#~ "determine whether an object is shareable"
#~ " or not::"
#~ msgstr ""

#~ msgid ""
#~ "This proposal provides two ways to "
#~ "share such objects between interpreters."
#~ msgstr ""

#~ msgid ""
#~ "First, channels may be passed to "
#~ "``run()`` via the ``channels`` keyword "
#~ "argument, where they are effectively "
#~ "injected into the target interpreter's "
#~ "``__main__`` module.  While passing arbitrary"
#~ " shareable objects this way is "
#~ "possible, doing so is mainly intended"
#~ " for sharing meta-objects (e.g. "
#~ "channels) between interpreters.  It is "
#~ "less useful to pass other objects "
#~ "(like ``bytes``) to ``run`` directly."
#~ msgstr ""

#~ msgid ""
#~ "Second, the main mechanism for sharing"
#~ " objects (i.e. their data) between "
#~ "interpreters is through channels.  A "
#~ "channel is a simplex FIFO similar "
#~ "to a pipe.  The main difference is"
#~ " that channels can be associated with"
#~ " zero or more interpreters on either"
#~ " end.  Like queues, which are also"
#~ " many-to-many, channels are buffered"
#~ " (though they also offer methods with"
#~ " unbuffered semantics)."
#~ msgstr ""

#~ msgid ""
#~ "Python objects are not shared between"
#~ " interpreters.  However, in some cases "
#~ "data those objects wrap is actually "
#~ "shared and not just copied. One "
#~ "example might be :pep:`3118` buffers.  "
#~ "In those cases the object in the"
#~ " original interpreter is kept alive "
#~ "until the shared data in the other"
#~ " interpreter is no longer used.  Then"
#~ " object destruction can happen like "
#~ "normal in the original interpreter, "
#~ "along with the previously shared data."
#~ msgstr ""

#~ msgid ""
#~ "The ``interpreters`` module provides the "
#~ "following functions related to channels::"
#~ msgstr ""

#~ msgid "Channel Lifespan"
#~ msgstr ""

#~ msgid ""
#~ "A channel is automatically closed and"
#~ " destroyed once there are no more "
#~ "Python objects (e.g. ``RecvChannel`` and "
#~ "``SendChannel``) referring to it.  So it"
#~ " is effectively triggered via garbage-"
#~ "collection of those objects.."
#~ msgstr ""

#~ msgid "Interpreter \"Isolated\" Mode"
#~ msgstr ""

#~ msgid ""
#~ "By default, every new interpreter "
#~ "created by ``interpreters.create()`` has "
#~ "specific restrictions on any code it "
#~ "runs.  This includes the following:"
#~ msgstr ""

#~ msgid ""
#~ "importing an extension module fails if"
#~ " it does not implement the :pep:`489`"
#~ " API"
#~ msgstr ""

#~ msgid "new threads of any kind are not allowed"
#~ msgstr ""

#~ msgid ""
#~ "``os.exec*()``, AKA \"fork+exec\", is not "
#~ "allowed (so no ``subprocess``)"
#~ msgstr ""

#~ msgid ""
#~ "This represents the full \"isolated\" "
#~ "mode of subinterpreters.  It is applied"
#~ " when ``interpreters.create()`` is called "
#~ "with the \"isolated\" keyword-only "
#~ "argument set to ``True`` (the default)."
#~ "  If ``interpreters.create(isolated=False)`` is "
#~ "called then none of those restrictions"
#~ " is applied."
#~ msgstr ""

#~ msgid ""
#~ "One advantage of this approach is "
#~ "that it allows extension maintainers to"
#~ " check subinterpreter compatibility before "
#~ "they implement the :pep:`489` API.  Also"
#~ " note that ``isolated=False`` represents "
#~ "the historical behavior when using the"
#~ " existing subinterpreters C-API, thus "
#~ "providing backward compatibility.  For the "
#~ "existing C-API itself, the default "
#~ "remains ``isolated=False``.  The same is "
#~ "true for the \"main\" module, so "
#~ "existing use of Python will not "
#~ "change."
#~ msgstr ""

#~ msgid ""
#~ "We may choose to later loosen some"
#~ " of the above restrictions or provide"
#~ " a way to enable/disable granular "
#~ "restrictions individually.  Regardless, requiring"
#~ " :pep:`489` support from extension modules"
#~ " will always be a default "
#~ "restriction."
#~ msgstr ""

#~ msgid ""
#~ "(at the top) a clear note that "
#~ "subinterpreter support in extension modules"
#~ " is not required"
#~ msgstr ""

#~ msgid "brief examples of how to use subinterpreters and channels"
#~ msgstr ""

#~ msgid "a summary of the limitations of subinterpreters"
#~ msgstr ""

#~ msgid ""
#~ "(for extension maintainers) a link to"
#~ " the resources for ensuring subinterpreter"
#~ " compatibility"
#~ msgstr ""

#~ msgid ""
#~ "A separate page will be added to"
#~ " the docs for resources to help "
#~ "extension maintainers ensure their modules "
#~ "can be used safely in subinterpreters,"
#~ " under `Extending Python <extension-"
#~ "docs_>`_.  The page will include the "
#~ "following information:"
#~ msgstr ""

#~ msgid ""
#~ "a summary about subinterpreters (similar "
#~ "to the same in the new "
#~ "``interpreters`` module page and in the"
#~ " C-API docs)"
#~ msgstr ""

#~ msgid "an explanation of how extension modules can be impacted"
#~ msgstr ""

#~ msgid "how to implement :pep:`489` support"
#~ msgstr ""

#~ msgid "how to move from global module state to per-interpreter"
#~ msgstr ""

#~ msgid ""
#~ "how to take advantage of :pep:`384` "
#~ "(heap types), :pep:`3121` (module state), "
#~ "and :pep:`573`"
#~ msgstr ""

#~ msgid ""
#~ "strategies for dealing with 3rd party"
#~ " C libraries that keep their own "
#~ "subinterpreter-incompatible global state"
#~ msgstr ""

#~ msgid ""
#~ "Also, the ``ImportError`` for incompatible "
#~ "extgension modules will have a message"
#~ " that clearly says it is due to"
#~ " missing subinterpreter compatibility and "
#~ "that extensions are not required to "
#~ "provide it.  This will help set "
#~ "user expectations properly."
#~ msgstr ""

#~ msgid ""
#~ "It would be convenient to run "
#~ "existing functions in subinterpreters "
#~ "directly.  ``Interpreter.run()`` could be "
#~ "adjusted to support this or a "
#~ "``call()`` method could be added::"
#~ msgstr ""

#~ msgid "timeout arg to recv() and send()"
#~ msgstr ""

#~ msgid ""
#~ "Typically functions that have a "
#~ "``block`` argument also have a "
#~ "``timeout`` argument.  It sometimes makes "
#~ "sense to do likewise for functions "
#~ "that otherwise block, like the channel"
#~ " ``recv()`` and ``send()`` methods.  We "
#~ "can add it later if needed."
#~ msgstr ""

#~ msgid ""
#~ "This method would make a ``run()`` "
#~ "call for you in a thread.  Doing"
#~ " this using only ``threading.Thread`` and"
#~ " ``run()`` is relatively trivial so "
#~ "we've left it out."
#~ msgstr ""

#~ msgid ""
#~ "The ``threading`` module provides a "
#~ "number of synchronization primitives for "
#~ "coordinating concurrent operations.  This is"
#~ " especially necessary due to the "
#~ "shared-state nature of threading.  In "
#~ "contrast, subinterpreters do not share "
#~ "state.  Data sharing is restricted to"
#~ " channels, which do away with the "
#~ "need for explicit synchronization.  If "
#~ "any sort of opt-in shared state"
#~ " support is added to subinterpreters "
#~ "in the future, that same effort "
#~ "can introduce synchronization primitives to"
#~ " meet that need."
#~ msgstr ""

#~ msgid ""
#~ "The ``Go`` language provides a "
#~ "concurrency model based on CSP, so "
#~ "it's similar to the concurrency model"
#~ " that subinterpreters support. However, "
#~ "``Go`` also provides syntactic support, "
#~ "as well several builtin concurrency "
#~ "primitives, to make concurrency a "
#~ "first-class feature. Conceivably, similar "
#~ "syntactic (and builtin) support could be"
#~ " added to Python using subinterpreters."
#~ "  However, that is *way* outside the"
#~ " scope of this PEP!"
#~ msgstr ""

#~ msgid ""
#~ "The ``multiprocessing`` module could support"
#~ " subinterpreters in the same way it"
#~ " supports threads and processes.  In "
#~ "fact, the module's maintainer, Davin "
#~ "Potts, has indicated this is a "
#~ "reasonable feature request.  However, it "
#~ "is outside the narrow scope of "
#~ "this PEP."
#~ msgstr ""

#~ msgid ""
#~ "By using the ``PyModuleDef_Slot`` introduced"
#~ " by :pep:`489`, we could easily add"
#~ " a mechanism by which C-extension "
#~ "modules could opt out of support "
#~ "for subinterpreters.  Then the import "
#~ "machinery, when operating in a "
#~ "subinterpreter, would need to check the"
#~ " module for support.  It would raise"
#~ " an ImportError if unsupported."
#~ msgstr ""

#~ msgid ""
#~ "Alternately we could support opting in"
#~ " to subinterpreter support. However, that"
#~ " would probably exclude many more "
#~ "modules (unnecessarily) than the opt-out"
#~ " approach.  Also, note that :pep:`489` "
#~ "defined that an extension's use of "
#~ "the PEP's machinery implies support for"
#~ " subinterpreters."
#~ msgstr ""

#~ msgid ""
#~ "As proposed, every call to "
#~ "``Interpreter.run()`` will execute in the "
#~ "namespace of the interpreter's existing "
#~ "``__main__`` module.  This means that "
#~ "data persists there between ``run()`` "
#~ "calls.  Sometimes this isn't desirable "
#~ "and you want to execute in a "
#~ "fresh ``__main__``.  Also, you don't "
#~ "necessarily want to leak objects there"
#~ " that you aren't using any more."
#~ msgstr ""

#~ msgid ""
#~ "a ``create()`` arg to indicate resetting"
#~ " ``__main__`` after each ``run`` call"
#~ msgstr ""

#~ msgid ""
#~ "Also note that resetting ``__main__`` "
#~ "does nothing about state stored in "
#~ "other modules.  So any solution would"
#~ " have to be clear about the "
#~ "scope of what is being reset.  "
#~ "Conceivably we could invent a mechanism"
#~ " by which any (or every) module "
#~ "could be reset, unlike ``reload()`` "
#~ "which does not clear the module "
#~ "before loading into it.  Regardless, "
#~ "since ``__main__`` is the execution "
#~ "namespace of the interpreter, resetting "
#~ "it has a much more direct "
#~ "correlation to interpreters and their "
#~ "dynamic state than does resetting other"
#~ " modules.  So a more generic module"
#~ " reset mechanism may prove unnecessary."
#~ msgstr ""

#~ msgid ""
#~ "A possible solution is to add an"
#~ " ``Interpreter.reset()`` method.  This would "
#~ "put the interpreter back into the "
#~ "state it was in when newly "
#~ "created.  If called on a running "
#~ "interpreter it would fail (hence the "
#~ "main interpreter could never be reset)."
#~ "  This would likely be more efficient"
#~ " than creating a new subinterpreter, "
#~ "though that depends on what "
#~ "optimizations will be made later to "
#~ "subinterpreter creation."
#~ msgstr ""

#~ msgid "File descriptors and sockets in channels"
#~ msgstr ""

#~ msgid ""
#~ "Given that file descriptors and sockets"
#~ " are process-global resources, support "
#~ "for passing them through channels is "
#~ "a reasonable idea.  They would be "
#~ "a good candidate for the first "
#~ "effort at expanding the types that "
#~ "channels support.  They aren't strictly "
#~ "necessary for the initial API."
#~ msgstr ""

#~ msgid ""
#~ "A possible solution is to provide "
#~ "async implementations of the blocking "
#~ "channel methods (``recv()``, and ``send()``)."
#~ "  However, the basic functionality of "
#~ "subinterpreters does not depend on async"
#~ " and can be added later."
#~ msgstr ""

#~ msgid ""
#~ "With the proposed object passing "
#~ "mechanism of \"channels\", other similar "
#~ "basic types aren't required to achieve"
#~ " the minimal useful functionality of "
#~ "subinterpreters.  Such types include pipes "
#~ "(like unbuffered channels, but one-"
#~ "to-one) and queues (like channels, "
#~ "but more generic).  See below in "
#~ "`Rejected Ideas`_ for more information."
#~ msgstr ""

#~ msgid ""
#~ "Folks might find it useful, when "
#~ "creating a new subinterpreter, to be "
#~ "able to indicate that they would "
#~ "like some things \"inherited\" by the"
#~ " new interpreter.  The mechanism could "
#~ "be a strict copy or it could "
#~ "be copy-on-write.  The motivating "
#~ "example is with the warnings module "
#~ "(e.g. copy the filters)."
#~ msgstr ""

#~ msgid ""
#~ "Exceptions are propagated out of "
#~ "``run()`` calls, so it isn't a big"
#~ " leap to make them shareable in "
#~ "channels.  However, as noted elsewhere, "
#~ "it isn't essential or (particularly "
#~ "common) so we can wait on doing"
#~ " that."
#~ msgstr ""

#~ msgid ""
#~ "An uncaught exception in a "
#~ "subinterpreter (from ``run()``) is copied "
#~ "to the calling interpreter and set "
#~ "as ``__cause__`` on a ``RunFailedError`` "
#~ "which is then raised.  That copying "
#~ "part involves some sort of "
#~ "deserialization in the calling interpreter,"
#~ " which can be expensive (e.g. due "
#~ "to imports) yet is not always "
#~ "necessary."
#~ msgstr ""

#~ msgid "Serialize everything through channels"
#~ msgstr ""

#~ msgid ""
#~ "We could use pickle (or marshal) "
#~ "to serialize everything sent through "
#~ "channels.  Doing this is potentially "
#~ "inefficient, but it may be a "
#~ "matter of convenience in the end.  "
#~ "We can add it later, but trying"
#~ " to remove it later would be "
#~ "significantly more painful."
#~ msgstr ""

#~ msgid "Return a value from ``run()``"
#~ msgstr ""

#~ msgid ""
#~ "Currently ``run()`` always returns None.  "
#~ "One idea is to return the return"
#~ " value from whatever the subinterpreter "
#~ "ran.  However, for now it doesn't "
#~ "make sense.  The only thing folks "
#~ "can run is a string of code "
#~ "(i.e. a script).  This is equivalent "
#~ "to ``PyRun_StringFlags()``, ``exec()``, or a"
#~ " module body.  None of those "
#~ "\"return\" anything.  We can revisit "
#~ "this once ``run()`` supports functions, "
#~ "etc."
#~ msgstr ""

#~ msgid "Add a \"tp_share\" type slot"
#~ msgstr ""

#~ msgid "This would replace the current global registry for shareable types."
#~ msgstr ""

#~ msgid "Expose which interpreters have actually *used* a channel end."
#~ msgstr ""

#~ msgid ""
#~ "Currently we associate interpreters upon "
#~ "access to a channel.  We would "
#~ "keep a separate association list for "
#~ "\"upon use\" and expose that."
#~ msgstr ""

#~ msgid ""
#~ "This would be ``_threading.Lock`` (or "
#~ "something like it) where interpreters "
#~ "would actually share the underlying "
#~ "mutex.  This would provide much better"
#~ " efficiency than blocking channel ops.  "
#~ "The main concern is that locks and"
#~ " channels don't mix well (as learned"
#~ " in Go)."
#~ msgstr ""

#~ msgid ""
#~ "Note that the same functionality as "
#~ "a lock can be achieved by passing"
#~ " some sort of \"token\" object "
#~ "through a channel.  \"send()\" would be"
#~ " equivalent to releasing the lock and"
#~ " \"recv()\" to acquiring the lock."
#~ msgstr ""

#~ msgid ""
#~ "The exception types that inherit from"
#~ " ``BaseException`` (aside from ``Exception``) "
#~ "are usually treated specially.  These "
#~ "types are: ``KeyboardInterrupt``, ``SystemExit``,"
#~ " and ``GeneratorExit``.  It may make "
#~ "sense to treat them specially when "
#~ "it comes to propagation from ``run()``."
#~ "  Here are some options::"
#~ msgstr ""

#~ msgid ""
#~ "The PEP proposes a hard separation "
#~ "between subinterpreters and threads: if "
#~ "you want to run in a thread "
#~ "you must create the thread yourself "
#~ "and call ``run()`` in it.  However, "
#~ "it might be convenient if ``run()`` "
#~ "could do that for you, meaning "
#~ "there would be less boilerplate."
#~ msgstr ""

#~ msgid ""
#~ "Furthermore, we anticipate that users "
#~ "will want to run in a thread "
#~ "much more often than not.  So it"
#~ " would make sense to make this "
#~ "the default behavior.  We would add "
#~ "a kw-only param \"threaded\" (default"
#~ " ``True``) to ``run()`` to allow the"
#~ " run-in-the-current-thread operation."
#~ msgstr ""

#~ msgid "Use pipes instead of channels"
#~ msgstr ""

#~ msgid "Use queues instead of channels"
#~ msgstr ""

#~ msgid ""
#~ "In function calls, uncaught exceptions "
#~ "propagate to the calling frame. The "
#~ "same approach could be taken with "
#~ "``run()``.  However, this would mean "
#~ "that exception objects would leak across"
#~ " the inter-interpreter boundary.  Likewise,"
#~ " the frames in the traceback would"
#~ " potentially leak."
#~ msgstr ""

#~ msgid ""
#~ "return the exception (or its proxy) "
#~ "from ``run()`` instead of raising it"
#~ msgstr ""

#~ msgid ""
#~ "throw the exception away and expect "
#~ "users to deal with unhandled exceptions"
#~ " explicitly in the script they pass"
#~ " to ``run()`` (they can pass error"
#~ " info out via channels); with threads"
#~ " you have to do something similar"
#~ msgstr ""

#~ msgid ""
#~ "As implemented in the C-API, a "
#~ "subinterpreter is not inherently tied to"
#~ " any thread.  Furthermore, it will "
#~ "run in any existing thread, whether "
#~ "created by Python or not.  You "
#~ "only have to activate one of its"
#~ " thread states (``PyThreadState``) in the"
#~ " thread first.  This means that the"
#~ " same thread may run more than "
#~ "one interpreter (though obviously not at"
#~ " the same time)."
#~ msgstr ""

#~ msgid ""
#~ "The proposed module maintains this "
#~ "behavior.  Subinterpreters are not tied "
#~ "to threads.  Only calls to "
#~ "``Interpreter.run()`` are.  However, one of"
#~ " the key objectives of this PEP "
#~ "is to provide a more human- "
#~ "centric concurrency model.  With that in"
#~ " mind, from a conceptual standpoint "
#~ "the module *might* be easier to "
#~ "understand if each subinterpreter were "
#~ "associated with its own thread."
#~ msgstr ""

#~ msgid ""
#~ "That would mean ``interpreters.create()`` "
#~ "would create a new thread and "
#~ "``Interpreter.run()`` would only execute in"
#~ " that thread (and nothing else "
#~ "would).  The benefit is that users "
#~ "would not have to wrap "
#~ "``Interpreter.run()`` calls in a new "
#~ "``threading.Thread``.  Nor would they be "
#~ "in a position to accidentally pause "
#~ "the current interpreter (in the current"
#~ " thread) while their subinterpreter "
#~ "executes."
#~ msgstr ""

#~ msgid "additions to the (\"private\") C=API needed by the low-level module"
#~ msgstr ""

#~ msgid ""
#~ "the low-level module is mostly "
#~ "complete.  The bulk of the "
#~ "implementation was merged into master in"
#~ " December 2018 as the "
#~ "\"_xxsubinterpreters\" module (for the sake"
#~ " of testing subinterpreter functionality).  "
#~ "Only 3 parts of the implementation "
#~ "remain: \"send_wait()\", \"send_buffer()\", and "
#~ "exception propagation.  All three have "
#~ "been mostly finished, but were blocked"
#~ " by work related to ceval. That "
#~ "blocker is basically resolved now and"
#~ " finishing the low-level will not "
#~ "require extensive work."
#~ msgstr ""

#~ msgid "http://bugs.python.org/issue24554"
#~ msgstr ""

#~ msgid "https://bugs.python.org/issue6531"
#~ msgstr ""

