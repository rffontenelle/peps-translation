# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-14 02:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../peps/peps/pep-0578.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/peps/pep-0578.rst:3
msgid "Steve Dower <steve.dower@python.org>"
msgstr ""

#: ../../peps/peps/pep-0578.rst
msgid "BDFL-Delegate"
msgstr ""

#: ../../peps/peps/pep-0578.rst:4
msgid "Christian Heimes <christian@python.org>"
msgstr ""

#: ../../peps/peps/pep-0578.rst
msgid "Status"
msgstr "Status"

#: ../../peps/peps/pep-0578.rst:5
msgid "Final"
msgstr ""

#: ../../peps/peps/pep-0578.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/peps/pep-0578.rst:6
msgid "Standards Track"
msgstr ""

#: ../../peps/peps/pep-0578.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/peps/pep-0578.rst:7
msgid "16-Jun-2018"
msgstr ""

#: ../../peps/peps/pep-0578.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/peps/pep-0578.rst:8
msgid "3.8"
msgstr ""

#: ../../peps/peps/pep-0578.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/peps/pep-0578.rst:9
msgid "28-Mar-2019, 07-May-2019"
msgstr ""

#: ../../peps/peps/pep-0578.rst:14
msgid "Abstract"
msgstr ""

#: ../../peps/peps/pep-0578.rst:16
msgid ""
"This PEP describes additions to the Python API and specific behaviors for "
"the CPython implementation that make actions taken by the Python runtime "
"visible to auditing tools. Visibility into these actions provides "
"opportunities for test frameworks, logging frameworks, and security tools to "
"monitor and optionally limit actions taken by the runtime."
msgstr ""

#: ../../peps/peps/pep-0578.rst:23
msgid ""
"This PEP proposes adding two APIs to provide insights into a running Python "
"application: one for arbitrary events, and another specific to the module "
"import system. The APIs are intended to be available in all Python "
"implementations, though the specific messages and values used are "
"unspecified here to allow implementations the freedom to determine how best "
"to provide information to their users. Some examples likely to be used in "
"CPython are provided for explanatory purposes."
msgstr ""

#: ../../peps/peps/pep-0578.rst:31
msgid ""
"See :pep:`551` for discussion and recommendations on enhancing the security "
"of a Python runtime making use of these auditing APIs."
msgstr ""

#: ../../peps/peps/pep-0578.rst:35
msgid "Background"
msgstr ""

#: ../../peps/peps/pep-0578.rst:37
msgid ""
"Python provides access to a wide range of low-level functionality on many "
"common operating systems. While this is incredibly useful for \"write-once, "
"run-anywhere\" scripting, it also makes monitoring of software written in "
"Python difficult. Because Python uses native system APIs directly, existing "
"monitoring tools either suffer from limited context or auditing bypass."
msgstr ""

#: ../../peps/peps/pep-0578.rst:44
msgid ""
"Limited context occurs when system monitoring can report that an action "
"occurred, but cannot explain the sequence of events leading to it. For "
"example, network monitoring at the OS level may be able to report "
"\"listening started on port 5678\", but may not be able to provide the "
"process ID, command line, parent process, or the local state in the program "
"at the point that triggered the action. Firewall controls to prevent such an "
"action are similarly limited, typically to process names or some global "
"state such as the current user, and in any case rarely provide a useful log "
"file correlated with other application messages."
msgstr ""

#: ../../peps/peps/pep-0578.rst:55
msgid ""
"Auditing bypass can occur when the typical system tool used for an action "
"would ordinarily report its use, but accessing the APIs via Python do not "
"trigger this. For example, invoking \"curl\" to make HTTP requests may be "
"specifically monitored in an audited system, but Python's \"urlretrieve\" "
"function is not."
msgstr ""

#: ../../peps/peps/pep-0578.rst:61
msgid ""
"Within a long-running Python application, particularly one that processes "
"user-provided information such as a web app, there is a risk of unexpected "
"behavior. This may be due to bugs in the code, or deliberately induced by a "
"malicious user. In both cases, normal application logging may be bypassed "
"resulting in no indication that anything out of the ordinary has occurred."
msgstr ""

#: ../../peps/peps/pep-0578.rst:68
msgid ""
"Additionally, and somewhat unique to Python, it is very easy to affect the "
"code that is run in an application by manipulating either the import "
"system's search path or placing files earlier on the path than intended. "
"This is often seen when developers create a script with the same name as the "
"module they intend to use - for example, a ``random.py`` file that attempts "
"to import the standard library ``random`` module."
msgstr ""

#: ../../peps/peps/pep-0578.rst:76
msgid ""
"This is not sandboxing, as this proposal does not attempt to prevent "
"malicious behavior (though it enables some new options to do so). See the "
"`Why Not A Sandbox`_ section below for further discussion."
msgstr ""

#: ../../peps/peps/pep-0578.rst:81
msgid "Overview of Changes"
msgstr ""

#: ../../peps/peps/pep-0578.rst:83
msgid ""
"The aim of these changes is to enable both application developers and system "
"administrators to integrate Python into their existing monitoring systems "
"without dictating how those systems look or behave."
msgstr ""

#: ../../peps/peps/pep-0578.rst:87
msgid ""
"We propose two API changes to enable this: an Audit Hook and Verified Open "
"Hook. Both are available from Python and native code, allowing applications "
"and frameworks written in pure Python code to take advantage of the extra "
"messages, while also allowing embedders or system administrators to deploy "
"builds of Python where auditing is always enabled."
msgstr ""

#: ../../peps/peps/pep-0578.rst:94
msgid ""
"Only CPython is bound to provide the native APIs as described here. Other "
"implementations should provide the pure Python APIs, and may provide native "
"versions as appropriate for their underlying runtimes. Auditing events are "
"likewise considered implementation specific, but are bound by normal feature "
"compatibility guarantees."
msgstr ""

#: ../../peps/peps/pep-0578.rst:101
msgid "Audit Hook"
msgstr ""

#: ../../peps/peps/pep-0578.rst:103
msgid ""
"In order to observe actions taken by the runtime (on behalf of the caller), "
"an API is required to raise messages from within certain operations. These "
"operations are typically deep within the Python runtime or standard library, "
"such as dynamic code compilation, module imports, DNS resolution, or use of "
"certain modules such as ``ctypes``."
msgstr ""

#: ../../peps/peps/pep-0578.rst:109
msgid ""
"The following new C APIs allow embedders and CPython implementors to send "
"and receive audit hook messages::"
msgstr ""

#: ../../peps/peps/pep-0578.rst:120
msgid "The new Python APIs for receiving and raising audit hooks are::"
msgstr ""

#: ../../peps/peps/pep-0578.rst:129
msgid ""
"Hooks are added by calling ``PySys_AddAuditHook()`` from C at any time, "
"including before ``Py_Initialize()``, or by calling ``sys.addaudithook()`` "
"from Python code. Hooks cannot be removed or replaced. For CPython, hooks "
"added from C are global, while hooks added from Python are only for the "
"current interpreter. Global hooks are executed before interpreter hooks."
msgstr ""

#: ../../peps/peps/pep-0578.rst:136
msgid ""
"When events of interest are occurring, code can either call "
"``PySys_Audit()`` from C (while the GIL is held) or ``sys.audit()``. The "
"string argument is the name of the event, and the tuple contains arguments. "
"A given event name should have a fixed schema for arguments, which should be "
"considered a public API (for each x.y version release), and thus should only "
"change between feature releases with updated documentation. To minimize "
"overhead and simplify handling in native code hook implementations, named "
"arguments are not supported."
msgstr ""

#: ../../peps/peps/pep-0578.rst:145
msgid ""
"For maximum compatibility, events using the same name as an event in the "
"reference interpreter CPython should make every attempt to use compatible "
"arguments. Including the name or an abbreviation of the implementation in "
"implementation-specific event names will also help prevent collisions. For "
"example, a ``pypy.jit_invoked`` event is clearly distinguished from an ``ipy."
"jit_invoked`` event. Events raised from Python modules should include their "
"module or package name in the event name."
msgstr ""

#: ../../peps/peps/pep-0578.rst:154
msgid ""
"While event names may be arbitrary UTF-8 strings, for consistency across "
"implementations it is recommended to use valid Python dotted names and avoid "
"encoding specific details in the name. For example, an ``import`` event with "
"the module name ``spam`` as an argument is preferable to a ``spam module "
"imported`` event with no arguments. Avoid using embedded null characters or "
"you may upset those who implement hooks using C."
msgstr ""

#: ../../peps/peps/pep-0578.rst:161
msgid ""
"When an event is audited, each hook is called in the order it was added (as "
"much as is possible), passing the event name and arguments. If any hook "
"returns with an exception set, later hooks are ignored and *in general* the "
"Python runtime should terminate - exceptions from hooks are not intended to "
"be handled or treated as expected occurrences. This allows hook "
"implementations to decide how to respond to any particular event. The "
"typical responses will be to log the event, abort the operation with an "
"exception, or to immediately terminate the process with an operating system "
"exit call."
msgstr ""

#: ../../peps/peps/pep-0578.rst:171
msgid ""
"When an event is audited but no hooks have been set, the ``audit()`` "
"function should impose minimal overhead. Ideally, each argument is a "
"reference to existing data rather than a value calculated just for the "
"auditing call."
msgstr ""

#: ../../peps/peps/pep-0578.rst:176
msgid ""
"As hooks may be Python objects, they need to be freed during interpreter or "
"runtime finalization. These should not be triggered at any other time, and "
"should raise an event hook to ensure that any unexpected calls are observed."
msgstr ""

#: ../../peps/peps/pep-0578.rst:181
msgid ""
"Below in `Suggested Audit Hook Locations`_, we recommend some important "
"operations that should raise audit events. In general, events should be "
"raised at the lowest possible level. Given the choice between raising an "
"event from Python code or native code, raising from native code should be "
"preferred."
msgstr ""

#: ../../peps/peps/pep-0578.rst:187
msgid ""
"Python implementations should document which operations will raise audit "
"events, along with the event schema. It is intentional that ``sys."
"addaudithook(print)`` is a trivial way to display all messages."
msgstr ""

#: ../../peps/peps/pep-0578.rst:192
msgid "Verified Open Hook"
msgstr ""

#: ../../peps/peps/pep-0578.rst:194
msgid ""
"Most operating systems have a mechanism to distinguish between files that "
"can be executed and those that can not. For example, this may be an execute "
"bit in the permissions field, a verified hash of the file contents to detect "
"potential code tampering, or file system path restrictions. These are an "
"important security mechanism for ensuring that only code that has been "
"approved for a given environment is executed."
msgstr ""

#: ../../peps/peps/pep-0578.rst:202
msgid ""
"Most kernels offer ways to restrict or audit binaries loaded and executed by "
"the kernel. File types owned by Python appear as regular data and these "
"features do not apply. This open hook allows Python embedders to integrate "
"with operating system support when launching scripts or importing Python "
"code."
msgstr ""

#: ../../peps/peps/pep-0578.rst:208
msgid "The new public C API for the verified open hook is::"
msgstr ""

#: ../../peps/peps/pep-0578.rst:217
msgid "The new public Python API for the verified open hook is::"
msgstr ""

#: ../../peps/peps/pep-0578.rst:223
msgid ""
"The ``io.open_code()`` function is a drop-in replacement for "
"``open(abspath(str(pathlike)), 'rb')``. Its default behaviour is to open a "
"file for raw, binary access. To change the behaviour a new handler should be "
"set. Handler functions only accept ``str`` arguments. The C API "
"``PyFile_OpenCode`` function assumes UTF-8 encoding. Paths must be absolute, "
"and it is the responsibility of the caller to ensure the full path is "
"correctly resolved."
msgstr ""

#: ../../peps/peps/pep-0578.rst:231
msgid ""
"A custom handler may be set by calling ``PyFile_SetOpenCodeHook()`` from C "
"at any time, including before ``Py_Initialize()``. However, if a hook has "
"already been set then the call will fail. When ``open_code()`` is called "
"with a hook set, the hook will be passed the path and its return value will "
"be returned directly. The returned object should be an open file-like object "
"that supports reading raw bytes. This is explicitly intended to allow a "
"``BytesIO`` instance if the open handler has already read the entire file "
"into memory."
msgstr ""

#: ../../peps/peps/pep-0578.rst:240
msgid ""
"Note that these hooks can import and call the ``_io.open()`` function on "
"CPython without triggering themselves. They can also use ``_io.BytesIO`` to "
"return a compatible result using an in-memory buffer."
msgstr ""

#: ../../peps/peps/pep-0578.rst:244
msgid ""
"If the hook determines that the file should not be loaded, it should raise "
"an exception of its choice, as well as performing any other logging."
msgstr ""

#: ../../peps/peps/pep-0578.rst:248
msgid ""
"All import and execution functionality involving code from a file will be "
"changed to use ``open_code()`` unconditionally. It is important to note that "
"calls to ``compile()``, ``exec()`` and ``eval()`` do not go through this "
"function - an audit hook that includes the code from these calls is the best "
"opportunity to validate code that is read from the file. Given the current "
"decoupling between import and execution in Python, most imported code will "
"go through both ``open_code()`` and the log hook for ``compile``, and so "
"care should be taken to avoid repeating verification steps."
msgstr ""

#: ../../peps/peps/pep-0578.rst:258
msgid ""
"File accesses that are not intentionally planning to execute code are not "
"expected to use this function. This includes loading pickles, XML or YAML "
"files, where code execution is generally considered malicious rather than "
"intentional. These operations should provide their own auditing events, "
"preferably distinguishing between normal functionality (for example, "
"``Unpickler.load``) and code execution (``Unpickler.find_class``)."
msgstr ""

#: ../../peps/peps/pep-0578.rst:266
msgid ""
"A few examples: if the file type normally requires an execute bit (on POSIX) "
"or would warn when marked as having been downloaded from the internet (on "
"Windows), it should probably use ``open_code()`` rather than plain "
"``open()``. Opening ZIP files using the ``ZipFile`` class should use "
"``open()``, while opening them via ``zipimport`` should use ``open_code()`` "
"to signal the correct intent. Code that uses the wrong function for a "
"particular context may bypass the hook, which in CPython and the standard "
"library should be considered a bug. Using a combination of ``open_code`` "
"hooks and auditing hooks is necessary to trace all executed sources in the "
"presence of arbitrary code."
msgstr ""

#: ../../peps/peps/pep-0578.rst:277
msgid ""
"There is no Python API provided for changing the open hook. To modify import "
"behavior from Python code, use the existing functionality provided by "
"``importlib``."
msgstr ""

#: ../../peps/peps/pep-0578.rst:282
msgid "API Availability"
msgstr ""

#: ../../peps/peps/pep-0578.rst:284
msgid ""
"While all the functions added here are considered public and stable API, the "
"behavior of the functions is implementation specific. Most descriptions here "
"refer to the CPython implementation, and while other implementations should "
"provide the functions, there is no requirement that they behave the same."
msgstr ""

#: ../../peps/peps/pep-0578.rst:290
msgid ""
"For example, ``sys.addaudithook()`` and ``sys.audit()`` should exist but may "
"do nothing. This allows code to make calls to ``sys.audit()`` without having "
"to test for existence, but it should not assume that its call will have any "
"effect. (Including existence tests in security-critical code allows another "
"vector to bypass auditing, so it is preferable that the function always "
"exist.)"
msgstr ""

#: ../../peps/peps/pep-0578.rst:297
msgid ""
"``io.open_code(path)`` should at a minimum always return ``_io.open(path, "
"'rb')``. Code using the function should make no further assumptions about "
"what may occur, and implementations other than CPython are not required to "
"let developers override the behavior of this function with a hook."
msgstr ""

#: ../../peps/peps/pep-0578.rst:304
msgid "Suggested Audit Hook Locations"
msgstr ""

#: ../../peps/peps/pep-0578.rst:306
msgid ""
"The locations and parameters in calls to ``sys.audit()`` or "
"``PySys_Audit()`` are to be determined by individual Python implementations. "
"This is to allow maximum freedom for implementations to expose the "
"operations that are most relevant to their platform, and to avoid or ignore "
"potentially expensive or noisy events."
msgstr ""

#: ../../peps/peps/pep-0578.rst:312
msgid ""
"Table 1 acts as both suggestions of operations that should trigger audit "
"events on all implementations, and examples of event schemas."
msgstr ""

#: ../../peps/peps/pep-0578.rst:315
msgid ""
"Table 2 provides further examples that are not required, but are likely to "
"be available in CPython."
msgstr ""

#: ../../peps/peps/pep-0578.rst:318
msgid ""
"Refer to the documentation associated with your version of Python to see "
"which operations provide audit events."
msgstr ""

#: ../../peps/peps/pep-0578.rst:321
msgid "Table 1: Suggested Audit Hooks"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "API Function"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Event Name"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Arguments"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Rationale"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``PySys_AddAuditHook``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``sys.addaudithook``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Detect when new audit hooks are being added."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``PyFile_SetOpenCodeHook``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``cpython.PyFile_SetOpenCodeHook``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Detects any attempt to set the ``open_code`` hook."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"``compile``, ``exec``, ``eval``, ``PyAst_CompileString``, ``PyAST_obj2mod``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``compile``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(code, filename_or_none)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:2
msgid ""
"Detect dynamic code compilation, where ``code`` could be a string or AST. "
"Note that this will be called for regular imports of source code, including "
"those that were opened with ``open_code``."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``exec``, ``eval``, ``run_mod``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``exec``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(code_object,)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:2
msgid ""
"Detect dynamic execution of code objects. This only occurs for explicit "
"calls, and is not raised for normal function invocation."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``import``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(module, filename, sys.path, sys.meta_path, sys.path_hooks)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detect when modules are imported. This is raised before the module name is "
"resolved to a file. All arguments other than the module name may be ``None`` "
"if they are not used or available."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``open``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``io.open``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(path, mode, flags)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detect when a file is about to be opened. *path* and *mode* are the usual "
"parameters to ``open`` if available, while *flags* is provided instead of "
"*mode* in some cases."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``PyEval_SetProfile``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``sys.setprofile``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detect when code is injecting trace functions. Because of the "
"implementation, exceptions raised from the hook will abort the operation, "
"but will not be raised in Python code. Note that ``threading.setprofile`` "
"eventually calls this function, so the event will be audited for each thread."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``PyEval_SetTrace``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``sys.settrace``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detect when code is injecting trace functions. Because of the "
"implementation, exceptions raised from the hook will abort the operation, "
"but will not be raised in Python code. Note that ``threading.settrace`` "
"eventually calls this function, so the event will be audited for each thread."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"``_PyObject_GenericSetAttr``, ``check_set_special_type_attr``, "
"``object_set_class``, ``func_set_code``, ``func_set_[kw]defaults``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:2
msgid "``object.__setattr__``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(object, attr, value)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detect monkey patching of types and objects. This event is raised for the "
"``__class__`` attribute and any attribute on ``type`` objects."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``_PyObject_GenericSetAttr``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``object.__delattr__``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(object, attr)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detect deletion of object attributes. This event is raised for any attribute "
"on ``type`` objects."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``Unpickler.find_class``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``pickle.find_class``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(module_name, global_name)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Detect imports and global name lookup when unpickling."
msgstr ""

#: ../../peps/peps/pep-0578.rst:381
msgid "Table 2: Potential CPython Audit Hooks"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``_PySys_ClearAuditHooks``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``sys._clearaudithooks``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Notifies hooks they are being cleaned up, mainly in case the event is "
"triggered unexpectedly. This event cannot be aborted."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``code_new``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``code.__new__``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(bytecode, filename, name)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:2
msgid ""
"Detect dynamic creation of code objects. This only occurs for direct "
"instantiation, and is not raised for normal compilation."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``func_new_impl``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``function.__new__``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(code,)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detect dynamic creation of function objects. This only occurs for direct "
"instantiation, and is not raised for normal compilation."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``_ctypes.dlopen``, ``_ctypes.LoadLibrary``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``ctypes.dlopen``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:2
msgid "``(module_or_path,)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Detect when native modules are used."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``_ctypes._FuncPtr``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``ctypes.dlsym``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(lib_object, name)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:2
msgid ""
"Collect information about specific symbols retrieved from native modules."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``_ctypes._CData``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``ctypes.cdata``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(ptr_as_int,)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Detect when code is accessing arbitrary memory using ``ctypes``."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``new_mmap_object``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``mmap.__new__``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(fileno, map_size, access, offset)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detects creation of mmap objects. On POSIX, access may have been calculated "
"from the ``prot`` and ``flags`` arguments."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``sys._getframe``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(frame_object,)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Detect when code is accessing frames directly."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``sys._current_frames``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"``socket.bind``, ``socket.connect``, ``socket.connect_ex``, ``socket."
"getaddrinfo``, ``socket.getnameinfo``, ``socket.sendmsg``, ``socket.sendto``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``socket.address``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(socket, address,)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:2
msgid ""
"Detect access to network resources. The address is unmodified from the "
"original call."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``member_get``, ``func_get_code``, ``func_get_[kw]defaults``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``object.__getattr__``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid ""
"Detect access to restricted attributes. This event is raised for any built-"
"in members that are marked as restricted, and members that may allow "
"bypassing imports."
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``urllib.urlopen``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``urllib.Request``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "``(url, data, headers, method)``"
msgstr ""

#: ../../peps/peps/pep-0578.rst:1
msgid "Detects URL requests."
msgstr ""

#: ../../peps/peps/pep-0578.rst:434
msgid "Performance Impact"
msgstr ""

#: ../../peps/peps/pep-0578.rst:436
msgid ""
"The important performance impact is the case where events are being raised "
"but there are no hooks attached. This is the unavoidable case - once a "
"developer has added audit hooks they have explicitly chosen to trade "
"performance for functionality. Performance impact with hooks added are not "
"of interest here, since this is opt-in functionality."
msgstr ""

#: ../../peps/peps/pep-0578.rst:442
msgid ""
"Analysis using the Python Performance Benchmark Suite [1]_ shows no "
"significant impact, with the vast majority of benchmarks showing between "
"1.05x faster to 1.05x slower."
msgstr ""

#: ../../peps/peps/pep-0578.rst:446
msgid ""
"In our opinion, the performance impact of the set of auditing points "
"described in this PEP is negligible."
msgstr ""

#: ../../peps/peps/pep-0578.rst:450
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/peps/pep-0578.rst:453
msgid "Separate module for audit hooks"
msgstr ""

#: ../../peps/peps/pep-0578.rst:455
msgid ""
"The proposal is to add a new module for audit hooks, hypothetically "
"``audit``. This would separate the API and implementation from the ``sys`` "
"module, and allow naming the C functions ``PyAudit_AddHook`` and "
"``PyAudit_Audit`` rather than the current variations."
msgstr ""

#: ../../peps/peps/pep-0578.rst:460
msgid ""
"Any such module would need to be a built-in module that is guaranteed to "
"always be present. The nature of these hooks is that they must be callable "
"without condition, as any conditional imports or calls provide opportunities "
"to intercept and suppress or modify events."
msgstr ""

#: ../../peps/peps/pep-0578.rst:465
msgid ""
"Given it is one of the most core modules, the ``sys`` module is somewhat "
"protected against module shadowing attacks. Replacing ``sys`` with a "
"sufficiently functional module that the application can still run is a much "
"more complicated task than replacing a module with only one function of "
"interest. An attacker that has the ability to shadow the ``sys`` module is "
"already capable of running arbitrary code from files, whereas an ``audit`` "
"module could be replaced with a single line in a ``.pth`` file anywhere on "
"the search path::"
msgstr ""

#: ../../peps/peps/pep-0578.rst:477
msgid ""
"Multiple layers of protection already exist for monkey patching attacks "
"against either ``sys`` or ``audit``, but assignments or insertions to ``sys."
"modules`` are not audited."
msgstr ""

#: ../../peps/peps/pep-0578.rst:481
msgid ""
"This idea is rejected because it makes it trivial to suppress all calls to "
"``audit``."
msgstr ""

#: ../../peps/peps/pep-0578.rst:485
msgid "Flag in sys.flags to indicate \"audited\" mode"
msgstr ""

#: ../../peps/peps/pep-0578.rst:487
msgid ""
"The proposal is to add a value in ``sys.flags`` to indicate when Python is "
"running in a \"secure\" or \"audited\" mode. This would allow applications "
"to detect when some features are enabled or when hooks have been added and "
"modify their behaviour appropriately."
msgstr ""

#: ../../peps/peps/pep-0578.rst:492
msgid ""
"Currently, we are not aware of any legitimate reasons for a program to "
"behave differently in the presence of audit hooks."
msgstr ""

#: ../../peps/peps/pep-0578.rst:495
msgid ""
"Both application-level APIs ``sys.audit`` and ``io.open_code`` are always "
"present and functional, regardless of whether the regular ``python`` entry "
"point or some alternative entry point is used. Callers cannot determine "
"whether any hooks have been added (except by performing side-channel "
"analysis), nor do they need to. The calls should be fast enough that callers "
"do not need to avoid them, and the program is responsible for ensuring that "
"any added hooks are fast enough to not affect application performance."
msgstr ""

#: ../../peps/peps/pep-0578.rst:504
msgid ""
"The argument that this is \"security by obscurity\" is valid, but "
"irrelevant. Security by obscurity is only an issue when there are no other "
"protective mechanisms; obscurity as the first step in avoiding attack is "
"strongly recommended (see `this article <https://danielmiessler.com/p/"
"security-by-obscurity/>`_ for discussion)."
msgstr ""

#: ../../peps/peps/pep-0578.rst:511
msgid ""
"This idea is rejected because there are no appropriate reasons for an "
"application to change its behaviour based on whether these APIs are in use."
msgstr ""

#: ../../peps/peps/pep-0578.rst:516
msgid "Why Not A Sandbox"
msgstr ""

#: ../../peps/peps/pep-0578.rst:518
msgid ""
"Sandboxing CPython has been attempted many times in the past, and each past "
"attempt has failed. Fundamentally, the problem is that certain functionality "
"has to be restricted when executing the sandboxed code, but otherwise needs "
"to be available for normal operation of Python. For example, completely "
"removing the ability to compile strings into bytecode also breaks the "
"ability to import modules from source code, and if it is not completely "
"removed then there are too many ways to get access to that functionality "
"indirectly. There is not yet any feasible way to generically determine "
"whether a given operation is \"safe\" or not. Further information and "
"references available at [2]_."
msgstr ""

#: ../../peps/peps/pep-0578.rst:529
msgid ""
"This proposal does not attempt to restrict functionality, but simply exposes "
"the fact that the functionality is being used. Particularly for intrusion "
"scenarios, detection is significantly more important than early prevention "
"(as early prevention will generally drive attackers to use an alternate, "
"less-detectable, approach). The availability of audit hooks alone does not "
"change the attack surface of Python in any way, but they enable defenders to "
"integrate Python into their environment in ways that are currently not "
"possible."
msgstr ""

#: ../../peps/peps/pep-0578.rst:538
msgid ""
"Since audit hooks have the ability to safely prevent an operation occurring, "
"this feature does enable the ability to provide some level of sandboxing. In "
"most cases, however, the intention is to enable logging rather than creating "
"a sandbox."
msgstr ""

#: ../../peps/peps/pep-0578.rst:544
msgid "Relationship to PEP 551"
msgstr ""

#: ../../peps/peps/pep-0578.rst:546
msgid ""
"This API was originally presented as part of :pep:`551` Security "
"Transparency in the Python Runtime."
msgstr ""

#: ../../peps/peps/pep-0578.rst:550
msgid ""
"For simpler review purposes, and due to the broader applicability of these "
"APIs beyond security, the API design is now presented separately."
msgstr ""

#: ../../peps/peps/pep-0578.rst:553
msgid ""
":pep:`551` is an informational PEP discussing how to integrate Python into a "
"secure or audited environment."
msgstr ""

#: ../../peps/peps/pep-0578.rst:557
msgid "References"
msgstr "Referências"

#: ../../peps/peps/pep-0578.rst:559
msgid ""
"Python Performance Benchmark Suite `<https://github.com/python/"
"pyperformance>`_"
msgstr ""

#: ../../peps/peps/pep-0578.rst:561
msgid ""
"Python Security model - Sandbox `<https://python-security.readthedocs.io/"
"security.html#sandbox>`_"
msgstr ""

#: ../../peps/peps/pep-0578.rst:564
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/peps/pep-0578.rst:566
msgid ""
"Copyright (c) 2019 by Microsoft Corporation. This material may be "
"distributed only subject to the terms and conditions set forth in the Open "
"Publication License, v1.0 or later (the latest version is presently "
"available at https://spdx.org/licenses/OPUBL-1.0.html)."
msgstr ""
