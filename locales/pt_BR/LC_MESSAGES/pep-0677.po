# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0677.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-0677.rst:3
msgid ""
"Steven Troxler <steven.troxler@gmail.com>, Pradeep Kumar Srinivasan "
"<gohanpra@gmail.com>"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Sponsor"
msgstr ""

#: ../../peps/pep-0677.rst:5
msgid "Guido van Rossum <guido at python.org>"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/pep-0677.rst:6
msgid "python-dev@python.org"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-0677.rst:7
msgid "Rejected"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-0677.rst:8
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Topic"
msgstr ""

#: ../../peps/pep-0677.rst:9
msgid "Typing"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-0677.rst:11
msgid "13-Dec-2021"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0677.rst:12
msgid "3.11"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-0677.rst:13
msgid "16-Dec-2021"
msgstr ""

#: ../../peps/pep-0677.rst
msgid "Resolution"
msgstr ""

#: ../../peps/pep-0677.rst:14
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/message/NHCLHCU2XCWTBGF732WESMN42YYVKOXB/"
msgstr ""

#: ../../peps/pep-0677.rst:17
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0677.rst:19
msgid ""
"This PEP introduces a concise and friendly syntax for callable types, "
"supporting the same functionality as ``typing.Callable`` but with an "
"arrow syntax inspired by the syntax for typed function signatures. This "
"allows types like ``Callable[[int, str], bool]`` to be written as ``(int,"
" str) -> bool``."
msgstr ""

#: ../../peps/pep-0677.rst:25
msgid ""
"The proposed syntax supports all the functionality provided by "
"``typing.Callable`` and ``typing.Concatenate``, and is intended to work "
"as a drop-in replacement."
msgstr ""

#: ../../peps/pep-0677.rst:31
msgid "Motivation"
msgstr ""

#: ../../peps/pep-0677.rst:33
msgid ""
"One way to make code safer and easier to analyze is by making sure that "
"functions and classes are well-typed.  In Python we have type "
"annotations, the framework for which is defined in :pep:`484`, to provide"
" type hints that can find bugs as well as helping with editor tooling "
"like tab completion, static analysis tooling, and code review."
msgstr ""

#: ../../peps/pep-0677.rst:39
msgid "Consider the following untyped code::"
msgstr ""

#: ../../peps/pep-0677.rst:58
msgid "We can add types to this example to detect the runtime error::"
msgstr ""

#: ../../peps/pep-0677.rst:74
msgid "There are a few usability challenges with ``Callable`` we can see here:"
msgstr ""

#: ../../peps/pep-0677.rst:76
msgid "It is verbose, particularly for more complex function signatures."
msgstr ""

#: ../../peps/pep-0677.rst:77
msgid ""
"It relies on two levels of nested brackets, unlike any other generic "
"type. This can be especially hard to read when some of the type "
"parameters are themselves generic types."
msgstr ""

#: ../../peps/pep-0677.rst:80
msgid ""
"The bracket structure is not visually similar to how function signatures "
"are written."
msgstr ""

#: ../../peps/pep-0677.rst:82
msgid ""
"It requires an explicit import, unlike many of the other most common "
"types like ``list`` and ``dict``."
msgstr ""

#: ../../peps/pep-0677.rst:85
msgid ""
"Possibly as a result, `programmers often fail to write complete Callable "
"types <https://github.com/pradeep90/annotation_collector#typed-projects"
"---callable-type>`_. Such untyped or partially-typed callable types do "
"not check the parameter types or return types of the given callable and "
"thus negate the benefits of static typing. For example, they might write "
"this::"
msgstr ""

#: ../../peps/pep-0677.rst:106
msgid ""
"There's some partial type information here - we at least know that "
"``func`` needs to be callable. But we've dropped too much type "
"information for type checkers to find the bug."
msgstr ""

#: ../../peps/pep-0677.rst:110
msgid "With our proposal, the example looks like this::"
msgstr ""

#: ../../peps/pep-0677.rst:123
msgid ""
"The type ``(int) -> list[int]`` is more concise, uses an arrow similar to"
" the one indicating a return type in a function header, avoids nested "
"brackets, and does not require an import."
msgstr ""

#: ../../peps/pep-0677.rst:129
msgid "Rationale"
msgstr ""

#: ../../peps/pep-0677.rst:131
msgid ""
"The ``Callable`` type is widely used. For example, `as of October 2021 it"
" was <https://github.com/pradeep90/annotation_collector#overall-stats-in-"
"typeshed>`_ the fifth most common complex type in typeshed, after "
"``Optional``, ``Tuple``, ``Union``, and ``List``."
msgstr ""

#: ../../peps/pep-0677.rst:137
msgid ""
"The others have had their syntax improved and the need for imports "
"eliminated by either :pep:`604` or :pep:`585`:"
msgstr ""

#: ../../peps/pep-0677.rst:140
msgid "``typing.Optional[int]`` is written ``int | None``"
msgstr ""

#: ../../peps/pep-0677.rst:141
msgid "``typing.Union[int, str]`` is written ``int | str``"
msgstr ""

#: ../../peps/pep-0677.rst:142
msgid "``typing.List[int]`` is written ``list[int]``"
msgstr ""

#: ../../peps/pep-0677.rst:143
msgid "``typing.Tuple[int, str]`` is written ``tuple[int, str]``"
msgstr ""

#: ../../peps/pep-0677.rst:145
msgid ""
"The ``typing.Callable`` type is used almost as often as these other "
"types, is more complicated to read and write, and still requires an "
"import and bracket-based syntax."
msgstr ""

#: ../../peps/pep-0677.rst:149
msgid ""
"In this proposal, we chose to support all the existing semantics of "
"``typing.Callable``, without adding support for new features. We made "
"this decision after examining how frequently each feature might be used "
"in existing typed and untyped open-source code. We determined that the "
"vast majority of use cases are covered."
msgstr ""

#: ../../peps/pep-0677.rst:155
msgid ""
"We considered adding support for named, optional, and variadic arguments."
" However, we decided against including these features, as our analysis "
"showed they are infrequently used. When they are really needed, it is "
"possible to type these using `callback protocols "
"<https://mypy.readthedocs.io/en/stable/protocols.html#callback-"
"protocols>`_."
msgstr ""

#: ../../peps/pep-0677.rst:162
msgid "An Arrow Syntax for Callable Types"
msgstr ""

#: ../../peps/pep-0677.rst:164
msgid ""
"We are proposing a succinct, easy-to-use syntax for ``typing.Callable`` "
"that looks similar to function headers in Python. Our proposal closely "
"follows syntax used by several popular languages such as `Typescript "
"<https://basarat.gitbook.io/typescript/type-system/callable#arrow-"
"syntax>`_, `Kotlin <https://kotlinlang.org/docs/lambdas.html>`_, and "
"`Scala <https://docs.scala-lang.org/tour/higher-order-functions.html>`_."
msgstr ""

#: ../../peps/pep-0677.rst:172
msgid "Our goals are that:"
msgstr ""

#: ../../peps/pep-0677.rst:174
msgid ""
"Callable types using this syntax will be easier to learn and use, "
"particularly for developers with experience in other languages."
msgstr ""

#: ../../peps/pep-0677.rst:176
msgid ""
"Library authors will be more likely to use expressive types for callables"
" that enable type checkers to better understand code and find bugs, as in"
" the ``decorator`` example above."
msgstr ""

#: ../../peps/pep-0677.rst:180
msgid ""
"Consider this simplified real-world example from a web server, written "
"using the existing ``typing.Callable``::"
msgstr ""

#: ../../peps/pep-0677.rst:193
msgid "With our proposal, this code can be abbreviated to::"
msgstr ""

#: ../../peps/pep-0677.rst:203
msgid ""
"This is shorter and requires fewer imports. It also has far less nesting "
"of square brackets - only one level, as opposed to three in the original "
"code."
msgstr ""

#: ../../peps/pep-0677.rst:208
msgid "Compact Syntax for ``ParamSpec``"
msgstr ""

#: ../../peps/pep-0677.rst:210
msgid ""
"A particularly common case where library authors leave off type "
"information for callables is when defining decorators. Consider the "
"following::"
msgstr ""

#: ../../peps/pep-0677.rst:233
msgid ""
"In the code above, it is clear that the decorator should produce a "
"function whose signature is like that of the argument ``f`` other than an"
" additional ``retry_once`` argument. But the use of ``...`` prevents a "
"type checker from seeing this and alerting a user that ``f(y=10)`` is "
"invalid."
msgstr ""

#: ../../peps/pep-0677.rst:240
msgid ""
"With :pep:`612` it is possible to type decorators like this correctly as "
"follows::"
msgstr ""

#: ../../peps/pep-0677.rst:258
msgid ""
"With our proposed syntax, the properly-typed decorator example becomes "
"concise and the type representations are visually descriptive::"
msgstr ""

#: ../../peps/pep-0677.rst:272
msgid "Comparing to Other Languages"
msgstr ""

#: ../../peps/pep-0677.rst:274
msgid ""
"Many popular programming languages use an arrow syntax similar to the one"
" we are proposing here."
msgstr ""

#: ../../peps/pep-0677.rst:278
msgid "TypeScript"
msgstr ""

#: ../../peps/pep-0677.rst:280
msgid ""
"In `TypeScript <https://basarat.gitbook.io/typescript/type-"
"system/callable#arrow-syntax>`_, function types are expressed in a syntax"
" almost the same as the one we are proposing, but the arrow token is "
"``=>`` and arguments have names::"
msgstr ""

#: ../../peps/pep-0677.rst:287
msgid ""
"The names of the arguments are not actually relevant to the type. So, for"
" example, this is the same callable type::"
msgstr ""

#: ../../peps/pep-0677.rst:293
msgid "Kotlin"
msgstr ""

#: ../../peps/pep-0677.rst:295
msgid ""
"Function types in `Kotlin <https://kotlinlang.org/docs/lambdas.html>`_ "
"permit an identical syntax to the one we are proposing, for example::"
msgstr ""

#: ../../peps/pep-0677.rst:300
msgid "It also optionally allows adding names to the arguments, for example::"
msgstr ""

#: ../../peps/pep-0677.rst:304
msgid ""
"As in TypeScript, the argument names (if provided) are just there for "
"documentation and are not part of the type itself."
msgstr ""

#: ../../peps/pep-0677.rst:308
msgid "Scala"
msgstr ""

#: ../../peps/pep-0677.rst:310
msgid ""
"`Scala <https://docs.scala-lang.org/tour/higher-order-functions.html>`_ "
"uses the ``=>`` arrow for function types. Other than that, their syntax "
"is the same as the one we are proposing, for example::"
msgstr ""

#: ../../peps/pep-0677.rst:316
msgid ""
"Scala, like Python, has the ability to provide function arguments by "
"name. Function types can optionally include names, for example::"
msgstr ""

#: ../../peps/pep-0677.rst:321
msgid ""
"Unlike in TypeScript and Kotlin, these names are part of the type if "
"provided - any function implementing the type must use the same names. "
"This is similar to the extended syntax proposal we describe in our "
"`Rejected Alternatives`_ section."
msgstr ""

#: ../../peps/pep-0677.rst:327
msgid "Function Definitions vs Callable Type Annotations"
msgstr ""

#: ../../peps/pep-0677.rst:329
msgid ""
"In all of the languages listed above, type annotations for function "
"definitions use a ``:`` rather than a ``->``. For example, in TypeScript "
"a simple add function looks like this::"
msgstr ""

#: ../../peps/pep-0677.rst:337
msgid ""
"Scala and Kotlin use essentially the same ``:`` syntax for return "
"annotations.  The ``:`` makes sense in these languages because they all "
"use ``:`` for type annotations of parameters and variables, and the use "
"for function return types is similar."
msgstr ""

#: ../../peps/pep-0677.rst:343
msgid ""
"In Python we use ``:`` to denote the start of a function body and ``->`` "
"for return annotations. As a result, even though our proposal is "
"superficially the same as these other languages the context is different."
" There is potential for more confusion in Python when reading function "
"definitions that include callable types."
msgstr ""

#: ../../peps/pep-0677.rst:349
msgid ""
"This is a key concern for which we are seeking feedback with our draft "
"PEP; one idea we have floated is to use ``=>`` instead to make it easier "
"to differentiate."
msgstr ""

#: ../../peps/pep-0677.rst:355
msgid "The ML Language Family"
msgstr ""

#: ../../peps/pep-0677.rst:357
msgid ""
"Languages in the ML family, including `F# <https://docs.microsoft.com/en-"
"us/dotnet/fsharp/language-reference/fsharp-types#syntax-for-types>`_, "
"`OCaml "
"<https://www2.ocaml.org/learn/tutorials/basics.html#Defining-a-function>`_,"
" and `Haskell <https://wiki.haskell.org/Type_signature>`_, all use ``->``"
" to represent function types. All of them use a parentheses-free syntax "
"with multiple arrows, for example in Haskell::"
msgstr ""

#: ../../peps/pep-0677.rst:367
msgid ""
"The use of multiple arrows, which differs from our proposal, makes sense "
"for languages in this family because they use automatic `currying "
"<https://en.wikipedia.org/wiki/Currying>`_ of function arguments, which "
"means that a multi-argument function behaves like a single-argument "
"function returning a function."
msgstr ""

#: ../../peps/pep-0677.rst:374
msgid "Specification"
msgstr ""

#: ../../peps/pep-0677.rst:377
msgid "Typing Behavior"
msgstr ""

#: ../../peps/pep-0677.rst:379
msgid ""
"Type checkers should treat the new syntax with exactly the same semantics"
" as ``typing.Callable``."
msgstr ""

#: ../../peps/pep-0677.rst:382
msgid ""
"As such, a type checker should treat the following pairs exactly the "
"same::"
msgstr ""

#: ../../peps/pep-0677.rst:416
msgid "Grammar and AST"
msgstr ""

#: ../../peps/pep-0677.rst:418
msgid ""
"The proposed new syntax can be described by these AST changes to "
"`Parser/Python.asdl "
"<https://github.com/python/cpython/blob/main/Parser/Python.asdl>`_::"
msgstr ""

#: ../../peps/pep-0677.rst:430
msgid ""
"Here are our proposed changes to the `Python Grammar "
"<https://docs.python.org/3/reference/grammar.htm>`::"
msgstr ""

#: ../../peps/pep-0677.rst:458
msgid ""
"If :pep:`646` is accepted, we intend to include support for unpacked "
"types in two ways. To support the \"star-for-unpack\" syntax proposed in "
":pep:`646`, we will modify the grammar for "
"``callable_type_positional_argument`` as follows::"
msgstr ""

#: ../../peps/pep-0677.rst:469
msgid ""
"With this change, a type of the form ``(int, *Ts) -> bool`` should "
"evaluate the AST form::"
msgstr ""

#: ../../peps/pep-0677.rst:477
msgid ""
"and be treated by type checkers as equivalent to or ``Callable[[int, "
"*Ts], bool]`` or ``Callable[[int, Unpack[Ts]], bool]``."
msgstr ""

#: ../../peps/pep-0677.rst:482
msgid "Implications of the Grammar"
msgstr ""

#: ../../peps/pep-0677.rst:485
msgid "Precedence of ->"
msgstr ""

#: ../../peps/pep-0677.rst:488
msgid ""
"``->`` binds less tightly than other operators, both inside types and in "
"function signatures, so the following two callable types are equivalent::"
msgstr ""

#: ../../peps/pep-0677.rst:496
msgid ""
"``->`` associates to the right, both inside types and in function "
"signatures. So the following pairs are equivalent::"
msgstr ""

#: ../../peps/pep-0677.rst:509
msgid ""
"Because operators bind more tightly than ``->``, parentheses are required"
" whenever an arrow type is intended to be inside an argument to an "
"operator like ``|``::"
msgstr ""

#: ../../peps/pep-0677.rst:517
msgid "We discussed each of these behaviors and believe they are desirable:"
msgstr ""

#: ../../peps/pep-0677.rst:519
msgid ""
"Union types (represented by ``A | B`` according to :pep:`604`) are valid "
"in function signature returns, so we need to allow operators in the "
"return position for consistency."
msgstr ""

#: ../../peps/pep-0677.rst:522
msgid ""
"Given that operators bind more tightly than ``->`` it is correct that a "
"type like ``bool | () -> bool`` must be a syntax error. We should be sure"
" the error message is clear because this may be a common mistake."
msgstr ""

#: ../../peps/pep-0677.rst:526
msgid ""
"Associating ``->`` to the right, rather than requiring explicit "
"parentheses, is consistent with other languages like TypeScript and "
"respects the principle that valid expressions should normally be "
"substitutable when possible."
msgstr ""

#: ../../peps/pep-0677.rst:532
msgid "``async`` Keyword"
msgstr ""

#: ../../peps/pep-0677.rst:534
msgid "All of the binding rules still work for async callable types::"
msgstr ""

#: ../../peps/pep-0677.rst:547
msgid "Trailing Commas"
msgstr ""

#: ../../peps/pep-0677.rst:549
msgid ""
"Following the precedent of function signatures, putting a comma in an "
"empty arguments list is illegal: ``(,) -> bool`` is a syntax error."
msgstr ""

#: ../../peps/pep-0677.rst:552
msgid ""
"Again following precedent, trailing commas are otherwise always "
"permitted::"
msgstr ""

#: ../../peps/pep-0677.rst:560
msgid ""
"Allowing trailing commas also gives autoformatters more flexibility when "
"splitting callable types across lines, which is always legal following "
"standard python whitespace rules."
msgstr ""

#: ../../peps/pep-0677.rst:566
msgid "Disallowing ``...`` as an Argument Type"
msgstr ""

#: ../../peps/pep-0677.rst:568
msgid ""
"Under normal circumstances, any valid expression is permitted where we "
"want a type annotation and ``...`` is a valid expression. This is never "
"semantically valid and all type checkers would reject it, but the grammar"
" would allow it if we did not explicitly prevent this."
msgstr ""

#: ../../peps/pep-0677.rst:573
msgid ""
"Since ``...`` is meaningless as a type and there are usability concerns, "
"our grammar rules it out and the following is a syntax error::"
msgstr ""

#: ../../peps/pep-0677.rst:579
msgid "We decided that there were compelling reasons to do this:"
msgstr ""

#: ../../peps/pep-0677.rst:581
msgid ""
"The semantics of ``(...) -> bool`` are different from ``(T) -> bool`` for"
" any valid type T: ``(...)`` is a special form indicating "
"``AnyArguments`` whereas ``T`` is a type parameter in the arguments list."
msgstr ""

#: ../../peps/pep-0677.rst:585
msgid ""
"``...`` is used as a placeholder default value to indicate an optional "
"argument in stubs and callback protocols. Allowing it in the position of "
"a type could easily lead to confusion and possibly bugs due to typos."
msgstr ""

#: ../../peps/pep-0677.rst:589
msgid ""
"In the ``tuple`` generic type, we special-case ``...`` to mean \"more of "
"the same\", e.g. a ``tuple[int, ...]`` means a tuple with one or more "
"integers. We do not use ``...`` in a a similar way in callable types, so "
"to prevent misunderstandings it makes sense to prevent this."
msgstr ""

#: ../../peps/pep-0677.rst:598
msgid "Incompatibility with other possible uses of ``*`` and ``**``"
msgstr ""

#: ../../peps/pep-0677.rst:600
msgid ""
"The use of ``**P`` for supporting :pep:`612` ``ParamSpec`` rules out any "
"future proposal using a bare ``**<some_type>`` to type ``kwargs``. This "
"seems acceptable because:"
msgstr ""

#: ../../peps/pep-0677.rst:604
msgid ""
"If we ever do want such a syntax, it would be clearer to require an "
"argument name anyway. This would also make the type look more similar to "
"a function signature. In other words, if we ever support typing "
"``kwargs`` in callable types, we would prefer ``(int, **kwargs: str)`` "
"rather than ``(int, **str)``."
msgstr ""

#: ../../peps/pep-0677.rst:609
msgid ""
":pep:`646` unpacking syntax would rule out using ``*<some_type>`` for "
"``args``. The ``kwargs`` case is similar enough that this rules out a "
"bare ``**<some_type>`` anyway."
msgstr ""

#: ../../peps/pep-0677.rst:616
msgid "Compatibility with Arrow-Based Lambda Syntax"
msgstr ""

#: ../../peps/pep-0677.rst:618
msgid ""
"To the best of our knowledge there is no active discussion of arrow-style"
" lambda syntax that we are aware of, but it is nonetheless worth "
"considering what possibilities would be ruled out by adopting this "
"proposal."
msgstr ""

#: ../../peps/pep-0677.rst:623
msgid ""
"It would be incompatible with this proposal to adopt the same a "
"parenthesized ``->``-based arrow syntax for lambdas, e.g.  ``(x, y) -> x "
"+ y`` for ``lambda x, y: x + y``."
msgstr ""

#: ../../peps/pep-0677.rst:628
msgid ""
"Our view is that if we want arrow syntax for lambdas in the future, it "
"would be a better choice to use ``=>``, e.g. ``(x, y) => x + y``. Many "
"languages use the same arrow token for both lambdas and callable types, "
"but Python is unique in that types are expressions and have to evaluate "
"to runtime values. Our view is that this merits using separate tokens, "
"and given the existing use of ``->`` for return types in function "
"signatures it would be more coherent to use ``->`` for callable types and"
" ``=>`` for lambdas."
msgstr ""

#: ../../peps/pep-0677.rst:638
msgid "Runtime Behavior"
msgstr ""

#: ../../peps/pep-0677.rst:640
msgid ""
"The new AST nodes need to evaluate to runtime types, and we have two "
"goals for the behavior of these runtime types:"
msgstr ""

#: ../../peps/pep-0677.rst:643
msgid ""
"They should expose a structured API that is descriptive and powerful "
"enough to be compatible with extending the type to include new features "
"like named and variadic arguments."
msgstr ""

#: ../../peps/pep-0677.rst:646
msgid ""
"They should also expose an API that is backward-compatible with "
"``typing.Callable``."
msgstr ""

#: ../../peps/pep-0677.rst:650
msgid "Evaluation and Structured API"
msgstr ""

#: ../../peps/pep-0677.rst:652
msgid ""
"We intend to create new builtin types to which the new AST nodes will "
"evaluate, exposing them in the ``types`` module."
msgstr ""

#: ../../peps/pep-0677.rst:655
msgid ""
"Our plan is to expose a structured API as if they were defined as "
"follows::"
msgstr ""

#: ../../peps/pep-0677.rst:672
msgid "The evaluation rules are expressed in terms of the following pseudocode::"
msgstr ""

#: ../../peps/pep-0677.rst:708
msgid "Backward-Compatible API"
msgstr ""

#: ../../peps/pep-0677.rst:710
msgid ""
"To get backward compatibility with the existing ``types.Callable`` API, "
"which relies on fields ``__args__`` and ``__parameters__``, we can define"
" them as if they were written in terms of the following::"
msgstr ""

#: ../../peps/pep-0677.rst:744
msgid "Additional Behaviors of ``types.CallableType``"
msgstr ""

#: ../../peps/pep-0677.rst:746
msgid "As with the ``A | B`` syntax for unions introduced in :pep:`604`:"
msgstr ""

#: ../../peps/pep-0677.rst:748
msgid ""
"The ``__eq__`` method should treat equivalent ``typing.Callable`` values "
"as equal to values constructed using the builtin syntax, and otherwise "
"should behave like the ``__eq__`` of ``typing.Callable``."
msgstr ""

#: ../../peps/pep-0677.rst:751
msgid ""
"The ``__repr__`` method should produce an arrow syntax representation "
"that, when evaluated, gives us back an equal ``types.CallableType`` "
"instance."
msgstr ""

#: ../../peps/pep-0677.rst:756
msgid "Rejected Alternatives"
msgstr ""

#: ../../peps/pep-0677.rst:758
msgid ""
"Many of the alternatives we considered would have been more expressive "
"than ``typing.Callable``, for example adding support for describing "
"signatures that include named, optional, and variadic arguments."
msgstr ""

#: ../../peps/pep-0677.rst:762
msgid ""
"To determine which features we most needed to support with a callable "
"type syntax, we did an extensive analysis of existing projects:"
msgstr ""

#: ../../peps/pep-0677.rst:765
msgid ""
"`stats on the use of the Callable type "
"<https://github.com/pradeep90/annotation_collector#typed-projects"
"---callable-type>`_;"
msgstr ""

#: ../../peps/pep-0677.rst:766
msgid ""
"`stats on how untyped and partially-typed callbacks are actually used "
"<https://github.com/pradeep90/annotation_collector#typed-projects"
"---callback-usage>`_."
msgstr ""

#: ../../peps/pep-0677.rst:768
msgid ""
"We decided on a simple proposal with improved syntax for the existing "
"``Callable`` type because the vast majority of callbacks can be correctly"
" described by the existing ``typing.Callable`` semantics:"
msgstr ""

#: ../../peps/pep-0677.rst:772
msgid ""
"Positional parameters: By far the most important case to handle well is "
"simple callable types with positional parameters, such as ``(int, str) ->"
" bool``"
msgstr ""

#: ../../peps/pep-0677.rst:775
msgid ""
"ParamSpec and Concatenate: The next most important feature is good "
"support for :pep:`612` ``ParamSpec`` and ``Concatenate`` types like "
"``(**P) -> bool`` and ``(int, **P) -> bool``. These are common primarily "
"because of the heavy use of decorator patterns in python code."
msgstr ""

#: ../../peps/pep-0677.rst:780
msgid ""
"TypeVarTuples: The next most important feature, assuming :pep:`646` is "
"accepted, is for unpacked types which are common because of cases where a"
" wrapper passes along ``*args`` to some other function."
msgstr ""

#: ../../peps/pep-0677.rst:784
#, python-format
msgid ""
"Features that other, more complicated proposals would support account for"
" fewer than 2% of the use cases we found. These are already expressible "
"using callback protocols, and since they are uncommon we decided that it "
"made more sense to move forward with a simpler syntax."
msgstr ""

#: ../../peps/pep-0677.rst:790
msgid "Extended Syntax Supporting Named and Optional Arguments"
msgstr ""

#: ../../peps/pep-0677.rst:792
msgid ""
"Another alternative was for a compatible but more complex syntax that "
"could express everything in this PEP but also named, optional, and "
"variadic arguments. In this “extended” syntax proposal the following "
"types would have been equivalent::"
msgstr ""

#: ../../peps/pep-0677.rst:803
msgid ""
"Advantages of this syntax include: - Most of the advantages of the "
"proposal in this PEP (conciseness, :pep:`612` support, etc) - "
"Furthermore, the ability to handle named, optional, and variadic "
"arguments"
msgstr ""

#: ../../peps/pep-0677.rst:808
msgid "We decided against proposing it for the following reasons:"
msgstr ""

#: ../../peps/pep-0677.rst:810
#, python-format
msgid ""
"The implementation would have been more difficult, and usage stats "
"demonstrate that fewer than 3% of use cases would benefit from any of the"
" added features."
msgstr ""

#: ../../peps/pep-0677.rst:813
msgid ""
"The group that debated these proposals was split down the middle about "
"whether these changes are desirable:"
msgstr ""

#: ../../peps/pep-0677.rst:816
msgid ""
"On the one hand, they make callable types more expressive. On the other "
"hand, they could easily confuse users who have not read the full "
"specification of callable type syntax."
msgstr ""

#: ../../peps/pep-0677.rst:819
msgid ""
"We believe the simpler syntax proposed in this PEP, which introduces no "
"new semantics and closely mimics syntax in other popular languages like "
"Kotlin, Scala, and TypesScript, is much less likely to confuse users."
msgstr ""

#: ../../peps/pep-0677.rst:824
msgid ""
"We intend to implement the current proposal in a way that is forward-"
"compatible with the more complicated extended syntax. If the community "
"decides after more experience and discussion that we want the additional "
"features, it should be straightforward to propose them in the future."
msgstr ""

#: ../../peps/pep-0677.rst:829
msgid ""
"Even a full extended syntax cannot replace the use of callback protocols "
"for overloads. For example, no closed form of callable type could express"
" a function that maps bools to bools and ints to floats, like this "
"callback protocol.::"
msgstr ""

#: ../../peps/pep-0677.rst:853
msgid ""
"We confirmed that the current proposal is forward-compatible with "
"extended syntax by `implementing "
"<https://github.com/stroxler/cpython/tree/callable-type-syntax--"
"extended>`_ a grammar and AST for this extended syntax on top of our "
"reference implementation of this PEP's grammar."
msgstr ""

#: ../../peps/pep-0677.rst:861
msgid "Syntax Closer to Function Signatures"
msgstr ""

#: ../../peps/pep-0677.rst:863
msgid ""
"One alternative we had floated was a syntax much more similar to function"
" signatures."
msgstr ""

#: ../../peps/pep-0677.rst:866
msgid "In this proposal, the following types would have been equivalent::"
msgstr ""

#: ../../peps/pep-0677.rst:875
msgid "The benefits of this proposal would have included:"
msgstr ""

#: ../../peps/pep-0677.rst:877
msgid "Perfect syntactic consistency between signatures and callable types."
msgstr ""

#: ../../peps/pep-0677.rst:878
msgid ""
"Support for more features of function signatures (named, optional, "
"variadic args) that this PEP does not support."
msgstr ""

#: ../../peps/pep-0677.rst:881
msgid "Key downsides that led us to reject the idea include the following:"
msgstr ""

#: ../../peps/pep-0677.rst:883
msgid ""
"A large majority of use cases only use positional-only arguments.  This "
"syntax would be more verbose for that use case, both because of requiring"
" argument names and an explicit ``/``, for example ``(int, /) -> bool`` "
"where our proposal allows ``(int) -> bool``"
msgstr ""

#: ../../peps/pep-0677.rst:887
msgid ""
"The requirement for explicit ``/`` for positional-only arguments has a "
"high risk of causing frequent bugs - which often would not be detected by"
" unit tests - where library authors would accidentally use types with "
"named arguments."
msgstr ""

#: ../../peps/pep-0677.rst:891
msgid ""
"Our analysis suggests that support for ``ParamSpec`` is key, but the "
"scoping rules laid out in :pep:`612` would have made this difficult."
msgstr ""

#: ../../peps/pep-0677.rst:896
msgid "Other Proposals Considered"
msgstr ""

#: ../../peps/pep-0677.rst:899
msgid "Functions-as-Types"
msgstr ""

#: ../../peps/pep-0677.rst:901
msgid ""
"An idea we looked at very early on was to `allow using functions as types"
" <https://docs.google.com/document/d/1rv6CCDnmLIeDrYlXe-"
"QcyT0xNPSYAuO1EBYjU3imU5s/edit?usp=sharing>`_. The idea is allowing a "
"function to stand in for its own call signature, with roughly the same "
"semantics as the ``__call__`` method of callback protocols::"
msgstr ""

#: ../../peps/pep-0677.rst:919
msgid ""
"This may be a good idea, but we do not consider it a viable replacement "
"for callable types:"
msgstr ""

#: ../../peps/pep-0677.rst:922
msgid ""
"It would be difficult to handle ``ParamSpec``, which we consider a "
"critical feature to support."
msgstr ""

#: ../../peps/pep-0677.rst:924
msgid ""
"When using functions as types, the callable types are not first-class "
"values.  Instead, they require a separate, out-of-line function "
"definition to define a type alias"
msgstr ""

#: ../../peps/pep-0677.rst:927
msgid ""
"It would not support more features than callback protocols, and seems "
"more like a shorter way to write them than a replacement for "
"``Callable``."
msgstr ""

#: ../../peps/pep-0677.rst:932
msgid "Hybrid keyword-arrow Syntax"
msgstr ""

#: ../../peps/pep-0677.rst:934
msgid ""
"In the Rust language, a keyword ``fn`` is used to indicate functions in "
"much the same way as Python's ``def``, and callable types are indicated "
"using a hybrid arrow syntax ``Fn(i64, String) -> bool``."
msgstr ""

#: ../../peps/pep-0677.rst:938
msgid ""
"We could use the ``def`` keyword in callable types for Python, for "
"example our two-parameter boolean function could be written as ``def(int,"
" str) -> bool``. But we think this might confuse readers into thinking "
"``def(A, B) -> C`` is a lambda, particularly because Javascript's "
"``function`` keyword is used in both named and anonymous functions."
msgstr ""

#: ../../peps/pep-0677.rst:946
msgid "Parenthesis-Free Syntax"
msgstr ""

#: ../../peps/pep-0677.rst:948
msgid ""
"We considered a parentheses-free syntax that would have been even more "
"concise::"
msgstr ""

#: ../../peps/pep-0677.rst:953
msgid ""
"We decided against it because this is not visually as similar to existing"
" function header syntax. Moreover, it is visually similar to lambdas, "
"which bind names with no parentheses: ``lambda x, y: x == y``."
msgstr ""

#: ../../peps/pep-0677.rst:959
msgid "Requiring Outer Parentheses"
msgstr ""

#: ../../peps/pep-0677.rst:961
msgid ""
"A concern with the current proposal is readability, particularly when "
"callable types are used in return type position which leads to multiple "
"top-level ``->`` tokens, for example::"
msgstr ""

#: ../../peps/pep-0677.rst:968
msgid ""
"We considered a few ideas to prevent this by changing rules about "
"parentheses. One was to move the parentheses to the outside, so that a "
"two-argument boolean function is written ``(int, str -> bool)``. With "
"this change, the example above becomes::"
msgstr ""

#: ../../peps/pep-0677.rst:976
msgid ""
"This makes the nesting of many examples that are difficult to follow "
"clear, but we rejected it because"
msgstr ""

#: ../../peps/pep-0677.rst:979
msgid ""
"Currently in Python commas bind very loosely, which means it might be "
"common to misread ``(int, str -> bool)`` as a tuple whose first element "
"is an int, rather than a two-parameter callable type."
msgstr ""

#: ../../peps/pep-0677.rst:982
msgid ""
"It is not very similar to function header syntax, and one of our goals "
"was familiar syntax inspired by function headers."
msgstr ""

#: ../../peps/pep-0677.rst:984
msgid ""
"This syntax may be more readable for deaply nested callables like the one"
" above, but deep nesting is not very common. Encouraging extra "
"parentheses around callable types in return position via a style guide "
"would have most of the readability benefit without the downsides."
msgstr ""

#: ../../peps/pep-0677.rst:989
msgid ""
"We also considered requiring parentheses on both the parameter list and "
"the outside, e.g. ``((int, str) -> bool)``. With this change, the example"
" above becomes::"
msgstr ""

#: ../../peps/pep-0677.rst:996
msgid "We rejected this change because:"
msgstr ""

#: ../../peps/pep-0677.rst:998
msgid ""
"The outer parentheses only help readability in some cases, mostly when a "
"callable type is used in return position. In many other cases they hurt "
"readability rather than helping."
msgstr ""

#: ../../peps/pep-0677.rst:1001
msgid ""
"We agree that it might make sense to encourage outer parentheses in "
"several cases, particularly callable types in function return "
"annotations. But"
msgstr ""

#: ../../peps/pep-0677.rst:1004
msgid ""
"We believe it is more appropriate to encourage this in style guides, "
"linters, and autoformatters than to bake it into the parser and throw "
"syntax errors."
msgstr ""

#: ../../peps/pep-0677.rst:1007
msgid ""
"Moreover, if a type is complicated enough that readability is a concern "
"we can always use type aliases, for example::"
msgstr ""

#: ../../peps/pep-0677.rst:1017
msgid "Making ``->`` bind tighter than ``|``"
msgstr ""

#: ../../peps/pep-0677.rst:1019
msgid ""
"In order to allow both ``->`` and ``|`` tokens in type expressions we had"
" to choose precedence. In the current proposal, this is a function "
"returning an optional boolean::"
msgstr ""

#: ../../peps/pep-0677.rst:1025
msgid ""
"We considered having ``->`` bind tighter so that instead the expression "
"would parse as ``((int, str) -> bool) | None``. There are two advantages "
"to this:"
msgstr ""

#: ../../peps/pep-0677.rst:1029
msgid ""
"It means we no would longer have to treat ``None | (int, str) -> bool`` "
"as a syntax error."
msgstr ""

#: ../../peps/pep-0677.rst:1031
msgid ""
"Looking at typeshed today, optional callable arguments are very common "
"because using ``None`` as a default value is a standard Python idiom. "
"Having ``->`` bind tighter would make these easier to write."
msgstr ""

#: ../../peps/pep-0677.rst:1035
msgid "We decided against this for a few reasons:"
msgstr ""

#: ../../peps/pep-0677.rst:1037
msgid ""
"The function header ``def f() -> int | None: ...`` is legal and indicates"
" a function returning an optional int. To be consistent with function "
"headers, callable types should do the same."
msgstr ""

#: ../../peps/pep-0677.rst:1040
msgid ""
"TypeScript is the other popular language we know of that uses both ``->``"
" and ``|`` tokens in type expressions, and they have ``|`` bind tighter. "
"While we do not have to follow their lead, we prefer to do so."
msgstr ""

#: ../../peps/pep-0677.rst:1044
msgid ""
"We do acknowledge that optional callable types are common and having "
"``|`` bind tighter forces extra parentheses, which makes these types "
"harder to write. But code is read more often than written, and we believe"
" that requiring the outer parentheses for an optional callable type like "
"``((int, str) -> bool) | None`` is preferable for readability."
msgstr ""

#: ../../peps/pep-0677.rst:1052
msgid "Introducing type-strings"
msgstr ""

#: ../../peps/pep-0677.rst:1054
msgid ""
"Another idea was adding a new “special string” syntax and putting the "
"type inside of it, for example ``t”(int, str) -> bool”``. We rejected "
"this because it is not as readable, and seems out of step with `guidance "
"<https://mail.python.org/archives/list/python-"
"dev@python.org/message/SZLWVYV2HPLU6AH7DOUD7DWFUGBJGQAY/>`_ from the "
"Steering Council on ensuring that type expressions do not diverge from "
"the rest of Python's syntax."
msgstr ""

#: ../../peps/pep-0677.rst:1063
msgid "Improving Usability of the Indexed Callable Type"
msgstr ""

#: ../../peps/pep-0677.rst:1065
msgid ""
"If we do not want to add new syntax for callable types, we could look at "
"how to make the existing type easier to read. One proposal would be to "
"make the builtin ``callable`` function indexable so that it could be used"
" as a type::"
msgstr ""

#: ../../peps/pep-0677.rst:1072
msgid ""
"This change would be analogous to :pep:`585` that made built in "
"collections like ``list`` and ``dict`` usable as types, and would make "
"imports more convenient, but it wouldn't help readability of the types "
"themselves much."
msgstr ""

#: ../../peps/pep-0677.rst:1077
msgid ""
"In order to reduce the number of brackets needed in complex callable "
"types, it would be possible to allow tuples for the argument list::"
msgstr ""

#: ../../peps/pep-0677.rst:1082
msgid ""
"This actually is a significant readability improvement for multi-argument"
" functions, but the problem is that it makes callables with one "
"arguments, which are the most common arity, hard to write: because "
"``(x)`` evaluates to ``x``, they would have to be written like "
"``callable[(int,), bool]``. We find this awkward."
msgstr ""

#: ../../peps/pep-0677.rst:1088
msgid ""
"Moreover, none of these ideas help as much with reducing verbosity as the"
" current proposal, nor do they introduce as strong a visual cue as the "
"``->`` between the parameter types and the return type."
msgstr ""

#: ../../peps/pep-0677.rst:1093
msgid "Alternative Runtime Behaviors"
msgstr ""

#: ../../peps/pep-0677.rst:1095
msgid "The hard requirements on our runtime API are that:"
msgstr ""

#: ../../peps/pep-0677.rst:1097
msgid ""
"It must preserve backward compatibility with ``typing.Callable`` via "
"``__args__`` and ``__params__``."
msgstr ""

#: ../../peps/pep-0677.rst:1099
msgid ""
"It must provide a structured API, which should be extensible if in the "
"future we try to support named and variadic arguments."
msgstr ""

#: ../../peps/pep-0677.rst:1103
msgid "Alternative APIs"
msgstr ""

#: ../../peps/pep-0677.rst:1105
msgid ""
"We considered having the runtime data ``types.CallableType`` use a more "
"structured API where there would be separate fields for ``posonlyargs`` "
"and ``param_spec``. The current proposal was was inspired by the "
"``inspect.Signature`` type."
msgstr ""

#: ../../peps/pep-0677.rst:1110
msgid ""
"We use \"argument\" in our field and type names, unlike \"parameter\" as "
"in ``inspect.Signature``, in order to avoid confusion with the "
"``callable_type.__parameters__`` field from the legacy API that refers to"
" type parameters rather than callable parameters."
msgstr ""

#: ../../peps/pep-0677.rst:1116
msgid "Using the plain return type in ``__args__`` for async types"
msgstr ""

#: ../../peps/pep-0677.rst:1118
msgid ""
"It is debatable whether we are required to preserve backward "
"compatibility of ``__args__`` for async callable types like ``async (int)"
" -> str``. The reason is that one could argue they are not expressible "
"directly using ``typing.Callable``, and therefore it would be fine to set"
" ``__args__`` as ``(int, int)`` rather than ``(int, "
"typing.Awaitable[int])``."
msgstr ""

#: ../../peps/pep-0677.rst:1124
msgid ""
"But we believe this would be problematic. By preserving the appearance of"
" a backward-compatible API while actually breaking its semantics on async"
" types, we would cause runtime type libraries that attempt to interpret "
"``Callable`` using ``__args__`` to fail silently."
msgstr ""

#: ../../peps/pep-0677.rst:1129
msgid ""
"It is for this reason that we automatically wrap the return type in "
"``Awaitable``."
msgstr ""

#: ../../peps/pep-0677.rst:1133
msgid "Backward Compatibility"
msgstr ""

#: ../../peps/pep-0677.rst:1135
msgid ""
"This PEP proposes a major syntax improvement over ``typing.Callable``, "
"but the static semantics are the same."
msgstr ""

#: ../../peps/pep-0677.rst:1138
msgid ""
"As such, the only thing we need for backward compatibility is to ensure "
"that types specified via the new syntax behave the same as equivalent "
"``typing.Callable`` and ``typing.Concatenate`` values they intend to "
"replace."
msgstr ""

#: ../../peps/pep-0677.rst:1143
msgid ""
"There is no particular interaction between this proposal and ``from "
"__future__ import annotations`` - just like any other type annotation it "
"will be unparsed to a string at module import, and "
"``typing.get_type_hints`` should correctly evaluate the resulting strings"
" in cases where that is possible."
msgstr ""

#: ../../peps/pep-0677.rst:1149
msgid "This is discussed in more detail in the Runtime Behavior section."
msgstr ""

#: ../../peps/pep-0677.rst:1153
msgid "Reference Implementation"
msgstr ""

#: ../../peps/pep-0677.rst:1155
msgid ""
"We have a working `implementation "
"<https://github.com/stroxler/cpython/tree/callable-type-syntax--"
"shorthand>`_ of the AST and Grammar with tests verifying that the grammar"
" proposed here has the desired behaviors."
msgstr ""

#: ../../peps/pep-0677.rst:1160
msgid ""
"The runtime behavior is not yet implemented. As discussed in the `Runtime"
" Behavior`_ portion of the spec we have a detailed plan for both a "
"backward-compatible API and a more structured API in `a separate doc "
"<https://docs.google.com/document/d/15nmTDA_39Lo-"
"EULQQwdwYx_Q1IYX4dD5WPnHbFG71Lk/edit>`_ where we are also open to "
"discussion and alternative ideas."
msgstr ""

#: ../../peps/pep-0677.rst:1169
msgid "Open Issues"
msgstr ""

#: ../../peps/pep-0677.rst:1172
msgid "Details of the Runtime API"
msgstr ""

#: ../../peps/pep-0677.rst:1174
msgid ""
"We have attempted to provide a complete behavior specification in the "
"`Runtime Behavior`_ section of this PEP."
msgstr ""

#: ../../peps/pep-0677.rst:1177
msgid ""
"But there are probably more details that we will not realize we need to "
"define until we build a full reference implementation."
msgstr ""

#: ../../peps/pep-0677.rst:1181
msgid "Optimizing ``SyntaxError`` messages"
msgstr ""

#: ../../peps/pep-0677.rst:1183
msgid ""
"The current reference implementation has a fully-functional parser and "
"all edge cases presented here have been tested."
msgstr ""

#: ../../peps/pep-0677.rst:1186
msgid ""
"But there are some known cases where the errors are not as informative as"
" we would like. For example, because ``(int, ...) -> bool`` is illegal "
"but ``(int, ...)`` is a valid tuple, we currently produce a syntax error "
"flagging the ``->`` as the problem even though the real cause of the "
"error is using ``...`` as an argument type."
msgstr ""

#: ../../peps/pep-0677.rst:1192
msgid ""
"This is not part of the specification *per se* but is an important detail"
" to address in our implementation. The solution will likely involve "
"adding ``invalid_.*`` rules to ``python.gram`` and customizing error "
"messages."
msgstr ""

#: ../../peps/pep-0677.rst:1198
msgid "Resources"
msgstr ""

#: ../../peps/pep-0677.rst:1201
msgid "Background and History"
msgstr ""

#: ../../peps/pep-0677.rst:1203
msgid ""
":pep:`PEP 484 specifies <484#suggested-syntax-for-python-2-7-and-"
"straddling-code>` a very similar syntax for function type hint *comments*"
" for use in code that needs to work on Python 2.7. For example::"
msgstr ""

#: ../../peps/pep-0677.rst:1212
msgid ""
"At that time we used indexing operations to specify generic types like "
"``typing.Callable`` because we decided not to add syntax for types. "
"However, we have since begun to do so, e.g. with :pep:`604`."
msgstr ""

#: ../../peps/pep-0677.rst:1216
msgid ""
"**Maggie** proposed better callable type syntax as part of a larger "
"`presentation on typing simplifications "
"<https://drive.google.com/file/d/1XhqTKoO6RHtz7zXqW5Wgq9nzaEz9TXjI/view>`_"
" at the PyCon Typing Summit 2021."
msgstr ""

#: ../../peps/pep-0677.rst:1221
msgid ""
"**Steven** `brought up this proposal on typing-sig "
"<https://mail.python.org/archives/list/typing-"
"sig@python.org/thread/3JNXLYH5VFPBNIVKT6FFBVVFCZO4GFR2>`_. We had several"
" meetings to discuss alternatives, and `this presentation "
"<https://www.dropbox.com/s/sshgtr4p30cs0vc/Python%20Callable%20Syntax%20Proposals.pdf?dl=0>`_"
" led us to the current proposal."
msgstr ""

#: ../../peps/pep-0677.rst:1227
msgid ""
"**Pradeep** `brought this proposal to python-dev "
"<https://mail.python.org/archives/list/python-"
"dev@python.org/thread/VBHJOS3LOXGVU6I4FABM6DKHH65GGCUB>`_ for feedback."
msgstr ""

#: ../../peps/pep-0677.rst:1232
msgid "Acknowledgments"
msgstr ""

#: ../../peps/pep-0677.rst:1234
msgid ""
"Thanks to the following people for their feedback on the PEP and help "
"planning the reference implementation:"
msgstr ""

#: ../../peps/pep-0677.rst:1237
msgid ""
"Alex Waygood, Eric Traut, Guido van Rossum, James Hilton-Balfe, Jelle "
"Zijlstra, Maggie Moss, Tuomas Suutari, Shannon Zhu."
msgstr ""

#: ../../peps/pep-0677.rst:1241
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-0677.rst:1243
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

#~ msgid ""
#~ "It is debatable whether we are "
#~ "required to preserve backward compatiblity "
#~ "of ``__args__`` for async callable types"
#~ " like ``async (int) -> str``. The "
#~ "reason is that one could argue "
#~ "they are not expressible directly using"
#~ " ``typing.Callable``, and therefore it "
#~ "would be fine to set ``__args__`` "
#~ "as ``(int, int)`` rather than ``(int,"
#~ " typing.Awaitable[int])``."
#~ msgstr ""

