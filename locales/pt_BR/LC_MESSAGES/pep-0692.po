# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-14 02:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../peps/peps/pep-0692.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/peps/pep-0692.rst:3
msgid "Franek Magiera <framagie@gmail.com>"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Sponsor"
msgstr ""

#: ../../peps/peps/pep-0692.rst:4
msgid "Jelle Zijlstra <jelle.zijlstra@gmail.com>"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/peps/pep-0692.rst:5
msgid ""
"https://discuss.python.org/t/pep-692-using-typeddict-for-more-precise-kwargs-"
"typing/17314"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Status"
msgstr "Status"

#: ../../peps/peps/pep-0692.rst:6
msgid "Final"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/peps/pep-0692.rst:7
msgid "Standards Track"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Topic"
msgstr ""

#: ../../peps/peps/pep-0692.rst:8
msgid "Typing"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/peps/pep-0692.rst:9
msgid "29-May-2022"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/peps/pep-0692.rst:10
msgid "3.12"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/peps/pep-0692.rst:11
msgid ""
"`29-May-2022 <https://mail.python.org/archives/list/typing-sig@python.org/"
"thread/U42MJE6QZYWPVIFHJIGIT7OE52ZGIQV3/>`__, `12-Jul-2022 <https://mail."
"python.org/archives/list/python-dev@python.org/thread/"
"PLCNW2XR4OOKAKHEZQM7R2AYVYUXPZGW/>`__, `12-Jul-2022 <https://discuss.python."
"org/t/pep-692-using-typeddict-for-more-precise-kwargs-typing/17314>`__,"
msgstr ""

#: ../../peps/peps/pep-0692.rst
msgid "Resolution"
msgstr ""

#: ../../peps/peps/pep-0692.rst:14
msgid ""
"https://discuss.python.org/t/pep-692-using-typeddict-for-more-precise-kwargs-"
"typing/17314/81"
msgstr ""

#: ../../peps/peps/pep-0692.rst:19
msgid "Abstract"
msgstr ""

#: ../../peps/peps/pep-0692.rst:21
msgid ""
"Currently ``**kwargs`` can be type hinted as long as all of the keyword "
"arguments specified by them are of the same type. However, that behaviour "
"can be very limiting. Therefore, in this PEP we propose a new way to enable "
"more precise ``**kwargs`` typing. The new approach revolves around using "
"``TypedDict`` to type ``**kwargs`` that comprise keyword arguments of "
"different types."
msgstr ""

#: ../../peps/peps/pep-0692.rst:29
msgid "Motivation"
msgstr ""

#: ../../peps/peps/pep-0692.rst:31
msgid ""
"Currently annotating ``**kwargs`` with a type ``T`` means that the "
"``kwargs`` type is in fact ``dict[str, T]``. For example::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:36
msgid ""
"means that all keyword arguments in ``foo`` are strings (i.e., ``kwargs`` is "
"of type ``dict[str, str]``). This behaviour limits the ability to type "
"annotate ``**kwargs`` only to the cases where all of them are of the same "
"type. However, it is often the case that keyword arguments conveyed by "
"``**kwargs`` have different types that are dependent on the keyword's name. "
"In those cases type annotating ``**kwargs`` is not possible. This is "
"especially a problem for already existing codebases where the need of "
"refactoring the code in order to introduce proper type annotations may be "
"considered not worth the effort. This in turn prevents the project from "
"getting all of the benefits that type hinting can provide."
msgstr ""

#: ../../peps/peps/pep-0692.rst:47
msgid ""
"Moreover, ``**kwargs`` can be used to reduce the amount of code needed in "
"cases when there is a top-level function that is a part of a public API and "
"it calls a bunch of helper functions, all of which expect the same keyword "
"arguments. Unfortunately, if those helper functions were to use "
"``**kwargs``, there is no way to properly type hint them if the keyword "
"arguments they expect are of different types. In addition, even if the "
"keyword arguments are of the same type, there is no way to check whether the "
"function is being called with keyword names that it actually expects."
msgstr ""

#: ../../peps/peps/pep-0692.rst:56
msgid ""
"As described in the `Intended Usage`_ section, using ``**kwargs`` is not "
"always the best tool for the job. Despite that, it is still a widely used "
"pattern. As a consequence, there has been a lot of discussion around "
"supporting more precise ``**kwargs`` typing and it became a feature that "
"would be valuable for a large part of the Python community. This is best "
"illustrated by the `mypy GitHub issue 4441 <mypyIssue4441_>`__ which "
"contains a lot of real world cases that could benefit from this propsal."
msgstr ""

#: ../../peps/peps/pep-0692.rst:64
msgid ""
"One more use case worth mentioning for which ``**kwargs`` are also "
"convenient, is when a function should accommodate optional keyword-only "
"arguments that don't have default values. A need for a pattern like that can "
"arise when values that are usually used as defaults to indicate no user "
"input, such as ``None``, can be passed in by a user and should result in a "
"valid, non-default behavior. For example, this issue `came up "
"<httpxIssue1384_>`__ in the popular ``httpx`` library."
msgstr ""

#: ../../peps/peps/pep-0692.rst:72
msgid "Rationale"
msgstr ""

#: ../../peps/peps/pep-0692.rst:74
msgid ""
":pep:`589` introduced the ``TypedDict`` type constructor that supports "
"dictionary types consisting of string keys and values of potentially "
"different types. A function's keyword arguments represented by a formal "
"parameter that begins with double asterisk, such as ``**kwargs``, are "
"received as a dictionary. Additionally, such functions are often called "
"using unpacked dictionaries to provide keyword arguments. This makes "
"``TypedDict`` a perfect candidate to be used for more precise ``**kwargs`` "
"typing. In addition, with ``TypedDict`` keyword names can be taken into "
"account during static type analysis. However, specifying ``**kwargs`` type "
"with a ``TypedDict`` means, as mentioned earlier, that each keyword argument "
"specified by ``**kwargs`` is a ``TypedDict`` itself. For instance::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:92
msgid ""
"means that each keyword argument in ``foo`` is itself a ``Movie`` dictionary "
"that has a ``name`` key with a string type value and a ``year`` key with an "
"integer type value. Therefore, in order to support specifying ``kwargs`` "
"type as a ``TypedDict`` without breaking current behaviour, a new construct "
"has to be introduced."
msgstr ""

#: ../../peps/peps/pep-0692.rst:98
msgid ""
"To support this use case, we propose reusing ``Unpack`` which was initially "
"introduced in :pep:`646`. There are several reasons for doing so:"
msgstr ""

#: ../../peps/peps/pep-0692.rst:101
msgid ""
"Its name is quite suitable and intuitive for the ``**kwargs`` typing use "
"case as our intention is to \"unpack\" the keywords arguments from the "
"supplied ``TypedDict``."
msgstr ""

#: ../../peps/peps/pep-0692.rst:104
msgid ""
"The current way of typing ``*args`` would be extended to ``**kwargs`` and "
"those are supposed to behave similarly."
msgstr ""

#: ../../peps/peps/pep-0692.rst:106
msgid "There would be no need to introduce any new special forms."
msgstr ""

#: ../../peps/peps/pep-0692.rst:107
msgid ""
"The use of ``Unpack`` for the purposes described in this PEP does not "
"interfere with the use cases described in :pep:`646`."
msgstr ""

#: ../../peps/peps/pep-0692.rst:111
msgid "Specification"
msgstr ""

#: ../../peps/peps/pep-0692.rst:113
msgid ""
"With ``Unpack`` we introduce a new way of annotating ``**kwargs``. "
"Continuing the previous example::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:118
msgid ""
"would mean that the ``**kwargs`` comprise two keyword arguments specified by "
"``Movie`` (i.e. a ``name`` keyword of type ``str`` and a ``year`` keyword of "
"type ``int``). This indicates that the function should be called as follows::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:127
msgid ""
"When ``Unpack`` is used, type checkers treat ``kwargs`` inside the function "
"body as a ``TypedDict``::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:134
msgid ""
"Using the new annotation will not have any runtime effect - it should only "
"be taken into account by type checkers. Any mention of errors in the "
"following sections relates to type checker errors."
msgstr ""

#: ../../peps/peps/pep-0692.rst:139
msgid "Function calls with standard dictionaries"
msgstr ""

#: ../../peps/peps/pep-0692.rst:141
msgid ""
"Passing a dictionary of type ``dict[str, object]`` as a ``**kwargs`` "
"argument to a function that has ``**kwargs`` annotated with ``Unpack`` must "
"generate a type checker error. On the other hand, the behaviour for "
"functions using standard, untyped dictionaries can depend on the type "
"checker. For example::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:158
msgid "Keyword collisions"
msgstr ""

#: ../../peps/peps/pep-0692.rst:160
msgid ""
"A ``TypedDict`` that is used to type ``**kwargs`` could potentially contain "
"keys that are already defined in the function's signature. If the duplicate "
"name is a standard parameter, an error should be reported by type checkers. "
"If the duplicate name is a positional-only parameter, no errors should be "
"generated. For example::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:176
msgid "Required and non-required keys"
msgstr ""

#: ../../peps/peps/pep-0692.rst:178
msgid ""
"By default all keys in a ``TypedDict`` are required. This behaviour can be "
"overridden by setting the dictionary's ``total`` parameter as ``False``. "
"Moreover, :pep:`655` introduced new type qualifiers - ``typing.Required`` "
"and ``typing.NotRequired`` - that enable specifying whether a particular key "
"is required or not::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:188
msgid ""
"When using a ``TypedDict`` to type ``**kwargs`` all of the required and non-"
"required keys should correspond to required and non-required function "
"keyword parameters. Therefore, if a required key is not supported by the "
"caller, then an error must be reported by type checkers."
msgstr ""

#: ../../peps/peps/pep-0692.rst:194
msgid "Assignment"
msgstr ""

#: ../../peps/peps/pep-0692.rst:196
msgid ""
"Assignments of a function typed with ``**kwargs: Unpack[Movie]`` and another "
"callable type should pass type checking only if they are compatible. This "
"can happen for the scenarios described below."
msgstr ""

#: ../../peps/peps/pep-0692.rst:201
msgid "Source and destination contain ``**kwargs``"
msgstr ""

#: ../../peps/peps/pep-0692.rst:203
msgid ""
"Both destination and source functions have a ``**kwargs: Unpack[TypedDict]`` "
"parameter and the destination function's ``TypedDict`` is assignable to the "
"source function's ``TypedDict`` and the rest of the parameters are "
"compatible::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:226
msgid "Source contains ``**kwargs`` and destination doesn't"
msgstr ""

#: ../../peps/peps/pep-0692.rst:228
msgid ""
"The destination callable doesn't contain ``**kwargs``, the source callable "
"contains ``**kwargs: Unpack[TypedDict]`` and the destination function's "
"keyword arguments are assignable to the corresponding keys in source "
"function's ``TypedDict``. Moreover, not required keys should correspond to "
"optional function arguments, whereas required keys should correspond to "
"required function arguments. Again, the rest of the parameters have to be "
"compatible. Continuing the previous example::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:246
msgid ""
"It is worth pointing out that the destination function's parameters that are "
"to be compatible with the keys and values from the ``TypedDict`` must be "
"keyword only::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:261
msgid ""
"The reverse situation where the destination callable contains ``**kwargs: "
"Unpack[TypedDict]`` and the source callable doesn't contain ``**kwargs`` "
"should be disallowed. This is because, we cannot be sure that additional "
"keyword arguments are not being passed in when an instance of a subclass had "
"been assigned to a variable with a base class type and then unpacked in the "
"destination callable invocation::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:277
msgid ""
"Similar situation can happen even without inheritance as compatibility "
"between ``TypedDict``\\s is based on structural subtyping."
msgstr ""

#: ../../peps/peps/pep-0692.rst:281
msgid "Source contains untyped ``**kwargs``"
msgstr ""

#: ../../peps/peps/pep-0692.rst:283
msgid ""
"The destination callable contains ``**kwargs: Unpack[TypedDict]`` and the "
"source callable contains untyped ``**kwargs``::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:292
msgid "Source contains traditionally typed ``**kwargs: T``"
msgstr ""

#: ../../peps/peps/pep-0692.rst:294
msgid ""
"The destination callable contains ``**kwargs: Unpack[TypedDict]``, the "
"source callable contains traditionally typed ``**kwargs: T`` and each of the "
"destination function ``TypedDict``'s fields is assignable to a variable of "
"type ``T``::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:317
msgid ""
"On the other hand, if the destination callable contains either untyped or "
"traditionally typed ``**kwargs: T`` and the source callable is typed using "
"``**kwargs: Unpack[TypedDict]`` then an error should be generated, because "
"traditionally typed ``**kwargs`` aren't checked for keyword names."
msgstr ""

#: ../../peps/peps/pep-0692.rst:322
msgid ""
"To summarize, function parameters should behave contravariantly and function "
"return types should behave covariantly."
msgstr ""

#: ../../peps/peps/pep-0692.rst:326
msgid "Passing kwargs inside a function to another function"
msgstr ""

#: ../../peps/peps/pep-0692.rst:328
msgid ""
"`A previous point <PEP 692 assignment dest no kwargs>`_ mentions the problem "
"of possibly passing additional keyword arguments by assigning a subclass "
"instance to a variable that has a base class type. Let's consider the "
"following example::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:364
msgid ""
"In the example above, the call to ``foo`` will not cause any issues at "
"runtime. Even though ``foo`` expects ``kwargs`` of type ``Animal`` it "
"doesn't matter if it receives additional arguments because it only reads and "
"uses what it needs completely ignoring any additional values."
msgstr ""

#: ../../peps/peps/pep-0692.rst:369
msgid ""
"The calls to ``bar`` and ``spam`` will fail because an unexpected keyword "
"argument will be passed to the ``takes_name`` function."
msgstr ""

#: ../../peps/peps/pep-0692.rst:372
msgid ""
"Therefore, ``kwargs`` hinted with an unpacked ``TypedDict`` can only be "
"passed to another function if the function to which unpacked kwargs are "
"being passed to has ``**kwargs`` in its signature as well, because then "
"additional keywords would not cause errors at runtime during function "
"invocation. Otherwise, the type checker should generate an error."
msgstr ""

#: ../../peps/peps/pep-0692.rst:378
msgid ""
"In cases similar to the ``bar`` function above the problem could be worked "
"around by explicitly dereferencing desired fields and using them as "
"arguments to perform the function call::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:387
msgid "Using ``Unpack`` with types other than ``TypedDict``"
msgstr ""

#: ../../peps/peps/pep-0692.rst:389
msgid ""
"As described in the Rationale_ section, ``TypedDict`` is the most natural "
"candidate for typing ``**kwargs``. Therefore, in the context of typing "
"``**kwargs``, using ``Unpack`` with types other than ``TypedDict`` should "
"not be allowed and type checkers should generate errors in such cases."
msgstr ""

#: ../../peps/peps/pep-0692.rst:396
msgid "Changes to ``Unpack``"
msgstr ""

#: ../../peps/peps/pep-0692.rst:398
msgid ""
"Currently using ``Unpack`` in the context of typing is interchangeable with "
"using the asterisk syntax::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:404
msgid ""
"Therefore, in order to be compatible with the new use case, ``Unpack``'s "
"``repr`` should be changed to simply ``Unpack[T]``."
msgstr ""

#: ../../peps/peps/pep-0692.rst:408
msgid "Intended Usage"
msgstr ""

#: ../../peps/peps/pep-0692.rst:409
msgid ""
"The intended use cases for this proposal are described in the Motivation_ "
"section. In summary, more precise ``**kwargs`` typing can bring benefits to "
"already existing codebases that decided to use ``**kwargs`` initially, but "
"now are mature enough to use a stricter contract via type hints. Using "
"``**kwargs`` can also help in reducing code duplication and the amount of "
"copy-pasting needed when there is a bunch of functions that require the same "
"set of keyword arguments. Finally, ``**kwargs`` are useful for cases when a "
"function needs to facilitate optional keyword arguments that don't have "
"obvious default values."
msgstr ""

#: ../../peps/peps/pep-0692.rst:419
msgid ""
"However, it has to be pointed out that in some cases there are better tools "
"for the job than using ``TypedDict`` to type ``**kwargs`` as proposed in "
"this PEP. For example, when writing new code if all the keyword arguments "
"are required or have default values then writing everything explicitly is "
"better than using ``**kwargs`` and a ``TypedDict``::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:428
msgid ""
"Similarly, when type hinting third party libraries via stubs it is again "
"better to state the function signature explicitly - this is the only way to "
"type such a function if it has default arguments. Another issue that may "
"arise in this case when trying to type hint the function with a "
"``TypedDict`` is that some standard function parameters may be treated as "
"keyword only::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:445
msgid ""
"Therefore, in this case it is again preferred to type hint such function "
"explicitly as::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:450
msgid ""
"Also, for the benefit of IDEs and documentation pages, functions that are "
"part of the public API should prefer explicit keyword parameters whenever "
"possible."
msgstr ""

#: ../../peps/peps/pep-0692.rst:454
msgid "How to Teach This"
msgstr ""

#: ../../peps/peps/pep-0692.rst:456
msgid ""
"This PEP could be linked in the ``typing`` module's documentation. Moreover, "
"a new section on using ``Unpack`` could be added to the aforementioned docs. "
"Similar sections could be also added to the `mypy documentation <https://"
"mypy.readthedocs.io/>`_ and the `typing RTD documentation <https://typing."
"readthedocs.io/>`_."
msgstr ""

#: ../../peps/peps/pep-0692.rst:463
msgid "Reference Implementation"
msgstr ""

#: ../../peps/peps/pep-0692.rst:465
msgid ""
"The `mypy type checker <https://github.com/python/mypy>`_ already `supports "
"<https://github.com/python/mypy/pull/13471>`_ more precise ``**kwargs`` "
"typing using ``Unpack``."
msgstr ""

#: ../../peps/peps/pep-0692.rst:469
msgid ""
"`Pyright type checker <https://github.com/microsoft/pyright>`_ also "
"`provides provisional support <pyrightProvisionalImplementation_>`__ for "
"`this feature <pyrightIssue3002_>`__."
msgstr ""

#: ../../peps/peps/pep-0692.rst:474
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/peps/pep-0692.rst:477
msgid "``TypedDict`` unions"
msgstr ""

#: ../../peps/peps/pep-0692.rst:479
msgid ""
"It is possible to create unions of typed dictionaries. However, supporting "
"typing ``**kwargs`` with a union of typed dicts would greatly increase the "
"complexity of the implementation of this PEP and there seems to be no "
"compelling use case to justify the support for this. Therefore, using unions "
"of typed dictionaries to type ``**kwargs`` as described in the context of "
"this PEP can result in an error::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:497
msgid ""
"Instead, a function that expects a union of ``TypedDict``\\s can be "
"overloaded::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:507
msgid "Changing the meaning of ``**kwargs`` annotations"
msgstr ""

#: ../../peps/peps/pep-0692.rst:509
msgid ""
"One way to achieve the purpose of this PEP would be to change the meaning of "
"``**kwargs`` annotations, so that the annotations would apply to the entire "
"``**kwargs`` dict, not to individual elements. For consistency, we would "
"have to make an analogous change to ``*args`` annotations."
msgstr ""

#: ../../peps/peps/pep-0692.rst:515
msgid ""
"This idea was discussed in a meeting of the typing community, and the "
"consensus was that the change would not be worth the cost. There is no clear "
"migration path, the current meaning of ``*args`` and ``**kwargs`` "
"annotations is well-established in the ecosystem, and type checkers would "
"have to introduce new errors for code that is currently legal."
msgstr ""

#: ../../peps/peps/pep-0692.rst:522
msgid "Introducing a new syntax"
msgstr ""

#: ../../peps/peps/pep-0692.rst:524
msgid ""
"In the previous versions of this PEP, using a double asterisk syntax was "
"proposed to support more precise ``**kwargs`` typing. Using this syntax, "
"functions could be annotated as follows::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:530
msgid "Which would have the same meaning as::"
msgstr ""

#: ../../peps/peps/pep-0692.rst:534
msgid ""
"This greatly increased the scope of the PEP, as it would require a grammar "
"change and adding a new dunder for the ``Unpack`` special form. At the same "
"the justification for introducing a new syntax was not strong enough and "
"became a blocker for the whole PEP. Therefore, we decided to abandon the "
"idea of introducing a new syntax as a part of this PEP and may propose it "
"again in a separate one."
msgstr ""

#: ../../peps/peps/pep-0692.rst:550
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/peps/pep-0692.rst:552
msgid ""
"This document is placed in the public domain or under the CC0-1.0-Universal "
"license, whichever is more permissive."
msgstr ""

#~ msgid "Accepted"
#~ msgstr "Criada em"
