# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0649.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-0649.rst:3
msgid "Larry Hastings <larry@hastings.org>"
msgstr ""

#: ../../peps/pep-0649.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/pep-0649.rst:4
msgid ""
"https://discuss.python.org/t/pep-649-deferred-evaluation-of-annotations-"
"tentatively-accepted/21331/"
msgstr ""

#: ../../peps/pep-0649.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-0649.rst:5
#, fuzzy
msgid "Accepted"
msgstr "Criada em"

#: ../../peps/pep-0649.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-0649.rst:6
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0649.rst
msgid "Topic"
msgstr ""

#: ../../peps/pep-0649.rst:7
msgid "Typing"
msgstr ""

#: ../../peps/pep-0649.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-0649.rst:9
msgid "11-Jan-2021"
msgstr ""

#: ../../peps/pep-0649.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0649.rst:10
msgid "3.13"
msgstr ""

#: ../../peps/pep-0649.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-0649.rst:11
msgid ""
"`11-Jan-2021 <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/5QMMCRF4HTRRNJV56CGHVI5GRHVBDGQO/>`__, `12-Apr-2021"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/QSASX6PZ3LIIFIANHQQFS752BJYFUFPY/>`__, `18-Apr-2021"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/WUZGTGE43T7XV3EUGT6AN2N52OD3U7AE/>`__, `09-Aug-2021"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/2MEOWHCVDLPABOBLYUGRXVOOOBYOLLU6/>`__, `20-Oct-2021"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/SZLWVYV2HPLU6AH7DOUD7DWFUGBJGQAY/>`__, `20-Oct-2021"
" <https://discuss.python.org/t/type-annotations-pep-649-and-"
"pep-563/11363>`__, `17-Nov-2021 <https://mail.python.org/archives/list"
"/python-dev@python.org/thread/VIZEBX5EYMSYIJNDBF6DMUMZOCWHARSO/>`__, "
"`15-Mar-2022 <https://discuss.python.org/t/finding-edge-cases-for-"
"peps-484-563-and-649-type-annotations/14314>`__, `23-Nov-2022 "
"<https://discuss.python.org/t/pep-649-deferred-evaluation-of-annotations-"
"tentatively-accepted/21331>`__, `07-Feb-2023 "
"<https://discuss.python.org/t/two-polls-on-how-to-revise-"
"pep-649/23628>`__, `11-Apr-2023 <https://discuss.python.org/t/a-massive-"
"pep-649-update-with-some-major-course-corrections/25672>`__,"
msgstr ""

#: ../../peps/pep-0649.rst
msgid "Resolution"
msgstr ""

#: ../../peps/pep-0649.rst:22
msgid ""
"https://discuss.python.org/t/pep-649-deferred-evaluation-of-annotations-"
"tentatively-accepted/21331/43"
msgstr ""

#: ../../peps/pep-0649.rst:26
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0649.rst:28
msgid ""
"Annotations are a Python technology that allows expressing type "
"information and other metadata about Python functions, classes, and "
"modules.  But Python's original semantics for annotations required them "
"to be eagerly evaluated, at the time the annotated object was bound.  "
"This caused chronic problems for static type analysis users using \"type "
"hints\", due to forward-reference and circular-reference problems."
msgstr ""

#: ../../peps/pep-0649.rst:37
msgid ""
"Python solved this by accepting :pep:`563`, incorporating a new approach "
"called \"stringized annotations\" in which annotations were automatically"
" converted into strings by Python.  This solved the forward-reference and"
" circular-reference problems, and also fostered intriguing new uses for "
"annotation metadata.  But stringized annotations in turn caused chronic "
"problems for runtime users of annotations."
msgstr ""

#: ../../peps/pep-0649.rst:45
msgid ""
"This PEP proposes a new and comprehensive third approach for representing"
" and computing annotations.  It adds a new internal mechanism for lazily "
"computing annotations on demand, via a new object method called "
"``__annotate__``. This approach, when combined with a novel technique for"
" coercing annotation values into alternative formats, solves all the "
"above problems, supports all existing use cases, and should foster future"
" innovations in annotations."
msgstr ""

#: ../../peps/pep-0649.rst:57
msgid "Overview"
msgstr ""

#: ../../peps/pep-0649.rst:59
msgid ""
"This PEP adds a new dunder attribute to the objects that support "
"annotations--functions, classes, and modules. The new attribute is called"
" ``__annotate__``, and is a reference to a function which computes and "
"returns that object's annotations dict."
msgstr ""

#: ../../peps/pep-0649.rst:65
msgid ""
"At compile time, if the definition of an object includes annotations, the"
" Python compiler will write the expressions computing the annotations "
"into its own function.  When run, the function will return the "
"annotations dict.  The Python compiler then stores a reference to this "
"function in ``__annotate__`` on the object."
msgstr ""

#: ../../peps/pep-0649.rst:72
msgid ""
"Furthermore, ``__annotations__`` is redefined to be a \"data descriptor\""
" which calls this annotation function once and caches the result."
msgstr ""

#: ../../peps/pep-0649.rst:76
msgid ""
"This mechanism delays the evaluation of annotations expressions until the"
" annotations are examined, which solves many circular reference problems."
msgstr ""

#: ../../peps/pep-0649.rst:80
msgid ""
"This PEP also defines new functionality for two functions in the Python "
"standard library: ``inspect.get_annotations`` and "
"``typing.get_type_hints``. The functionality is accessed via a new "
"keyword-only parameter, ``format``.  ``format`` allows the user to "
"request the annotations from these functions in a specific format. Format"
" identifiers are always predefined integer values. The formats defined by"
" this PEP are:"
msgstr ""

#: ../../peps/pep-0649.rst:91
msgid "``inspect.VALUE = 1``"
msgstr ""

#: ../../peps/pep-0649.rst:93
msgid ""
"The default value. The function will return the conventional Python "
"values for the annotations.  This format is identical to the return value"
" for these functions under Python 3.11."
msgstr ""

#: ../../peps/pep-0649.rst:98
msgid "``inspect.FORWARDREF = 2``"
msgstr ""

#: ../../peps/pep-0649.rst:100
msgid ""
"The function will attempt to return the conventional Python values for "
"the annotations.  However, if it encounters an undefined name, or a free "
"variable that has not yet been associated with a value, it dynamically "
"creates a proxy object (a ``ForwardRef``) that substitutes for that value"
" in the expression, then continues evaluation. The resulting dict may "
"contain a mixture of proxies and real values.  If all real values are "
"defined at the time the function is called, ``inspect.FORWARDREF`` and "
"``inspect.VALUE`` produce identical results."
msgstr ""

#: ../../peps/pep-0649.rst:111
msgid "``inspect.SOURCE = 3``"
msgstr ""

#: ../../peps/pep-0649.rst:113
msgid ""
"The function will produce an annotation dictionary where the values have "
"been replaced by strings containing the original source code for the "
"annotation expressions. These strings may only be approximate, as they "
"may be reverse-engineered from another format, rather than preserving the"
" original source code, but the differences will be minor."
msgstr ""

#: ../../peps/pep-0649.rst:121
msgid ""
"If accepted, this PEP would *supersede* :pep:`563`, and :pep:`563`'s "
"behavior would be deprecated and eventually removed."
msgstr ""

#: ../../peps/pep-0649.rst:127
msgid "Comparison Of Annotation Semantics"
msgstr ""

#: ../../peps/pep-0649.rst:129
msgid ""
"The code presented in this section is simplified for clarity, and is "
"intentionally inaccurate in some critical aspects.  This example is "
"intended merely to communicate the high-level concepts involved without "
"getting lost in the details.  But readers should note that the actual "
"implementation is quite different in several important ways.  See the "
"Implementation_ section later in this PEP for a far more accurate "
"description of what this PEP proposes from a technical level."
msgstr ""

#: ../../peps/pep-0649.rst:140
msgid "Consider this example code:"
msgstr ""

#: ../../peps/pep-0649.rst:150
msgid ""
"As we see here, annotations are available at runtime through an "
"``__annotations__`` attribute on functions, classes, and modules. When "
"annotations are specified on one of these objects, ``__annotations__`` is"
" a dictionary mapping the names of the fields to the value specified as "
"that field's annotation."
msgstr ""

#: ../../peps/pep-0649.rst:156
msgid ""
"The default behavior in Python is to evaluate the expressions for the "
"annotations, and build the annotations dict, at the time the function, "
"class, or module is bound.  At runtime the above code actually works "
"something like this:"
msgstr ""

#: ../../peps/pep-0649.rst:171
msgid ""
"The crucial detail here is that the values ``int``, ``MyType``, and "
"``float`` are looked up at the time the function object is bound, and "
"these values are stored in the annotations dict. But this code doesn't "
"run—it throws a ``NameError`` on the first line, because ``MyType`` "
"hasn't been defined yet."
msgstr ""

#: ../../peps/pep-0649.rst:177
msgid ""
":pep:`563`'s solution is to decompile the expressions back into strings "
"during compilation and store those strings as the values in the "
"annotations dict.  The equivalent runtime code would look something like "
"this:"
msgstr ""

#: ../../peps/pep-0649.rst:192
msgid ""
"This code now runs successfully.  However, ``foo_y_annotation`` is no "
"longer a reference to ``MyType``, it is the *string* ``'MyType'``.  To "
"turn the string into the real value ``MyType``, the user would need to "
"evaluate the string using ``eval``, ``inspect.get_annotations``, or "
"``typing.get_type_hints``."
msgstr ""

#: ../../peps/pep-0649.rst:198
msgid ""
"This PEP proposes a third approach, delaying the evaluation of the "
"annotations by computing them in their own function.  If this PEP was "
"active, the generated code would work something like this:"
msgstr ""

#: ../../peps/pep-0649.rst:224
msgid ""
"The important change is that the code constructing the annotations dict "
"now lives in a function—here, called ``annotate_foo()``.  But this "
"function isn't called until we ask for the value of "
"``foo.__annotations__``, and we don't do that until *after* the "
"definition of ``MyType``. So this code also runs successfully, and "
"``foo_y_annotation`` now has the correct value--the class "
"``MyType``--even though ``MyType`` wasn't defined until *after* the "
"annotation was defined."
msgstr ""

#: ../../peps/pep-0649.rst:236
msgid "Mistaken Rejection Of This Approach In November 2017"
msgstr ""

#: ../../peps/pep-0649.rst:238
msgid ""
"During the early days of discussion around :pep:`563`, in a November 2017"
" thread in ``comp.lang.python-dev``, the idea of using code to delay the "
"evaluation of annotations was briefly discussed.  At the time the "
"technique was termed an \"implicit lambda expression\"."
msgstr ""

#: ../../peps/pep-0649.rst:244
msgid ""
"Guido van Rossum—Python's BDFL at the time—replied, asserting that these "
"\"implicit lambda expression\" wouldn't work, because they'd only be able"
" to resolve symbols at module-level scope:"
msgstr ""

#: ../../peps/pep-0649.rst:249
msgid ""
"IMO the inability of referencing class-level definitions from annotations"
" on methods pretty much kills this idea."
msgstr ""

#: ../../peps/pep-0649.rst:252
msgid "https://mail.python.org/pipermail/python-dev/2017-November/150109.html"
msgstr ""

#: ../../peps/pep-0649.rst:254
msgid ""
"This led to a short discussion about extending lambda-ized annotations "
"for methods to be able to refer to class-level definitions, by "
"maintaining a reference to the class-level scope.  This idea, too, was "
"quickly rejected."
msgstr ""

#: ../../peps/pep-0649.rst:259
msgid ""
":pep:`PEP 563 summarizes the above discussion <563#keeping-the-ability-"
"to-use-function-local-state-when-defining-annotations>`"
msgstr ""

#: ../../peps/pep-0649.rst:262
msgid ""
"The approach taken by this PEP doesn't suffer from these restrictions.  "
"Annotations can access module-level definitions, class-level definitions,"
" and even local and free variables."
msgstr ""

#: ../../peps/pep-0649.rst:269
msgid "Motivation"
msgstr ""

#: ../../peps/pep-0649.rst:272
msgid "A History Of Annotations"
msgstr ""

#: ../../peps/pep-0649.rst:274
msgid ""
"Python 3.0 shipped with a new syntax feature, \"annotations\", defined in"
" :pep:`3107`. This allowed specifying a Python value that would be "
"associated with a parameter of a Python function, or with the value that "
"function returns. Said another way, annotations gave Python users an "
"interface to provide rich metadata about a function parameter or return "
"value, for example type information. All the annotations for a function "
"were stored together in a new attribute ``__annotations__``, in an "
"\"annotation dict\" that mapped parameter names (or, in the case of the "
"return annotation, using the name ``'return'``) to their Python value."
msgstr ""

#: ../../peps/pep-0649.rst:287
msgid ""
"In an effort to foster experimentation, Python intentionally didn't "
"define what form this metadata should take, or what values should be "
"used.  User code began experimenting with this new facility almost "
"immediately.  But popular libraries that make use of this functionality "
"were slow to emerge."
msgstr ""

#: ../../peps/pep-0649.rst:293
msgid ""
"After years of little progress, the BDFL chose a particular approach for "
"expressing static type information, called *type hints,* as defined in "
":pep:`484`.  Python 3.5 shipped with a new :mod:`typing` module which "
"quickly became very popular."
msgstr ""

#: ../../peps/pep-0649.rst:298
msgid ""
"Python 3.6 added syntax to annotate local variables, class attributes, "
"and module attributes, using the approach proposed in :pep:`526`.  Static"
" type analysis continued to grow in popularity."
msgstr ""

#: ../../peps/pep-0649.rst:303
msgid ""
"However, static type analysis users were increasingly frustrated by an "
"inconvenient problem: forward references.  In classic Python, if a class "
"C depends on a later-defined class D, it's normally not a problem, "
"because user code will usually wait until both are defined before trying "
"to use either. But annotations added a new complication, because they "
"were computed at the time the annotated object (function, class, or "
"module) was bound.  If methods on class C are annotated with type D, and "
"these annotation expressions are computed at the time that the method is "
"bound, D may not be defined yet. And if methods in D are also annotated "
"with type C, you now have an unresolvable circular reference problem."
msgstr ""

#: ../../peps/pep-0649.rst:316
msgid ""
"Initially, static type users worked around this problem by defining their"
" problematic annotations as strings. This worked because a string "
"containing the type hint was just as usable for the static type analysis "
"tool. And users of static type analysis tools rarely examine the "
"annotations at runtime, so this representation wasn't itself an "
"inconvenience.  But manually stringizing type hints was clumsy and error-"
"prone.  Also, code bases were adding more and more annotations, which "
"consumed more and more CPU time to create and bind."
msgstr ""

#: ../../peps/pep-0649.rst:327
msgid ""
"To solve these problems, the BDFL accepted :pep:`563`, which added a new "
"feature to Python 3.7: \"stringized annotations\". It was activated with "
"a future import::"
msgstr ""

#: ../../peps/pep-0649.rst:333
msgid ""
"Normally, annotation expressions were evaluated at the time the object "
"was bound, with their values being stored in the annotations dict.  When "
"stringized annotations were active, these semantics changed: instead, at "
"compile time, the compiler converted all annotations in that module into "
"string representations of their source code--thus, *automatically* "
"turning the users's annotations into strings, obviating the need to "
"*manually* stringize them as before.  :pep:`563` suggested users could "
"evaluate this string with ``eval`` if the actual value was needed at "
"runtime."
msgstr ""

#: ../../peps/pep-0649.rst:344
msgid ""
"(From here on out, this PEP will refer to the classic semantics of "
":pep:`3107` and :pep:`526`, where the values of annotation expressions "
"are computed at the time the object is bound, as *\"stock\" semantics,* "
"to differentiate them from the new :pep:`563` \"stringized\" annotation "
"semantics.)"
msgstr ""

#: ../../peps/pep-0649.rst:351
msgid "The Current State Of Annotation Use Cases"
msgstr ""

#: ../../peps/pep-0649.rst:353
msgid ""
"Although there are many specific use cases for annotations, annotation "
"users in the discussion around this PEP tended to fall into one of these "
"four categories."
msgstr ""

#: ../../peps/pep-0649.rst:359
msgid "Static typing users"
msgstr ""

#: ../../peps/pep-0649.rst:361
msgid ""
"Static typing users use annotations to add type information to their "
"code.  But they largely don't examine the annotations at runtime.  "
"Instead, they use static type analysis tools (mypy, pytype) to examine "
"their source tree and determine whether or not their code is using types "
"consistently. This is almost certainly the most popular use case for "
"annotations today."
msgstr ""

#: ../../peps/pep-0649.rst:369
msgid ""
"Many of the annotations use *type hints,* a la :pep:`484` (and many "
"subsequent PEPs).  Type hints are passive objects, mere representation of"
" type information; they don't do any actual work. Type hints are often "
"parameterized with other types or other type hints. Since they're "
"agnostic about what these actual values are, type hints work fine with "
"``ForwardRef`` proxy objects. Users of static type hints discovered that "
"extensive type hinting under stock semantics often created large-scale "
"circular reference and circular import problems that could be difficult "
"to solve.  :pep:`563` was designed specifically to solve this problem, "
"and the solution worked great for these users.  The difficulty of "
"rendering stringized annotations into real values largely didn't "
"inconvenience these users because of how infrequently they examine "
"annotations at runtime."
msgstr ""

#: ../../peps/pep-0649.rst:383
msgid ""
"Static typing users often combine :pep:`563` with the ``if "
"typing.TYPE_CHECKING`` idiom to prevent their type hints from being "
"loaded at runtime.  This means they often aren't able to evaluate their "
"stringized annotations and produce real values at runtime.  On the rare "
"occasion that they do examine annotations at runtime, they often forgo "
"``eval``, instead using lexical analysis directly on the stringized "
"annotations."
msgstr ""

#: ../../peps/pep-0649.rst:391
msgid ""
"Under this PEP, static typing users will probably prefer ``FORWARDREF`` "
"or ``SOURCE`` format."
msgstr ""

#: ../../peps/pep-0649.rst:396
#, fuzzy
msgid "Runtime annotation users"
msgstr "Anotações de funções"

#: ../../peps/pep-0649.rst:398
msgid ""
"Runtime annotation users use annotations as a means of expressing rich "
"metadata about their functions and classes, which they use as input to "
"runtime behavior.  Specific use cases include runtime type verification "
"(Pydantic) and glue logic to expose Python APIs in another domain "
"(FastAPI, Typer).  The annotations may or may not be type hints."
msgstr ""

#: ../../peps/pep-0649.rst:404
msgid ""
"As runtime annotation users examine annotations at runtime, they were "
"traditionally better served with stock semantics.  This use case is "
"largely incompatible with :pep:`563`, particularly with the ``if "
"typing.TYPE_CHECKING`` idiom."
msgstr ""

#: ../../peps/pep-0649.rst:409
msgid ""
"Under this PEP, runtime annotation users will most likely prefer "
"``VALUE`` format, though some (e.g. if they evaluate annotations eagerly "
"in a decorator and want to support forward references) may also use "
"``FORWARDREF`` format."
msgstr ""

#: ../../peps/pep-0649.rst:415
msgid "Wrappers"
msgstr ""

#: ../../peps/pep-0649.rst:417
msgid ""
"Wrappers are functions or classes that wrap user functions or classes and"
" add functionality.  Examples of this would be "
":func:`~dataclasses.dataclass`, :func:`functools.partial`, ``attrs``, and"
" ``wrapt``."
msgstr ""

#: ../../peps/pep-0649.rst:422
msgid ""
"Wrappers are a distinct subcategory of runtime annotation users. Although"
" they do use annotations at runtime, they may or may not actually examine"
" the annotations of the objects they wrap--it depends on the "
"functionality the wrapper provides.  As a rule they should propagate the "
"annotations of the wrapped object to the wrapper they create, although "
"it's possible they may modify those annotations."
msgstr ""

#: ../../peps/pep-0649.rst:429
msgid ""
"Wrappers were generally designed to work well under stock semantics. "
"Whether or not they work well under :pep:`563` semantics depends on the "
"degree to which they examine the wrapped object's annotations. Often "
"wrappers don't care about the value per se, only needing specific "
"information about the annotations.  Even so, :pep:`563` and the ``if "
"typing.TYPE_CHECKING`` idiom can make it difficult for wrappers to "
"reliably determine the information they need at runtime.  This is an "
"ongoing, chronic problem. Under this PEP, wrappers will probably prefer "
"``FORWARDREF`` format for their internal logic.  But the wrapped objects "
"need to support all formats for their users."
msgstr ""

#: ../../peps/pep-0649.rst:443
msgid "Documentation"
msgstr ""

#: ../../peps/pep-0649.rst:445
msgid ""
":pep:`563` stringized annotations were a boon for tools that mechanically"
" construct documentation."
msgstr ""

#: ../../peps/pep-0649.rst:448
msgid ""
"Stringized type hints make for excellent documentation; type hints as "
"expressed in source code are often succinct and readable.  However, at "
"runtime these same type hints can produce value at runtime whose repr is "
"a sprawling, nested, unreadable mess.  Thus documentation users were "
"well-served by :pep:`563` but poorly served with stock semantics."
msgstr ""

#: ../../peps/pep-0649.rst:454
msgid "Under this PEP, documentation users are expected to use ``SOURCE`` format."
msgstr ""

#: ../../peps/pep-0649.rst:458
msgid "Motivation For This PEP"
msgstr ""

#: ../../peps/pep-0649.rst:460
msgid ""
"Python's original semantics for annotations made its use for static type "
"analysis painful due to forward reference problems. :pep:`563` solved the"
" forward reference problem, and many static type analysis users became "
"happy early adopters of it. But its unconventional solution created new "
"problems for two of the above cited use cases: runtime annotation users, "
"and wrappers."
msgstr ""

#: ../../peps/pep-0649.rst:468
msgid ""
"First, stringized annotations didn't permit referencing local or free "
"variables, which meant many useful, reasonable approaches to creating "
"annotations were no longer viable.  This was particularly inconvenient "
"for decorators that wrap existing functions and classes, as these "
"decorators often use closures."
msgstr ""

#: ../../peps/pep-0649.rst:474
msgid ""
"Second, in order for ``eval`` to correctly look up globals in a "
"stringized annotation, you must first obtain a reference to the correct "
"module. But class objects don't retain a reference to their globals. "
":pep:`563` suggests looking up a class's module by name in "
"``sys.modules``—a surprising requirement for a language-level feature."
msgstr ""

#: ../../peps/pep-0649.rst:482
msgid ""
"Additionally, complex but legitimate constructions can make it difficult "
"to determine the correct globals and locals dicts to give to  ``eval`` to"
" properly evaluate a stringized annotation. Even worse, in some "
"situations it may simply be infeasible."
msgstr ""

#: ../../peps/pep-0649.rst:487
msgid ""
"For example, some libraries (e.g. ``typing.TypedDict``, "
":mod:`dataclasses`) wrap a user class, then merge all the annotations "
"from all that class's base classes together into one cumulative "
"annotations dict. If those annotations were stringized, calling ``eval`` "
"on them later may not work properly, because the globals dictionary used "
"for the ``eval`` will be the module where the *user class* was defined, "
"which may not be the same module where the *annotation* was defined.  "
"However, if the annotations were stringized because of forward-reference "
"problems, calling ``eval`` on them early may not work either, due to the "
"forward reference not being resolvable yet.  This has proved to be "
"difficult to reconcile; of the three bug reports linked to below, only "
"one has been marked as fixed."
msgstr ""

#: ../../peps/pep-0649.rst:501
msgid "https://github.com/python/cpython/issues/89687"
msgstr ""

#: ../../peps/pep-0649.rst:502
msgid "https://github.com/python/cpython/issues/85421"
msgstr ""

#: ../../peps/pep-0649.rst:503
msgid "https://github.com/python/cpython/issues/90531"
msgstr ""

#: ../../peps/pep-0649.rst:505
msgid ""
"Even with proper globals *and* locals, ``eval`` can be unreliable on "
"stringized annotations. ``eval`` can only succeed if all the symbols "
"referenced in an annotations are defined.  If a stringized annotation "
"refers to a mixture of defined and undefined symbols, a simple ``eval`` "
"of that string will fail.  This is a problem for libraries with that need"
" to examine the annotation, because they can't reliably convert these "
"stringized annotations into real values."
msgstr ""

#: ../../peps/pep-0649.rst:514
msgid ""
"Some libraries (e.g. :mod:`dataclasses`) solved this by foregoing real "
"values and performing lexical analysis of the stringized annotation, "
"which requires a lot of work to get right."
msgstr ""

#: ../../peps/pep-0649.rst:518
msgid ""
"Other libraries still suffer with this problem, which can produce "
"surprising runtime behavior. "
"https://github.com/python/cpython/issues/97727"
msgstr ""

#: ../../peps/pep-0649.rst:522
msgid ""
"Also, ``eval()`` is slow, and it isn't always available; it's sometimes "
"removed for space reasons on certain platforms. ``eval()`` on MicroPython"
" doesn't support the ``locals`` argument, which makes converting "
"stringized annotations into real values at runtime even harder."
msgstr ""

#: ../../peps/pep-0649.rst:528
msgid ""
"Finally, :pep:`563` requires Python implementations to stringize their "
"annotations.  This is surprising behavior—unprecedented for a language-"
"level feature, with a complicated implementation, that must be updated "
"whenever a new operator is added to the language."
msgstr ""

#: ../../peps/pep-0649.rst:534
msgid ""
"These problems motivated the research into finding a new approach to "
"solve the problems facing annotations users, resulting in this PEP."
msgstr ""

#: ../../peps/pep-0649.rst:541
msgid "Implementation"
msgstr ""

#: ../../peps/pep-0649.rst:544
msgid "Observed semantics for annotations expressions"
msgstr ""

#: ../../peps/pep-0649.rst:546
msgid ""
"For any object ``o`` that supports annotations, provided that all names "
"evaluated in the annotations expressions are bound before ``o`` is "
"defined and never subsequently rebound, ``o.__annotations__`` will "
"produce an identical annotations dict both when \"stock\" semantics are "
"active and when this PEP is active. In particular, name resolution will "
"be performed identically in both scenarios."
msgstr ""

#: ../../peps/pep-0649.rst:554
msgid ""
"When this PEP is active, the value of ``o.__annotations__`` won't be "
"calculated until the first time ``o.__annotations__`` itself is "
"evaluated.  All evaluation of the annotation expressions is delayed until"
" this moment, which also means that"
msgstr ""

#: ../../peps/pep-0649.rst:559
msgid ""
"names referenced in the annotations expressions will use their *current* "
"value at this moment, and"
msgstr ""

#: ../../peps/pep-0649.rst:561
msgid ""
"if evaluating the annotations expressions raises an exception, that "
"exception will be raised at this moment."
msgstr ""

#: ../../peps/pep-0649.rst:564
msgid ""
"Once ``o.__annotations__`` is successfully calculated for the first time,"
" this value is cached and will be returned by future requests for "
"``o.__annotations__``."
msgstr ""

#: ../../peps/pep-0649.rst:569
msgid "__annotate__ and __annotations__"
msgstr ""

#: ../../peps/pep-0649.rst:571
msgid ""
"Python supports annotations on three different types: functions, classes,"
" and modules.  This PEP modifies the semantics on all three of these "
"types in a similar way."
msgstr ""

#: ../../peps/pep-0649.rst:576
msgid ""
"First, this PEP adds a new \"dunder\" attribute, ``__annotate__``. "
"``__annotate__`` must be a \"data descriptor\", implementing all three "
"actions: get, set, and delete. The ``__annotate__`` attribute is always "
"defined, and may only be set to either ``None`` or to a callable. "
"(``__annotate__`` cannot be deleted.)  If an object has no annotations, "
"``__annotate__`` should be initialized to ``None``, rather than to a "
"function that returns an empty dict."
msgstr ""

#: ../../peps/pep-0649.rst:586
msgid ""
"The ``__annotate__`` data descriptor must have dedicated storage inside "
"the object to store the reference to its value. The location of this "
"storage at runtime is an implementation detail.  Even if it's visible to "
"Python code, it should still be considered an internal implementation "
"detail, and Python code should prefer to interact with it only via the "
"``__annotate__`` attribute."
msgstr ""

#: ../../peps/pep-0649.rst:594
msgid ""
"The callable stored in ``__annotate__`` must accept a single required "
"positional argument called ``format``, which will always be an ``int`` "
"(or a subclass of ``int``). It must either return a dict (or subclass of "
"dict) or raise ``NotImplementedError()``."
msgstr ""

#: ../../peps/pep-0649.rst:600
msgid ""
"Here's a formal definition of ``__annotate__``, as it will appear in the "
"\"Magic methods\" section of the Python Language Reference:"
msgstr ""

#: ../../peps/pep-0649.rst:604
msgid "``__annotate__(format: int) -> dict``"
msgstr ""

#: ../../peps/pep-0649.rst:606
msgid ""
"Returns a new dictionary object mapping attribute/parameter names to "
"their annotation values."
msgstr ""

#: ../../peps/pep-0649.rst:609
msgid ""
"Takes a ``format`` parameter specifying the format in which annotations "
"values should be provided.  Must be one of the following:"
msgstr ""

#: ../../peps/pep-0649.rst:613
msgid "``inspect.VALUE`` (equivalent to the ``int`` constant ``1``)"
msgstr ""

#: ../../peps/pep-0649.rst:615
msgid "Values are the result of evaluating the annotation expressions."
msgstr ""

#: ../../peps/pep-0649.rst:617
msgid "``inspect.FORWARDREF`` (equivalent to the ``int`` constant ``2``)"
msgstr ""

#: ../../peps/pep-0649.rst:619
msgid ""
"Values are real annotation values (as per ``inspect.VALUE`` format) for "
"defined values, and ``ForwardRef`` proxies for undefined values. Real "
"objects may be exposed to, or contain references to, ``ForwardRef`` proxy"
" objects."
msgstr ""

#: ../../peps/pep-0649.rst:624
msgid "``inspect.SOURCE`` (equivalent to the ``int`` constant ``3``)"
msgstr ""

#: ../../peps/pep-0649.rst:626
msgid ""
"Values are the text string of the annotation as it appears in the source "
"code.  May only be approximate; whitespace may be normalized, and "
"constant values may be optimized.  It's possible the exact values of "
"these strings could change in future version of Python."
msgstr ""

#: ../../peps/pep-0649.rst:632
msgid ""
"If an ``__annotate__`` function doesn't support the requested format, it "
"must raise ``NotImplementedError()``. ``__annotate__`` functions must "
"always support ``1`` (``inspect.VALUE``) format; they must not raise "
"``NotImplementedError()`` when called with ``format=1``."
msgstr ""

#: ../../peps/pep-0649.rst:638
msgid ""
"When called with ``format=1``, an ``__annotate__`` function may raise "
"``NameError``; it must not raise ``NameError`` when called requesting any"
" other format."
msgstr ""

#: ../../peps/pep-0649.rst:642
msgid ""
"If an object doesn't have any annotations, ``__annotate__`` should "
"preferably be set to ``None`` (it can't be deleted), rather than set to a"
" function that returns an empty dict."
msgstr ""

#: ../../peps/pep-0649.rst:646
msgid ""
"When the Python compiler compiles an object with annotations, it "
"simultaneously compiles the appropriate annotate function.  This "
"function, called with the single positional argument ``inspect.VALUE``, "
"computes and returns the annotations dict as defined on that object.  The"
" Python compiler and runtime work in concert to ensure that the function "
"is bound to the appropriate namespaces:"
msgstr ""

#: ../../peps/pep-0649.rst:655
msgid ""
"For functions and classes, the globals dictionary will be the module "
"where the object was defined.  If the object is itself a module, its "
"globals dictionary will be its own dict."
msgstr ""

#: ../../peps/pep-0649.rst:659
msgid ""
"For methods on classes, and for classes, the locals dictionary will be "
"the class dictionary."
msgstr ""

#: ../../peps/pep-0649.rst:661
msgid ""
"If the annotations refer to free variables, the closure will be the "
"appropriate closure tuple containing cells for free variables."
msgstr ""

#: ../../peps/pep-0649.rst:664
msgid ""
"Second, this PEP requires that the existing ``__annotations__`` must be a"
" \"data descriptor\", implementing all three actions: get, set, and "
"delete. ``__annotations__`` must also have its own internal storage it "
"uses to cache a reference to the annotations dict:"
msgstr ""

#: ../../peps/pep-0649.rst:670
msgid ""
"Class and module objects must cache the annotations dict in their "
"``__dict__``, using the key ``__annotations__``.  This is required for "
"backwards compatibility reasons."
msgstr ""

#: ../../peps/pep-0649.rst:674
msgid ""
"For function objects, storage for the annotations dict cache is an "
"implementation detail.  It's preferably internal to the function object "
"and not visible in Python."
msgstr ""

#: ../../peps/pep-0649.rst:678
msgid ""
"This PEP defines semantics on how ``__annotations__`` and "
"``__annotate__`` interact, for all three types that implement them. In "
"the following examples, ``fn`` represents a function, ``cls`` represents "
"a class, ``mod`` represents a module, and ``o`` represents an object of "
"any of these three types:"
msgstr ""

#: ../../peps/pep-0649.rst:684
msgid ""
"When ``o.__annotations__`` is evaluated, and the internal storage for "
"``o.__annotations__`` is unset, and ``o.__annotate__`` is set to a "
"callable, the getter for ``o.__annotations__`` calls "
"``o.__annotate__(1)``, then caches the result in its internal storage and"
" returns the result."
msgstr ""

#: ../../peps/pep-0649.rst:690
msgid ""
"To explicitly clarify one question that has come up multiple times: this "
"``o.__annotations__`` cache is the *only* caching mechanism defined in "
"this PEP.  There are *no other* caching mechanisms defined in this PEP.  "
"The ``__annotate__`` functions generated by the Python compiler "
"explicitly don't cache any of the values they compute."
msgstr ""

#: ../../peps/pep-0649.rst:696
msgid ""
"Setting ``o.__annotate__`` to a callable invalidates the cached "
"annotations dict."
msgstr ""

#: ../../peps/pep-0649.rst:699
msgid ""
"Setting ``o.__annotate__`` to ``None`` has no effect on the cached "
"annotations dict."
msgstr ""

#: ../../peps/pep-0649.rst:702
msgid ""
"Deleting ``o.__annotate__`` raises ``TypeError``. ``__annotate__`` must "
"always be set; this prevents unannotated subclasses from inheriting the "
"``__annotate__`` method of one of their base classes."
msgstr ""

#: ../../peps/pep-0649.rst:707
msgid ""
"Setting ``o.__annotations__`` to a legal value automatically sets "
"``o.__annotate__`` to ``None``."
msgstr ""

#: ../../peps/pep-0649.rst:710
msgid ""
"Setting ``cls.__annotations__`` or ``mod.__annotations__`` to ``None`` "
"otherwise works like any other attribute; the attribute is set to "
"``None``."
msgstr ""

#: ../../peps/pep-0649.rst:714
msgid ""
"Setting ``fn.__annotations__`` to ``None`` invalidates the cached "
"annotations dict.  If ``fn.__annotations__`` doesn't have a cached "
"annotations value, and ``fn.__annotate__`` is ``None``, the "
"``fn.__annotations__`` data descriptor creates, caches, and returns a new"
" empty dict.  (This is for backwards compatibility with :pep:`3107` "
"semantics.)"
msgstr ""

#: ../../peps/pep-0649.rst:722
msgid "Changes to allowable annotations syntax"
msgstr ""

#: ../../peps/pep-0649.rst:724
msgid ""
"``__annotate__`` now delays the evaluation of annotations until "
"``__annotations__`` is referenced in the future.  It also means "
"annotations are evaluated in a new function, rather than in the original "
"context where the object they were defined on was bound. There are four "
"operators with significant runtime side-effects that were permitted in "
"stock semantics, but are disallowed when ``from __future__ import "
"annotations`` is active, and will have to be disallowed when this PEP is "
"active:"
msgstr ""

#: ../../peps/pep-0649.rst:733
msgid "``:=``"
msgstr ""

#: ../../peps/pep-0649.rst:734
msgid "``yield``"
msgstr ""

#: ../../peps/pep-0649.rst:735
msgid "``yield from``"
msgstr ""

#: ../../peps/pep-0649.rst:736
msgid "``await``"
msgstr ""

#: ../../peps/pep-0649.rst:739
msgid "Changes to ``inspect.get_annotations`` and ``typing.get_type_hints``"
msgstr ""

#: ../../peps/pep-0649.rst:741
msgid ""
"(This PEP makes frequent reference to these two functions.  In the future"
" it will refer to them collectively as \"the helper functions\", as they "
"help user code work with annotations.)"
msgstr ""

#: ../../peps/pep-0649.rst:745
msgid ""
"These two functions extract and return the annotations from an object. "
"``inspect.get_annotations`` returns the annotations unchanged; for the "
"convenience of static typing users, ``typing.get_type_hints`` makes some "
"modifications to the annotations before it returns them."
msgstr ""

#: ../../peps/pep-0649.rst:750
msgid ""
"This PEP adds a new keyword-only parameter to these two functions, "
"``format``.  ``format`` specifies what format the values in the "
"annotations dict should be returned in. The ``format`` parameter on these"
" two functions accepts the same values as the ``format`` parameter on the"
" ``__annotate__`` magic method defined above; however, these ``format`` "
"parameters also have a default value of ``inspect.VALUE``."
msgstr ""

#: ../../peps/pep-0649.rst:758
msgid ""
"When either ``__annotations__`` or ``__annotate__`` is updated on an "
"object, the other of those two attributes is now out-of-date and should "
"also either be updated or deleted (set to ``None``, in the case of "
"``__annotate__`` which cannot be deleted).  In general, the semantics "
"established in the previous section ensure that this happens "
"automatically.  However, there's one case which for all practical "
"purposes can't be handled automatically: when the dict cached by "
"``o.__annotations__`` is itself modified, or when mutable values inside "
"that dict are modified."
msgstr ""

#: ../../peps/pep-0649.rst:767
msgid ""
"Since this can't be handled in code, it must be handled in documentation."
"  This PEP proposes amending the documentation for "
"``inspect.get_annotations`` (and similarly for ``typing.get_type_hints``)"
" as follows:"
msgstr ""

#: ../../peps/pep-0649.rst:772
msgid ""
"If you directly modify the ``__annotations__`` dict on an object, by "
"default these changes may not be reflected in the dictionary returned by "
"``inspect.get_annotations`` when requesting either ``SOURCE`` or "
"``FORWARDREF`` format on that object. Rather than modifying the "
"``__annotations__`` dict directly, consider replacing that object's "
"``__annotate__`` method with a function computing the annotations dict "
"with your desired values.  Failing that, it's best to overwrite the "
"object's ``__annotate__`` method with ``None`` to prevent "
"``inspect.get_annotations`` from generating stale results for ``SOURCE`` "
"and ``FORWARDREF`` formats."
msgstr ""

#: ../../peps/pep-0649.rst:786
msgid "The ``stringizer`` and the ``fake globals`` environment"
msgstr ""

#: ../../peps/pep-0649.rst:788
msgid ""
"As originally proposed, this PEP supported many runtime annotation user "
"use cases, and many static type user use cases. But this was insufficient"
"--this PEP could not be accepted until it satisfied *all* extant use "
"cases.  This became a longtime blocker of this PEP until Carl Meyer "
"proposed the \"stringizer\" and the \"fake globals\" environment as "
"described below.  These techniques allow this PEP to support both the "
"``FORWARDREF`` and ``SOURCE`` formats, ably satisfying all remaining uses"
" cases."
msgstr ""

#: ../../peps/pep-0649.rst:798
msgid ""
"In a nutshell, this technique involves running a Python-compiler-"
"generated ``__annotate__`` function in an exotic runtime environment.  "
"Its normal ``globals`` dict is replaced with what's called a \"fake "
"globals\" dict. A \"fake globals\" dict is a dict with one important "
"difference: every time you \"get\" a key from it that isn't mapped, it "
"creates, caches, and returns a new value for that key (as per the "
"``__missing__`` callback for a dictionary). That value is a an instance "
"of a novel type referred to as a \"stringizer\"."
msgstr ""

#: ../../peps/pep-0649.rst:809
msgid ""
"A \"stringizer\" is a Python class with highly unusual behavior. Every "
"stringizer is initialized with its \"value\", initially the name of the "
"missing key in the \"fake globals\" dict.  The stringizer then implements"
" every Python \"dunder\" method used to implement operators, and the "
"value returned by that method is a new stringizer whose value is a text "
"representation of that operation."
msgstr ""

#: ../../peps/pep-0649.rst:817
msgid ""
"When these stringizers are used in expressions, the result of the "
"expression is a new stringizer whose name textually represents that "
"expression.  For example, let's say you have a variable ``f``, which is a"
" reference to a stringizer initialized with the value ``'f'``.  Here are "
"some examples of operations you could perform on ``f`` and the values "
"they would return::"
msgstr ""

#: ../../peps/pep-0649.rst:832
msgid ""
"Bringing it all together: if we run a Python-generated ``__annotate__`` "
"function, but we replace its globals with a \"fake globals\" dict, all "
"undefined symbols it references will be replaced with stringizer proxy "
"objects representing those symbols, and any operations performed on those"
" proxies will in turn result in proxies representing that expression.  "
"This allows ``__annotate__`` to complete, and to return an annotations "
"dict, with stringizer instances standing in for names and entire "
"expressions that could not have otherwise been evaluated."
msgstr ""

#: ../../peps/pep-0649.rst:843
msgid ""
"In practice, the \"stringizer\" functionality will be implemented in the "
"``ForwardRef`` object currently defined in the ``typing`` module.  "
"``ForwardRef`` will be extended to implement all stringizer "
"functionality; it will also be extended to support evaluating the string "
"it contains, to produce the real value (assuming all symbols referenced "
"are defined).  This means the ``ForwardRef`` object will retain "
"references to the appropriate \"globals\", \"locals\", and even "
"\"closure\" information needed to evaluate the expression."
msgstr ""

#: ../../peps/pep-0649.rst:854
msgid ""
"This technique is the core of how ``inspect.get_annotations`` supports "
"``FORWARDREF`` and ``SOURCE`` formats.  Initially, "
"``inspect.get_annotations`` will call the object's ``__annotate__`` "
"method requesting the desired format. If that raises "
"``NotImplementedError``, ``inspect.get_annotations`` will construct a "
"\"fake globals\" environment, then call the object's ``__annotate__`` "
"method."
msgstr ""

#: ../../peps/pep-0649.rst:862
msgid ""
"``inspect.get_annotations`` produces ``SOURCE`` format by creating a new "
"empty \"fake globals\" dict, binding it to the object's ``__annotate__`` "
"method, calling that requesting ``VALUE`` format, and then extracting the"
" string \"value\" from each ``ForwardRef`` object in the resulting dict."
msgstr ""

#: ../../peps/pep-0649.rst:869
msgid ""
"``inspect.get_annotations`` produces ``FORWARDREF`` format by creating a "
"new empty \"fake globals\" dict, pre-populating it with the current "
"contents of the  ``__annotate__`` method's globals dict, binding the "
"\"fake globals\" dict to the object's ``__annotate__`` method, calling "
"that requesting ``VALUE`` format, and returning the result."
msgstr ""

#: ../../peps/pep-0649.rst:876
msgid ""
"This entire technique works because the ``__annotate__`` functions "
"generated by the compiler are controlled by Python itself, and are simple"
" and predictable.  They're effectively a single ``return`` statement, "
"computing and returning the annotations dict.  Since most operations "
"needed to compute an annotation are implemented in Python using dunder "
"methods, and the stringizer supports all the relevant dunder methods, "
"this approach is a reliable, practical solution."
msgstr ""

#: ../../peps/pep-0649.rst:885
msgid ""
"However, it's not reasonable to attempt this technique with just any "
"``__annotate__`` method.  This PEP assumes that third-party libraries may"
" implement their own ``__annotate__`` methods, and those functions would "
"almost certainly work incorrectly when run in this \"fake globals\" "
"environment. For that reason, this PEP allocates a flag on code objects, "
"one of the unused bits in ``co_flags``, to mean \"This code object can be"
" run in a 'fake globals' environment.\"  This makes the \"fake globals\" "
"environment strictly opt-in, and it's expected that only ``__annotate__``"
" methods generated by the Python compiler will set it."
msgstr ""

#: ../../peps/pep-0649.rst:897
msgid ""
"The weakness in this technique is in handling operators which don't "
"directly map to dunder methods on an object.  These are all operators "
"that implement some manner of flow control, either branching or "
"iteration:"
msgstr ""

#: ../../peps/pep-0649.rst:902
msgid "Short-circuiting ``or``"
msgstr ""

#: ../../peps/pep-0649.rst:903
msgid "Short-circuiting ``and``"
msgstr ""

#: ../../peps/pep-0649.rst:904
msgid "Ternary operator (the ``if`` / ``then`` operator)"
msgstr ""

#: ../../peps/pep-0649.rst:905
msgid "Generator expressions"
msgstr ""

#: ../../peps/pep-0649.rst:906
msgid "List / dict / set comprehensions"
msgstr ""

#: ../../peps/pep-0649.rst:907
msgid "Iterable unpacking"
msgstr ""

#: ../../peps/pep-0649.rst:909
msgid ""
"As a rule these techniques aren't used in annotations, so it doesn't pose"
" a problem in practice.  However, the recent addition of ``TypeVarTuple``"
" to Python does use iterable unpacking.  The dunder methods involved "
"(``__iter__`` and ``__next__``) don't permit distinguishing between "
"iteration use cases; in order to correctly detect which use case was "
"involved, mere \"fake globals\" and a \"stringizer\" wouldn't be "
"sufficient; this would require a custom bytecode interpreter designed "
"specifically around producing ``SOURCE`` and ``FORWARDREF`` formats."
msgstr ""

#: ../../peps/pep-0649.rst:921
msgid ""
"Thankfully there's a shortcut that will work fine: the stringizer will "
"simply assume that when its iteration dunder methods are called, it's in "
"service of iterator unpacking being performed by ``TypeVarTuple``. It "
"will hard-code this behavior.  This means no other technique using "
"iteration will work, but in practice this won't inconvenience real-world "
"use cases."
msgstr ""

#: ../../peps/pep-0649.rst:930
msgid ""
"Finally, note that the \"fake globals\" environment will also require "
"constructing a matching \"fake locals\" dictionary, which for "
"``FORWARDREF`` format will be pre-populated with the relevant locals "
"dict.  The \"fake globals\" environment will also have to create a fake "
"\"closure\", a tuple of ``ForwardRef`` objects pre-created with the names"
" of the free variables referenced by the ``__annotate__`` method."
msgstr ""

#: ../../peps/pep-0649.rst:939
msgid ""
"``ForwardRef`` proxies created from ``__annotate__`` methods that "
"reference free variables will map the names and closure values of those "
"free variables into the locals dictionary, to ensure that ``eval`` uses "
"the correct values for those names."
msgstr ""

#: ../../peps/pep-0649.rst:947
msgid "Compiler-generated  ``__annotate__`` functions"
msgstr ""

#: ../../peps/pep-0649.rst:949
msgid ""
"As mentioned in the previous section, the ``__annotate__`` functions "
"generated by the compiler are simple.  They're mainly a single ``return``"
" statement, computing and returning the annotations dict."
msgstr ""

#: ../../peps/pep-0649.rst:954
msgid ""
"However, the protocol for ``inspect.get_annotations`` to request either "
"``FORWARDREF`` or ``SOURCE`` format requires first asking the "
"``__annotate__`` method to produce it.  ``__annotate__`` methods "
"generated by the Python compiler won't support either of these formats "
"and will raise ``NotImplementedError()``."
msgstr ""

#: ../../peps/pep-0649.rst:963
msgid "Third-party ``__annotate__`` functions"
msgstr ""

#: ../../peps/pep-0649.rst:965
msgid ""
"Third-party classes and functions will likely need to implement their own"
" ``__annotate__`` methods, so that downstream users of those objects can "
"take full advantage of annotations. In particular, wrappers will likely "
"need to transform the annotation dicts produced by the wrapped object: "
"adding, removing, or modifying the dictionary in some way."
msgstr ""

#: ../../peps/pep-0649.rst:973
msgid ""
"Most of the time, third-party code will implement their ``__annotate__`` "
"methods by calling ``inspect.get_annotations`` on some existing upstream "
"object.  For example, wrappers will likely request the annotations dict "
"for their wrapped object, in the format that was requested from them, "
"then modify the returned annotations dict as appropriate and return that."
"  This allows third-party code to leverage the \"fake globals\" technique"
" without having to understand or participate in it."
msgstr ""

#: ../../peps/pep-0649.rst:984
msgid ""
"Third-party libraries that support both pre- and post-PEP-649 versions of"
" Python will have to innovate their own best practices on how to support "
"both. One sensible approach would be for their wrapper to always support "
"``__annotate__``, then call it requesting ``VALUE`` format and store the "
"result as the ``__annotations__`` on their wrapper object. This would "
"support pre-649 Python semantics, and be forward-compatible with post-649"
" semantics."
msgstr ""

#: ../../peps/pep-0649.rst:997
msgid "Pseudocode"
msgstr ""

#: ../../peps/pep-0649.rst:999
msgid "Here's high-level pseudocode for ``inspect.get_annotations``::"
msgstr ""

#: ../../peps/pep-0649.rst:1023
msgid ""
"Here's what a Python compiler-generated ``__annotate__`` method might "
"look like if it was written in Python::"
msgstr ""

#: ../../peps/pep-0649.rst:1031
msgid ""
"Here's how a third-party wrapper class might implement ``__annotate__``."
"  In this example, the wrapper works like ``functools.partial``, pre-"
"binding one parameter of the wrapped callable, which for simplicity must "
"be named ``arg``::"
msgstr ""

#: ../../peps/pep-0649.rst:1045
msgid "Other modifications to the Python runtime"
msgstr ""

#: ../../peps/pep-0649.rst:1047
msgid ""
"This PEP does not dictate exactly how it should be implemented; that is "
"left up to the language implementation maintainers.  However, the best "
"implementation of this PEP may require adding additional information to "
"existing Python objects, which is implicitly condoned by the acceptance "
"of this PEP."
msgstr ""

#: ../../peps/pep-0649.rst:1054
msgid ""
"For example, it may be necessary to add a ``__globals__`` attribute to "
"class objects, so that the ``__annotate__`` function for that class can "
"be lazily bound, only on demand.  Also, ``__annotate__`` functions "
"defined on methods defined in a class may need to retain a reference to "
"the class's ``__dict__``, in order to correctly evaluate names bound in "
"that class.  It's expected that the CPython implementation of this PEP "
"will include both those new attributes."
msgstr ""

#: ../../peps/pep-0649.rst:1064
msgid ""
"All such new information added to existing Python objects should be done "
"with \"dunder\" attributes, as they will of course be implementation "
"details."
msgstr ""

#: ../../peps/pep-0649.rst:1070
msgid "Interactive REPL Shell"
msgstr ""

#: ../../peps/pep-0649.rst:1072
msgid ""
"The semantics established in this PEP also hold true when executing code "
"in Python's interactive REPL shell, except for module annotations in the "
"interactive module (``__main__``) itself.  Since that module is never "
"\"finished\", there's no specific point where we can compile the "
"``__annotate__`` function."
msgstr ""

#: ../../peps/pep-0649.rst:1078
msgid ""
"For the sake of simplicity, in this case we forego delayed evaluation. "
"Module-level annotations in the REPL shell will continue to work exactly "
"as they do with \"stock semantics\", evaluating immediately and setting "
"the result directly inside the ``__annotations__`` dict."
msgstr ""

#: ../../peps/pep-0649.rst:1085
msgid "Annotations On Local Variables Inside Functions"
msgstr ""

#: ../../peps/pep-0649.rst:1087
msgid ""
"Python supports syntax for local variable annotations inside functions. "
"However, these annotations have no runtime effect--they're discarded at "
"compile-time.  Therefore, this PEP doesn't need to do anything to support"
" them, the same as stock semantics and :pep:`563`."
msgstr ""

#: ../../peps/pep-0649.rst:1096
#, fuzzy
msgid "Prototype"
msgstr "Tipo"

#: ../../peps/pep-0649.rst:1098
msgid "The original prototype implementation of this PEP can be found here:"
msgstr ""

#: ../../peps/pep-0649.rst:1100
msgid "https://github.com/larryhastings/co_annotations/"
msgstr ""

#: ../../peps/pep-0649.rst:1102
msgid ""
"As of this writing, the implementation is severely out of date; it's "
"based on Python 3.10 and implements the semantics of the first draft of "
"this PEP, from early 2021.  It will be updated shortly."
msgstr ""

#: ../../peps/pep-0649.rst:1110
msgid "Performance Comparison"
msgstr ""

#: ../../peps/pep-0649.rst:1112
msgid ""
"Performance with this PEP is generally favorable.  There are four "
"scenarios to consider:"
msgstr ""

#: ../../peps/pep-0649.rst:1115
msgid "the runtime cost when annotations aren't defined,"
msgstr ""

#: ../../peps/pep-0649.rst:1116
msgid "the runtime cost when annotations are defined but *not* referenced, and"
msgstr ""

#: ../../peps/pep-0649.rst:1117
msgid "the runtime cost when annotations are defined and referenced as objects."
msgstr ""

#: ../../peps/pep-0649.rst:1118
msgid "the runtime cost when annotations are defined and referenced as strings."
msgstr ""

#: ../../peps/pep-0649.rst:1120
msgid ""
"We'll examine each of these scenarios in the context of all three "
"semantics for annotations: stock, :pep:`563`, and this PEP."
msgstr ""

#: ../../peps/pep-0649.rst:1123
msgid ""
"When there are no annotations, all three semantics have the same runtime "
"cost: zero. No annotations dict is created and no code is generated for "
"it.  This requires no runtime processor time and consumes no memory."
msgstr ""

#: ../../peps/pep-0649.rst:1128
msgid ""
"When annotations are defined but not referenced, the runtime cost of "
"Python with this PEP is roughly the same as :pep:`563`, and improved over"
" stock.  The specifics depend on the object being annotated:"
msgstr ""

#: ../../peps/pep-0649.rst:1133
msgid ""
"With stock semantics, the annotations dict is always built, and set as an"
" attribute of the object being annotated."
msgstr ""

#: ../../peps/pep-0649.rst:1135
msgid ""
"In :pep:`563` semantics, for function objects, a precompiled constant (a "
"specially constructed tuple) is set as an attribute of the function.  For"
" class and module objects, the annotations dict is always built and set "
"as an attribute of the class or module."
msgstr ""

#: ../../peps/pep-0649.rst:1139
msgid ""
"With this PEP, a single object is set as an attribute of the object being"
" annotated.  Most of the time, this object is a constant (a code object),"
" but when the annotations require a class namespace or closure, this "
"object will be a tuple constructed at binding time."
msgstr ""

#: ../../peps/pep-0649.rst:1145
msgid ""
"When annotations are both defined and referenced as objects, code using "
"this PEP should be much faster than :pep:`563`, and be as fast or faster "
"than stock.  :pep:`563` semantics requires invoking ``eval()`` for every "
"value inside an annotations dict which is enormously slow. And the "
"implementation of this PEP generates measurably more efficient bytecode "
"for class and module annotations than stock semantics; for function "
"annotations, this PEP and stock semantics should be about the same speed."
msgstr ""

#: ../../peps/pep-0649.rst:1154
msgid ""
"The one case where this PEP will be noticeably slower than :pep:`563` is "
"when annotations are requested as strings; it's hard to beat \"they are "
"already strings.\" But stringified annotations are intended for online "
"documentation use cases, where performance is less likely to be a key "
"factor."
msgstr ""

#: ../../peps/pep-0649.rst:1159
msgid ""
"Memory use should also be comparable in all three scenarios across all "
"three semantic contexts.  In the first and third scenarios, memory usage "
"should be roughly equivalent in all cases. In the second scenario, when "
"annotations are defined but not referenced, using this PEP's semantics "
"will mean the function/class/module will store one unused code object "
"(possibly bound to an unused function object); with the other two "
"semantics, they'll store one unused dictionary or constant tuple."
msgstr ""

#: ../../peps/pep-0649.rst:1171
msgid "Backwards Compatibility"
msgstr ""

#: ../../peps/pep-0649.rst:1174
msgid "Backwards Compatibility With Stock Semantics"
msgstr ""

#: ../../peps/pep-0649.rst:1176
msgid ""
"This PEP preserves nearly all existing behavior of annotations from stock"
" semantics:"
msgstr ""

#: ../../peps/pep-0649.rst:1179
msgid ""
"The format of the annotations dict stored in the ``__annotations__`` "
"attribute is unchanged. Annotations dicts contain real values, not "
"strings as per :pep:`563`."
msgstr ""

#: ../../peps/pep-0649.rst:1183
msgid "Annotations dicts are mutable, and any changes to them are preserved."
msgstr ""

#: ../../peps/pep-0649.rst:1185
msgid ""
"The ``__annotations__`` attribute can be explicitly set, and any legal "
"value set this way will be preserved."
msgstr ""

#: ../../peps/pep-0649.rst:1187
msgid ""
"The ``__annotations__`` attribute can be deleted using the ``del`` "
"statement."
msgstr ""

#: ../../peps/pep-0649.rst:1190
msgid ""
"Most code that works with stock semantics should continue to work when "
"this PEP is active without any modification necessary.  But there are "
"exceptions, as follows."
msgstr ""

#: ../../peps/pep-0649.rst:1195
msgid ""
"First, there's a well-known idiom for accessing class annotations which "
"may not work correctly when this PEP is active.  The original "
"implementation of class annotations had what can only be called a bug: if"
" a class didn't define any annotations of its own, but one of its base "
"classes did define annotations, the class would \"inherit\" those "
"annotations.  This behavior was never desirable, so user code found a "
"workaround: instead of accessing the annotations on the class directly "
"via ``cls.__annotations__``, code would access the class's annotations "
"via its dict as in ``cls.__dict__.get(\"__annotations__\", {})``.  This "
"idiom worked because classes stored their annotations in their "
"``__dict__``, and accessing them this way avoided the lookups in the base"
" classes.  The technique relied on implementation details of CPython, so "
"it was never supported behavior--though it was necessary. However, when "
"this PEP is active, a class may have annotations defined but hasn't yet "
"called ``__annotate__`` and cached the result, in which case this "
"approach would lead to mistakenly assuming the class didn't have "
"annotations. In any case, the bug was fixed as of Python 3.10, and the "
"idiom should no longer be used.  Also as of Python 3.10, there's an "
"`Annotations HOWTO <https://docs.python.org/3/howto/annotations.html>`_ "
"that defines best practices for working with annotations; code that "
"follows these guidelines will work correctly even when this PEP is "
"active, because it suggests using different approaches to get annotations"
" from class objects based on the Python version the code runs under."
msgstr ""

#: ../../peps/pep-0649.rst:1229
msgid ""
"Since delaying the evaluation of annotations until they are introspected "
"changes the semantics of the language, it's observable from within the "
"language.  Therefore it's *possible* to write code that behaves "
"differently based on whether annotations are evaluated at binding time or"
" at access time, e.g."
msgstr ""

#: ../../peps/pep-0649.rst:1242
msgid ""
"This will print ``<class 'str'>`` with stock semantics and ``<class "
"'int'>`` when this PEP is active.  This is therefore a backwards-"
"incompatible change.  However, this example is poor programming style, so"
" this change seems acceptable."
msgstr ""

#: ../../peps/pep-0649.rst:1249
msgid ""
"There are two uncommon interactions possible with class and module "
"annotations that work with stock semantics that would no longer work when"
" this PEP was active. These two interactions would have to be prohibited."
"  The good news is, neither is common, and neither is considered good "
"practice.  In fact, they're rarely seen outside of Python's own "
"regression test suite.  They are:"
msgstr ""

#: ../../peps/pep-0649.rst:1257
msgid ""
"*Code that sets annotations on module or class attributes from inside any"
" kind of flow control statement.*   It's currently possible to set module"
" and class attributes with annotations inside an ``if`` or ``try`` "
"statement, and it works as one would expect.  It's untenable to support "
"this behavior when this PEP is active."
msgstr ""

#: ../../peps/pep-0649.rst:1263
msgid ""
"*Code in module or class scope that references or modifies the local* "
"``__annotations__`` *dict directly.*  Currently, when setting annotations"
" on module or class attributes, the generated code simply creates a local"
" ``__annotations__`` dict, then adds mappings to it as needed.  It's "
"possible for user code to directly modify this dict, though this doesn't "
"seem to be an intentional feature.  Although it would be possible to "
"support this after a fashion once this PEP was active, the semantics "
"would likely be surprising and wouldn't make anyone happy."
msgstr ""

#: ../../peps/pep-0649.rst:1273
msgid ""
"Note that these are both also pain points for static type checkers, and "
"are unsupported by those tools.  It seems reasonable to declare that both"
" are at the very least unsupported, and their use results in undefined "
"behavior.  It might be worth making a small effort to explicitly prohibit"
" them with compile-time checks."
msgstr ""

#: ../../peps/pep-0649.rst:1279
msgid ""
"Finally, if this PEP is active, annotation values shouldn't use the ``if "
"/ else`` ternary operator.  Although this will work correctly when "
"accessing ``o.__annotations__`` or requesting ``inspect.VALUE`` from a "
"helper function, the boolean expression may not compute correctly with "
"``inspect.FORWARDREF`` when some names are defined, and would be far less"
" correct with ``inspect.SOURCE``."
msgstr ""

#: ../../peps/pep-0649.rst:1289
msgid "Backwards Compatibility With PEP 563 Semantics"
msgstr ""

#: ../../peps/pep-0649.rst:1291
msgid ""
":pep:`563` changed the semantics of annotations.  When its semantics are "
"active, annotations must assume they will be evaluated in *module-level* "
"or *class-level* scope.  They may no longer refer directly to local "
"variables in the current function or an enclosing function. This PEP "
"removes that restriction, and annotations may refer any local variable."
msgstr ""

#: ../../peps/pep-0649.rst:1298
msgid ""
":pep:`563` requires using ``eval`` (or a helper function like "
"``typing.get_type_hints`` or ``inspect.get_annotations`` that uses "
"``eval`` for you) to convert stringized annotations into their \"real\" "
"values.  Existing code that activates stringized annotations, and calls "
"``eval()`` directly to convert the strings back into real values, can "
"simply remove the ``eval()`` call. Existing code using a helper function "
"would continue to work unchanged, though use of those functions may "
"become optional."
msgstr ""

#: ../../peps/pep-0649.rst:1307
msgid ""
"Static typing users often have modules that only contain inert type hint "
"definitions--but no live code.  These modules are only needed when "
"running static type checking; they aren't used at runtime.  But under "
"stock semantics, these modules have to be imported in order for the "
"runtime to evaluate and compute the annotations.  Meanwhile, these "
"modules often caused circular import problems that could be difficult or "
"even impossible to solve.  :pep:`563` allowed users to solve these "
"circular import problems by doing two things.  First, they activated "
":pep:`563` in their modules, which meant annotations were constant "
"strings, and didn't require the real symbols to be defined in order for "
"the annotations to be computable. Second, this permitted users to only "
"import the problematic modules in an ``if typing.TYPE_CHECKING`` block.  "
"This allowed the static type checkers to import the modules and the type "
"definitions inside, but they wouldn't be imported at runtime. So far, "
"this approach will work unchanged when this PEP is active; ``if "
"typing.TYPE_CHECKING`` is supported behavior."
msgstr ""

#: ../../peps/pep-0649.rst:1326
msgid ""
"However, some codebases actually *did* examine their annotations at "
"runtime, even when using the ``if typing.TYPE_CHECKING`` technique and "
"not importing definitions used in their annotations. These codebases "
"examined the annotation strings *without evaluating them,* instead "
"relying on identity checks or simple lexical analysis on the strings."
msgstr ""

#: ../../peps/pep-0649.rst:1333
msgid ""
"This PEP supports these techniques too.  But users will need to port "
"their code to it.  First, user code will need to use "
"``inspect.get_annotations`` or ``typing.get_type_hints`` to access the "
"annotations; they won't be able to simply get the ``__annotations__`` "
"attribute from their object.  Second, they will need to specify either "
"``inspect.FORWARDREF`` or ``inspect.SOURCE`` for the ``format`` when "
"calling that function.  This means the helper function can succeed in "
"producing the annotations dict, even when not all the symbols are "
"defined.  Code expecting stringized annotations should work unmodified "
"with ``inspect.SOURCE`` formatted annotations dicts; however, users "
"should consider switching to ``inspect.FORWARDREF``, as it may make their"
" analysis easier."
msgstr ""

#: ../../peps/pep-0649.rst:1347
msgid ""
"Similarly, :pep:`563` permitted use of class decorators on annotated "
"classes in a way that hadn't previously been possible. Some class "
"decorators (e.g. :mod:`dataclasses`) examine the annotations on the "
"class.  Because class decorators using the ``@`` decorator syntax are run"
" before the class name is bound, they can cause unsolvable circular-"
"definition problems. If you annotate attributes of a class with "
"references to the class itself, or annotate attributes in multiple "
"classes  with circular references to each other, you can't decorate those"
" classes with the ``@`` decorator syntax using decorators that examine "
"the annotations.  :pep:`563` allowed this to work, as long as the "
"decorators examined the strings lexically and didn't use ``eval`` to "
"evaluate them (or handled the ``NameError`` with further workarounds).  "
"When this PEP is active, decorators will be able to compute the "
"annotations dict in ``inspect.SOURCE`` or ``inspect.FORWARDREF`` format "
"using the helper functions.  This will permit them to analyze annotations"
" containing undefined symbols, in the format they prefer."
msgstr ""

#: ../../peps/pep-0649.rst:1365
msgid ""
"Early adopters of :pep:`563` discovered that \"stringized\" annotations "
"were useful for automatically-generated documentation. Users experimented"
" with this use case, and Python's ``pydoc`` has expressed some interest "
"in this technique.  This PEP supports this use case; the code generating "
"the documentation will have to be updated to use a helper function to "
"access the annotations in ``inspect.SOURCE`` format."
msgstr ""

#: ../../peps/pep-0649.rst:1373
msgid ""
"Finally, the warnings about using the ``if / else`` ternary operator in "
"annotations apply equally to users of :pep:`563`. It currently works for "
"them, but could produce incorrect results when requesting some formats "
"from the helper functions."
msgstr ""

#: ../../peps/pep-0649.rst:1378
msgid ""
"If this PEP is accepted, :pep:`563` will be deprecated and eventually "
"removed.  To facilitate this transition for early adopters of :pep:`563`,"
" who now depend on its semantics, ``inspect.get_annotations`` and "
"``typing.get_type_hints`` will implement a special affordance."
msgstr ""

#: ../../peps/pep-0649.rst:1384
msgid ""
"The Python compiler won't generate annotation code objects for objects "
"defined in a module where :pep:`563` semantics are active, even if this "
"PEP is accepted.  So, under normal circumstances, requesting "
"``inspect.SOURCE`` format from a helper function would return an empty "
"dict.  As an affordance, to facilitate the transition, if the helper "
"functions detect that an object was defined in a module with :pep:`563` "
"active, and the user requests ``inspect.SOURCE`` format, they'll return "
"the current value of the ``__annotations__`` dict, which in this case "
"will be the stringized annotations.  This will allow :pep:`563` users who"
" lexically analyze stringized annotations to immediately change over to "
"requesting ``inspect.SOURCE`` format from the helper functions, which "
"will hopefully smooth their transition away from :pep:`563`."
msgstr ""

#: ../../peps/pep-0649.rst:1402
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/pep-0649.rst:1405
msgid "\"Just store the strings\""
msgstr ""

#: ../../peps/pep-0649.rst:1407
msgid ""
"One proposed idea for supporting ``SOURCE`` format was for the Python "
"compiler to emit the actual source code for the annotation values "
"somewhere, and to furnish that when the user requested ``SOURCE`` format."
msgstr ""

#: ../../peps/pep-0649.rst:1412
msgid ""
"This idea wasn't rejected so much as categorized as \"not yet\".  We "
"already know we need to support ``FORWARDREF`` format, and that technique"
" can be adapted to support ``SOURCE`` format in just a few lines.  There "
"are many unanswered questions about this approach:"
msgstr ""

#: ../../peps/pep-0649.rst:1418
msgid ""
"Where would we store the strings?  Would they always be loaded when the "
"annotated object was created, or would they be lazy-loaded on demand?  If"
" so, how would the lazy-loading work?"
msgstr ""

#: ../../peps/pep-0649.rst:1422
msgid ""
"Would the \"source code\" include the newlines and comments of the "
"original?  Would it preserve all whitespace, including indents and extra "
"spaces used purely for formatting?"
msgstr ""

#: ../../peps/pep-0649.rst:1427
msgid ""
"It's possible we'll revisit this topic in the future, if improving the "
"fidelity of ``SOURCE`` values to the original source code is judged "
"sufficiently important."
msgstr ""

#: ../../peps/pep-0649.rst:1434
msgid "Acknowledgements"
msgstr ""

#: ../../peps/pep-0649.rst:1436
msgid ""
"Thanks to Carl Meyer, Barry Warsaw, Eric V. Smith, Mark Shannon, Jelle "
"Ziljstra, and Guido van Rossum for ongoing feedback and encouragement."
msgstr ""

#: ../../peps/pep-0649.rst:1440
msgid ""
"Particular thanks to several individuals who contributed key ideas that "
"became some of the best aspects of this proposal:"
msgstr ""

#: ../../peps/pep-0649.rst:1443
msgid ""
"Carl Meyer suggested the \"stringizer\" technique that made "
"``FORWARDREF`` and ``SOURCE`` formats possible, which allowed making "
"forward progress on this PEP possible after a year of languishing due to "
"seemingly-unfixable problems. He also suggested the affordance for "
":pep:`563` users where ``inspect.SOURCE`` will return the stringized "
"annotations, and many more suggestions besides.  Carl was also the "
"primary correspondent in private email threads discussing this PEP, and "
"was a tireless resource and voice of sanity.  This PEP would almost "
"certainly not have been accepted it were it not for Carl's contributions."
msgstr ""

#: ../../peps/pep-0649.rst:1454
msgid ""
"Mark Shannon suggested building the entire annotations dict inside a "
"single code object, and only binding it to a function on demand."
msgstr ""

#: ../../peps/pep-0649.rst:1457
msgid ""
"Guido van Rossum suggested that ``__annotate__`` functions should "
"duplicate the name visibility rules of annotations under \"stock\" "
"semantics."
msgstr ""

#: ../../peps/pep-0649.rst:1460
msgid "Jelle Zijlstra contributed not only feedback--but code!"
msgstr ""

#: ../../peps/pep-0649.rst:1465
msgid "References"
msgstr ""

#: ../../peps/pep-0649.rst:1467
msgid "https://github.com/larryhastings/co_annotations/issues"
msgstr ""

#: ../../peps/pep-0649.rst:1469
msgid "https://discuss.python.org/t/two-polls-on-how-to-revise-pep-649/23628"
msgstr ""

#: ../../peps/pep-0649.rst:1471
msgid ""
"https://discuss.python.org/t/a-massive-pep-649-update-with-some-major-"
"course-corrections/25672"
msgstr ""

#: ../../peps/pep-0649.rst:1477
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-0649.rst:1479
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

#~ msgid "Draft"
#~ msgstr ""

#~ msgid "11-Jan-2021, 11-Apr-2021"
#~ msgstr ""

#~ msgid ""
#~ "As of Python 3.9, Python supports "
#~ "two different behaviors for annotations:"
#~ msgstr ""

#~ msgid ""
#~ "original or \"stock\" Python semantics, "
#~ "in which annotations are evaluated at"
#~ " the time they are bound, and"
#~ msgstr ""

#~ msgid ""
#~ ":pep:`563` semantics, currently enabled "
#~ "per-module by ``from __future__ import "
#~ "annotations``, in which annotations are "
#~ "converted back into strings and must "
#~ "be reparsed and executed by ``eval()``"
#~ " to be used."
#~ msgstr ""

#~ msgid ""
#~ "Original Python semantics created a "
#~ "circular references problem for static "
#~ "typing analysis.  :pep:`563` solved that "
#~ "problem--but its novel semantics "
#~ "introduced new problems, including its "
#~ "restriction that annotations can only "
#~ "reference names at module-level scope."
#~ msgstr ""

#~ msgid ""
#~ "This PEP proposes a third way that"
#~ " embodies the best of both previous"
#~ " approaches.  It solves the same "
#~ "circular reference problems solved by "
#~ ":pep:`563`, while otherwise preserving "
#~ "Python's original annotation semantics, "
#~ "including allowing annotations to refer "
#~ "to local and class variables."
#~ msgstr ""

#~ msgid ""
#~ "In this new approach, the code to"
#~ " generate the annotations dict is "
#~ "written to its own function which "
#~ "computes and returns the annotations "
#~ "dict.  Then, ``__annotations__`` is a "
#~ "\"data descriptor\" which calls this "
#~ "annotation function once and retains the"
#~ " result.  This delays the evaluation "
#~ "of annotations expressions until the "
#~ "annotations are examined, at which point"
#~ " all circular references have likely "
#~ "been resolved.  And if the annotations"
#~ " are never examined, the function is"
#~ " never called and the annotations are"
#~ " never computed."
#~ msgstr ""

#~ msgid ""
#~ "Annotations defined using this PEP's "
#~ "semantics have the same visibility into"
#~ " the symbol table as annotations "
#~ "under \"stock\" semantics--any name "
#~ "visible to an annotation in Python "
#~ "3.9 is visible to an annotation "
#~ "under this PEP.  In addition, "
#~ "annotations under this PEP can refer "
#~ "to names defined *after* the annotation"
#~ " is defined, as long as the "
#~ "name is defined in a scope visible"
#~ " to the annotation. Specifically, when "
#~ "this PEP is active:"
#~ msgstr ""

#~ msgid ""
#~ "An annotation can refer to a local"
#~ " variable defined in the current "
#~ "function scope."
#~ msgstr ""

#~ msgid ""
#~ "An annotation can refer to a local"
#~ " variable defined in an enclosing "
#~ "function scope."
#~ msgstr ""

#~ msgid ""
#~ "An annotation can refer to a class"
#~ " variable defined in the current "
#~ "class scope."
#~ msgstr ""

#~ msgid "An annotation can refer to a global variable."
#~ msgstr ""

#~ msgid ""
#~ "And in all four of these cases,"
#~ " the variable referenced by the "
#~ "annotation needn't be defined at the "
#~ "time the annotation is defined--it "
#~ "can be defined afterwards.  The only "
#~ "restriction is that the name or "
#~ "variable be defined before the "
#~ "annotation is *evaluated.*"
#~ msgstr ""

#~ msgid ""
#~ "If accepted, these new semantics for "
#~ "annotations would initially be gated "
#~ "behind ``from __future__ import "
#~ "co_annotations``. However, these semantics "
#~ "would eventually be promoted to be "
#~ "Python's default behavior.  Thus this "
#~ "PEP would *supersede* :pep:`563`, and "
#~ ":pep:`563`'s behavior would be deprecated "
#~ "and eventually removed."
#~ msgstr ""

#~ msgid ""
#~ "The code presented in this section "
#~ "is simplified for clarity.  The "
#~ "intention is to communicate the high-"
#~ "level concepts involved without getting "
#~ "lost in with the details. The "
#~ "actual details are often quite "
#~ "different.  See the Implementation_ section"
#~ " later in this PEP for a much"
#~ " more accurate description of how "
#~ "this PEP works."
#~ msgstr ""

#~ msgid ""
#~ "The default behavior in Python 3.9 "
#~ "is to evaluate the expressions for "
#~ "the annotations, and build the "
#~ "annotations dict, at the time the "
#~ "function, class, or module is bound."
#~ "  At runtime the above code actually"
#~ " works something like this:"
#~ msgstr ""

#~ msgid ""
#~ ":pep:`563`'s solution is to decompile "
#~ "the expressions back into strings, and"
#~ " store those *strings* in the "
#~ "annotations dict. The equivalent runtime "
#~ "code would look something like this:"
#~ msgstr ""

#~ msgid ""
#~ "This code now runs successfully.  "
#~ "However, ``foo_y_type`` is no longer a"
#~ " reference to ``MyType``, it is the"
#~ " *string* ``'MyType'``.  The code would "
#~ "have to be further modified to "
#~ "call ``eval()`` or ``typing.get_type_hints()`` "
#~ "to convert the string into a "
#~ "useful reference to the actual "
#~ "``MyType`` object."
#~ msgstr ""

#~ msgid ""
#~ "The important change is that the "
#~ "code constructing the annotations dict "
#~ "now lives in a function—here, called "
#~ "``foo_annotations_fn()``.  But this function "
#~ "isn't called until we ask for the"
#~ " value of ``foo.__annotations__``, and we"
#~ " don't do that until *after* the "
#~ "definition of ``MyType``. So this code"
#~ " also runs successfully, and ``foo_y_type``"
#~ " now has the correct value--the "
#~ "class ``MyType``--even though ``MyType`` "
#~ "wasn't defined until *after* the "
#~ "annotation was defined."
#~ msgstr ""

#~ msgid ""
#~ "Python's original semantics for annotations"
#~ " made its use for static type "
#~ "analysis painful due to forward "
#~ "reference problems. This was the main"
#~ " justification for :pep:`563`, and we "
#~ "need not revisit those arguments here."
#~ msgstr ""

#~ msgid ""
#~ "However, :pep:`563`'s solution was to "
#~ "decompile code for Python annotations "
#~ "back into strings at compile time, "
#~ "requiring users of annotations to "
#~ "``eval()`` those strings to restore them"
#~ " to their actual Python values.  This"
#~ " has several drawbacks:"
#~ msgstr ""

#~ msgid ""
#~ "It requires Python implementations to "
#~ "stringize their annotations.  This is "
#~ "surprising behavior—unprecedented for a "
#~ "language-level feature.  Also, adding this"
#~ " feature to CPython was complicated, "
#~ "and this complicated code would need "
#~ "to be reimplemented independently by "
#~ "every other Python implementation."
#~ msgstr ""

#~ msgid ""
#~ "It requires that all annotations be "
#~ "evaluated at module-level scope.  "
#~ "Annotations under :pep:`563` can no "
#~ "longer refer to"
#~ msgstr ""

#~ msgid "class variables,"
#~ msgstr ""

#~ msgid "local variables in the current function, or"
#~ msgstr ""

#~ msgid "local variables in enclosing functions."
#~ msgstr ""

#~ msgid ""
#~ "It requires a code change every "
#~ "time existing code uses an annotation,"
#~ " to handle converting the stringized "
#~ "annotation back into a useful value."
#~ msgstr ""

#~ msgid "``eval()`` is slow."
#~ msgstr ""

#~ msgid ""
#~ "``eval()`` isn't always available; it's "
#~ "sometimes removed from Python for space"
#~ " reasons."
#~ msgstr ""

#~ msgid ""
#~ "In order to evaluate the annotations "
#~ "on a class, it requires obtaining "
#~ "a reference to that class's globals, "
#~ "which :pep:`563` suggests should be done"
#~ " by looking up that class by "
#~ "name in ``sys.modules``—another surprising "
#~ "requirement for a language-level "
#~ "feature."
#~ msgstr ""

#~ msgid ""
#~ "It adds an ongoing maintenance burden"
#~ " to Python implementations. Every time "
#~ "the language adds a new feature "
#~ "available in expressions, the implementation's"
#~ " stringizing code must be updated in"
#~ " tandem in order to support "
#~ "decompiling it."
#~ msgstr ""

#~ msgid ""
#~ "This PEP also solves the forward "
#~ "reference problem outlined in :pep:`563` "
#~ "while avoiding the problems listed "
#~ "above:"
#~ msgstr ""

#~ msgid ""
#~ "Python implementations would generate "
#~ "annotations as code objects.  This is"
#~ " simpler than stringizing, and is "
#~ "something Python implementations are already"
#~ " quite good at.  This means:"
#~ msgstr ""

#~ msgid ""
#~ "alternate implementations would need to "
#~ "write less code to implement this "
#~ "feature, and"
#~ msgstr ""

#~ msgid ""
#~ "the implementation would be simpler "
#~ "overall, which should reduce its ongoing"
#~ " maintenance cost."
#~ msgstr ""

#~ msgid ""
#~ "Existing annotations would not need to"
#~ " be changed to only use global "
#~ "scope.  Actually, annotations would become "
#~ "much easier to use, as they would"
#~ " now also handle forward references."
#~ msgstr ""

#~ msgid ""
#~ "Code examining annotations at runtime "
#~ "would no longer need to use "
#~ "``eval()`` or anything else—it would "
#~ "automatically see the correct values.  "
#~ "This is easier, faster, and removes "
#~ "the dependency on ``eval()``."
#~ msgstr ""

#~ msgid ""
#~ ":pep:`563` changed the semantics of "
#~ "annotations.  When its semantics are "
#~ "active, annotations must assume they "
#~ "will be evaluated in *module-level* "
#~ "scope.  They may no longer refer "
#~ "directly to local variables or class "
#~ "attributes."
#~ msgstr ""

#~ msgid ""
#~ "This PEP removes that restriction; "
#~ "annotations may refer to globals, local"
#~ " variables inside functions, local "
#~ "variables defined in enclosing functions, "
#~ "and class members in the current "
#~ "class.  In addition, annotations may "
#~ "refer to any of these that haven't"
#~ " been defined yet at the time "
#~ "the annotation is defined, as long "
#~ "as the not-yet-defined name is "
#~ "created normally (in such a way "
#~ "that it is known to the symbol "
#~ "table for the relevant block, or "
#~ "is a global or class variable "
#~ "found using normal name resolution).  "
#~ "Thus, this PEP demonstrates *improved* "
#~ "backwards compatibility over :pep:`563`."
#~ msgstr ""

#~ msgid ""
#~ ":pep:`563` also requires using ``eval()`` "
#~ "or ``typing.get_type_hints()`` to examine "
#~ "annotations.  Code updated to work with"
#~ " :pep:`563` that calls ``eval()`` directly"
#~ " would have to be updated simply "
#~ "to remove the ``eval()`` call.  Code "
#~ "using ``typing.get_type_hints()`` would continue "
#~ "to work unchanged, though future use "
#~ "of that function would become optional"
#~ " in most cases."
#~ msgstr ""

#~ msgid ""
#~ "Because this PEP makes semantic changes"
#~ " to how annotations are evaluated, "
#~ "this PEP will be initially gated "
#~ "with a per-module ``from __future__ "
#~ "import co_annotations`` before it eventually"
#~ " becomes the default behavior."
#~ msgstr ""

#~ msgid ""
#~ "Apart from the delay in evaluating "
#~ "values stored in annotations dicts, this"
#~ " PEP preserves nearly all existing "
#~ "behavior of annotations dicts.  Specifically:"
#~ msgstr ""

#~ msgid ""
#~ "The ``__annotations__`` attribute can be "
#~ "explicitly set, and any value set "
#~ "this way will be preserved."
#~ msgstr ""

#~ msgid ""
#~ "However, there are two uncommon "
#~ "interactions possible with class and "
#~ "module annotations that work today—both "
#~ "with stock semantics, and with "
#~ ":pep:`563` semantics—that would no longer "
#~ "work when this PEP was active.  "
#~ "These two interactions would have to "
#~ "be prohibited. The good news is, "
#~ "neither is common, and neither is "
#~ "considered good practice.  In fact, "
#~ "they're rarely seen outside of Python's"
#~ " own regression test suite.  They "
#~ "are:"
#~ msgstr ""

#~ msgid ""
#~ "*Code in module or class scope "
#~ "that references or modifies the local*"
#~ " ``__annotations__`` *dict directly.*  Currently,"
#~ " when setting annotations on module "
#~ "or class attributes, the generated code"
#~ " simply creates a local ``__annotations__``"
#~ " dict, then sets mappings in it "
#~ "as needed.  It's also possible for "
#~ "user code to directly modify this "
#~ "dict, though this doesn't seem like "
#~ "it's an intentional feature.  Although "
#~ "it would be possible to support "
#~ "this after a fashion when this PEP"
#~ " was active, the semantics would "
#~ "likely be surprising and wouldn't make"
#~ " anyone happy."
#~ msgstr ""

#~ msgid ""
#~ "Note that these are both also pain"
#~ " points for static type checkers, and"
#~ " are unsupported by those checkers.  "
#~ "It seems reasonable to declare that "
#~ "both are at the very least "
#~ "unsupported, and their use results in"
#~ " undefined behavior.  It might be "
#~ "worth making a small effort to "
#~ "explicitly prohibit them with compile-"
#~ "time checks."
#~ msgstr ""

#~ msgid ""
#~ "In addition, there are a few "
#~ "operators that would no longer be "
#~ "valid for use in annotations, because"
#~ " their side effects would affect the"
#~ " *annotation function* instead of the "
#~ "class/function/module the annotation was "
#~ "nominally defined in:"
#~ msgstr ""

#~ msgid "``:=`` (aka the \"walrus operator\"),"
#~ msgstr ""

#~ msgid "``yield`` and ``yield from``, and"
#~ msgstr ""

#~ msgid "``await``."
#~ msgstr ""

#~ msgid ""
#~ "Use of any of these operators in"
#~ " an annotation will result in a "
#~ "compile-time error."
#~ msgstr ""

#~ msgid ""
#~ "Since delaying the evaluation of "
#~ "annotations until they are evaluated "
#~ "changes the semantics of the language,"
#~ " it's observable from within the "
#~ "language.  Therefore it's possible to "
#~ "write code that behaves differently "
#~ "based on whether annotations are "
#~ "evaluated at binding time or at "
#~ "access time, e.g."
#~ msgstr ""

#~ msgid ""
#~ "This will print ``<class 'str'>`` with"
#~ " stock semantics and ``<class 'int'>`` "
#~ "when this PEP is active.  Since "
#~ "this is poor programming style to "
#~ "begin with, it seems acceptable that "
#~ "this PEP changes its behavior."
#~ msgstr ""

#~ msgid ""
#~ "Finally, there's a standard idiom that's"
#~ " actually somewhat common when accessing"
#~ " class annotations, and which will "
#~ "become more problematic when this PEP"
#~ " is active: code often accesses class"
#~ " annotations via "
#~ "``cls.__dict__.get(\"__annotations__\", {})`` rather "
#~ "than simply ``cls.__annotations__``.  It's due"
#~ " to a flaw in the original "
#~ "design of annotations themselves.  This "
#~ "topic will be examined in a "
#~ "separate discussion; the outcome of that"
#~ " discussion will likely guide the "
#~ "future evolution of this PEP."
#~ msgstr ""

#~ msgid ""
#~ "During the early days of discussion "
#~ "around :pep:`563`, using code to delay"
#~ " the evaluation of annotations was "
#~ "briefly discussed, in a November 2017"
#~ " thread in ``comp.lang.python-dev``.  At"
#~ " the time the technique was termed"
#~ " an \"implicit lambda expression\"."
#~ msgstr ""

#~ msgid ""
#~ "What's puzzling is :pep:`563`'s own "
#~ "changes to the scoping rules of "
#~ "annotations—it *also* doesn't permit "
#~ "annotations to reference class-level "
#~ "definitions.  It's not immediately clear "
#~ "why an inability to reference class-"
#~ "level definitions was enough to reject"
#~ " using \"implicit lambda expressions\" for"
#~ " annotations, but was acceptable for "
#~ "stringized annotations."
#~ msgstr ""

#~ msgid ""
#~ "In retrospect there was probably a "
#~ "pivot during the development of "
#~ ":pep:`563`.  It seems that, early on,"
#~ " there was a prevailing assumption "
#~ "that :pep:`563` would support references "
#~ "to class-level definitions.  But by "
#~ "the time :pep:`563` was finalized, this"
#~ " assumption had apparently been abandoned."
#~ "  And it looks like \"implicit lambda"
#~ " expressions\" were never reconsidered in"
#~ " this new light."
#~ msgstr ""

#~ msgid ""
#~ "In any case, annotations are still "
#~ "able to refer to class-level "
#~ "definitions under this PEP, rendering "
#~ "the objection moot."
#~ msgstr ""

#~ msgid "There's a prototype implementation of this PEP, here:"
#~ msgstr ""

#~ msgid ""
#~ "As of this writing, all features "
#~ "described in this PEP are implemented,"
#~ " and there are some rudimentary tests"
#~ " in the test suite.  There are "
#~ "still some broken tests, and the "
#~ "``co_annotations`` repo is many months "
#~ "behind the CPython repo."
#~ msgstr ""

#~ msgid "from __future__ import co_annotations"
#~ msgstr ""

#~ msgid "In the prototype, the semantics presented in this PEP are gated with:"
#~ msgstr ""

#~ msgid "__co_annotations__"
#~ msgstr ""

#~ msgid ""
#~ "Python supports runtime metadata for "
#~ "annotations for three different types: "
#~ "function, classes, and modules.  The "
#~ "basic approach to implement this PEP "
#~ "is much the same for all three "
#~ "with only minor variations."
#~ msgstr ""

#~ msgid ""
#~ "With this PEP, each of these types"
#~ " adds a new attribute, "
#~ "``__co_annotations__``.  ``__co_annotations__`` is a"
#~ " function: it takes no arguments, and"
#~ " must return either ``None`` or a "
#~ "dict (or subclass of dict).  It "
#~ "adds the following semantics:"
#~ msgstr ""

#~ msgid ""
#~ "``__co_annotations__`` is always set, and "
#~ "may contain either ``None`` or a "
#~ "callable."
#~ msgstr ""

#~ msgid "``__co_annotations__`` cannot be deleted."
#~ msgstr ""

#~ msgid ""
#~ "``__annotations__`` and ``__co_annotations__`` can't"
#~ " both be set to a useful value"
#~ " simultaneously:"
#~ msgstr ""

#~ msgid ""
#~ "If you set ``__annotations__`` to a "
#~ "dict, this also sets ``__co_annotations__``"
#~ " to None."
#~ msgstr ""

#~ msgid ""
#~ "If you set ``__co_annotations__`` to a"
#~ " callable, this also deletes "
#~ "``__annotations__``"
#~ msgstr ""

#~ msgid ""
#~ "Internally, ``__co_annotations__`` is a \"data"
#~ " descriptor\", where functions are called"
#~ " whenever user code gets, sets, or"
#~ " deletes the attribute.  In all three"
#~ " cases, the object has separate "
#~ "internal storage for the current value"
#~ " of the ``__co_annotations__`` attribute."
#~ msgstr ""

#~ msgid ""
#~ "``__annotations__`` is also as a data"
#~ " descriptor, with its own separate "
#~ "internal storage for its internal value."
#~ " The code implementing the \"get\" "
#~ "for ``__annotations__`` works something like"
#~ " this:"
#~ msgstr ""

#~ msgid "Unbound code objects"
#~ msgstr ""

#~ msgid ""
#~ "When Python code defines one of "
#~ "these three objects with annotations, "
#~ "the Python compiler generates a separate"
#~ " code object which builds and returns"
#~ " the appropriate annotations dict.  "
#~ "Wherever possible, the \"annotation code "
#~ "object\" is then stored *unbound* as "
#~ "the internal value of ``__co_annotations__``;"
#~ " it is then bound on demand "
#~ "when the user asks for "
#~ "``__annotations__``."
#~ msgstr ""

#~ msgid ""
#~ "This is a useful optimization for "
#~ "both speed and memory consumption.  "
#~ "Python processes rarely examine annotations"
#~ " at runtime. Therefore, pre-binding "
#~ "these code objects to function objects"
#~ " would usually be a waste of "
#~ "resources."
#~ msgstr ""

#~ msgid "When is this optimization not possible?"
#~ msgstr ""

#~ msgid ""
#~ "When an annotation function contains "
#~ "references to free variables, in the "
#~ "current function or in an outer "
#~ "function."
#~ msgstr ""

#~ msgid ""
#~ "When an annotation function is defined"
#~ " on a method (a function defined "
#~ "inside a class) and the annotations "
#~ "possibly refer directly to class "
#~ "variables."
#~ msgstr ""

#~ msgid ""
#~ "Note that user code isn't permitted "
#~ "to directly access these unbound code"
#~ " objects.  If the user \"gets\" the"
#~ " value of ``__co_annotations__``, and the"
#~ " internal value of ``__co_annotations__`` "
#~ "is an unbound code object, it "
#~ "immediately binds the code object, and"
#~ " the resulting function object is "
#~ "stored as the new value of "
#~ "``__co_annotations__`` and returned."
#~ msgstr ""

#~ msgid ""
#~ "(However, these unbound code objects "
#~ "*are* stored in the ``.pyc`` file.  "
#~ "So a determined user could examine "
#~ "them should that be necessary for "
#~ "some reason.)"
#~ msgstr ""

#~ msgid ""
#~ "When compiling a function, the CPython"
#~ " bytecode compiler visits the annotations"
#~ " for the function all in one "
#~ "place, starting with "
#~ "``compiler_visit_annotations()`` in ``compile.c``. "
#~ "If there are any annotations, they "
#~ "create the scope for the annotations "
#~ "function on demand, and "
#~ "``compiler_visit_annotations()`` assembles it."
#~ msgstr ""

#~ msgid ""
#~ "The code object is passed in place"
#~ " of the annotations dict for the "
#~ "``MAKE_FUNCTION`` bytecode instruction. "
#~ "``MAKE_FUNCTION`` supports a new bit in"
#~ " its oparg bitfield, ``0x10``, which "
#~ "tells it to expect a ``co_annotations``"
#~ " code object on the stack. The "
#~ "bitfields for ``annotations`` (``0x04``) and"
#~ " ``co_annotations`` (``0x10``) are mutually "
#~ "exclusive."
#~ msgstr ""

#~ msgid ""
#~ "When binding an unbound annotation code"
#~ " object, a function will use its "
#~ "own ``__globals__`` as the new "
#~ "function's globals."
#~ msgstr ""

#~ msgid ""
#~ "One quirk of Python: you can't "
#~ "actually remove the annotations from a"
#~ " function object.  If you delete the"
#~ " ``__annotations__`` attribute of a "
#~ "function, then get its ``__annotations__`` "
#~ "member, it will create an empty "
#~ "dict and use that as its "
#~ "``__annotations__``.  The implementation of "
#~ "this PEP maintains this quirk for "
#~ "backwards compatibility."
#~ msgstr ""

#~ msgid "Class Annotations"
#~ msgstr ""

#~ msgid ""
#~ "When compiling a class body, the "
#~ "compiler maintains two scopes: one for"
#~ " the normal class body code, and "
#~ "one for annotations. (This is "
#~ "facilitated by four new functions: "
#~ "``compiler.c`` adds ``compiler_push_scope()`` and"
#~ " ``compiler_pop_scope()``, and ``symtable.c`` "
#~ "adds ``symtable_push_scope()`` and "
#~ "``symtable_pop_scope()``.) Once the code "
#~ "generator reaches the end of the "
#~ "class body, but before it generates "
#~ "the bytecode for the class body, "
#~ "it assembles the bytecode for "
#~ "``__co_annotations__``, then assigns that to"
#~ " ``__co_annotations__`` using ``STORE_NAME``."
#~ msgstr ""

#~ msgid ""
#~ "It also sets a new ``__globals__`` "
#~ "attribute.  Currently it does this by"
#~ " calling ``globals()`` and storing the "
#~ "result. (Surely there's a more elegant"
#~ " way to find the class's globals--"
#~ "but this was good enough for the"
#~ " prototype.)  When binding an unbound "
#~ "annotation code object, a class will "
#~ "use the value of this ``__globals__``"
#~ " attribute.  When the class drops its"
#~ " reference to the unbound code object"
#~ "--either because it has bound it "
#~ "to a function, or because "
#~ "``__annotations__`` has been explicitly set"
#~ "--it also deletes its ``__globals__`` "
#~ "attribute."
#~ msgstr ""

#~ msgid ""
#~ "As discussed above, examination or "
#~ "modification of ``__annotations__`` from "
#~ "within the class body is no longer"
#~ " supported.  Also, any flow control "
#~ "(``if`` or ``try`` blocks) around "
#~ "declarations of members with annotations "
#~ "is unsupported."
#~ msgstr ""

#~ msgid ""
#~ "If you delete the ``__annotations__`` "
#~ "attribute of a class, then get its"
#~ " ``__annotations__`` member, it will return"
#~ " the annotations dict of the first"
#~ " base class with annotations set. If"
#~ " no base classes have annotations "
#~ "set, it will raise ``AttributeError``."
#~ msgstr ""

#~ msgid ""
#~ "Although it's an implementation-specific "
#~ "detail, currently classes store the "
#~ "internal value of ``__co_annotations__`` in"
#~ " their ``tp_dict`` under the same "
#~ "name."
#~ msgstr ""

#~ msgid "Module Annotations"
#~ msgstr ""

#~ msgid ""
#~ "Module annotations work much the same"
#~ " as class annotations. The main "
#~ "difference is, a module uses its "
#~ "own dict as the ``__globals__`` when "
#~ "binding the function."
#~ msgstr ""

#~ msgid ""
#~ "If you delete the ``__annotations__`` "
#~ "attribute of a class, then get its"
#~ " ``__annotations__`` member, the module "
#~ "will raise ``AttributeError``."
#~ msgstr ""

#~ msgid "Annotations With Closures"
#~ msgstr ""

#~ msgid ""
#~ "It's possible to write annotations that"
#~ " refer to free variables, and even"
#~ " free variables that have yet to "
#~ "be defined.  For example:"
#~ msgstr ""

#~ msgid ""
#~ "At the time ``fn`` is set, "
#~ "``inner.__co_annotations__()`` hasn't been run.  "
#~ "So it has to retain a reference"
#~ " to the *future* definitions of "
#~ "``mytype`` and ``mytype2`` if it is "
#~ "to correctly evaluate its annotations."
#~ msgstr ""

#~ msgid ""
#~ "If an annotation function refers to "
#~ "a local variable from the current "
#~ "function scope, or a free variable "
#~ "from an enclosing function scope--if,"
#~ " in CPython, the annotation function "
#~ "code object contains one or more "
#~ "``LOAD_DEREF`` opcodes--then the annotation"
#~ " code object is bound at definition"
#~ " time with references to these "
#~ "variables.  ``LOAD_DEREF`` instructions require "
#~ "the annotation function to be bound "
#~ "with special run-time information (in"
#~ " CPython, a ``freevars`` array).   Rather"
#~ " than store that separately and use"
#~ " that to later lazy-bind the "
#~ "function object, the current implementation"
#~ " simply early-binds the function "
#~ "object."
#~ msgstr ""

#~ msgid ""
#~ "Note that, since the annotation function"
#~ " ``inner.__co_annotations__()`` is defined while"
#~ " parsing ``outer()``, from Python's "
#~ "perspective the annotation function is a"
#~ " \"nested function\".  So \"local variable"
#~ " inside the 'current' function\" and "
#~ "\"free variable from an enclosing "
#~ "function\" are, from the perspective of"
#~ " the annotation function, the same "
#~ "thing."
#~ msgstr ""

#~ msgid "Annotations That Refer To Class Variables"
#~ msgstr ""

#~ msgid ""
#~ "It's possible to write annotations that"
#~ " refer to class variables, and even"
#~ " class variables that haven't yet "
#~ "been defined.  For example:"
#~ msgstr ""

#~ msgid ""
#~ "Internally, annotation functions are defined"
#~ " as a new type of \"block\" in"
#~ " CPython's symbol table called an "
#~ "``AnnotationBlock``.  An ``AnnotationBlock`` is "
#~ "almost identical to a ``FunctionBlock``.  "
#~ "It differs in that it's permitted "
#~ "to see names from an enclosing "
#~ "class scope.  (Again: annotation functions "
#~ "are functions, and they're defined "
#~ "*inside* the same scope as the "
#~ "thing they're being defined on.  So "
#~ "in the above example, the annotation "
#~ "function for ``C.method()`` is defined "
#~ "inside ``C``.)"
#~ msgstr ""

#~ msgid ""
#~ "If it's possible that an annotation "
#~ "function refers to class variables--if"
#~ " all these conditions are true:"
#~ msgstr ""

#~ msgid "The annotation function is being defined inside a class scope."
#~ msgstr ""

#~ msgid ""
#~ "The generated code for the annotation"
#~ " function has at least one "
#~ "``LOAD_NAME`` instruction."
#~ msgstr ""

#~ msgid ""
#~ "Then the annotation function is bound"
#~ " at the time it's set on the"
#~ " class/function, and this binding includes"
#~ " a reference to the class dict.  "
#~ "The class dict is pushed on the"
#~ " stack, and the ``MAKE_FUNCTION`` bytecode"
#~ " instruction takes a new second "
#~ "bitfield (0x20) indicating that it "
#~ "should consume that stack argument and"
#~ " store it as ``__locals__`` on the"
#~ " newly created function object."
#~ msgstr ""

#~ msgid ""
#~ "Then, at the time the function is"
#~ " executed, the ``f_locals`` field of "
#~ "the frame object is set to the "
#~ "function's ``__locals__``, if set. This "
#~ "permits ``LOAD_NAME`` opcodes to work "
#~ "normally, which means the code generated"
#~ " for annotation functions is nearly "
#~ "identical to that generated for "
#~ "conventional Python functions."
#~ msgstr ""

#~ msgid ""
#~ "Everything works the same inside "
#~ "Python's interactive REPL shell, except "
#~ "for module annotations in the "
#~ "interactive module (``__main__``) itself.  "
#~ "Since that module is never \"finished\","
#~ " there's no specific point where we"
#~ " can compile the ``__co_annotations__`` "
#~ "function."
#~ msgstr ""

#~ msgid ""
#~ "For the sake of simplicity, in "
#~ "this case we forego delayed evaluation."
#~ " Module-level annotations in the REPL"
#~ " shell will continue to work exactly"
#~ " as they do today, evaluating "
#~ "immediately and setting the result "
#~ "directly inside the ``__annotations__`` dict."
#~ msgstr ""

#~ msgid ""
#~ "(It might be possible to support "
#~ "delayed evaluation here. But it gets "
#~ "complicated quickly, and for a "
#~ "nearly-non-existent use case.)"
#~ msgstr ""

#~ msgid ""
#~ "Performance with this PEP should be "
#~ "favorable, when compared with either "
#~ "stock behavior or :pep:`563`.  In "
#~ "general, resources are only consumed on"
#~ " demand—\"you only pay for what you"
#~ " use\"."
#~ msgstr ""

#~ msgid "There are three scenarios to consider:"
#~ msgstr ""

#~ msgid "the runtime cost when annotations are defined *and* referenced."
#~ msgstr ""

#~ msgid ""
#~ "When annotations are defined but not "
#~ "referenced, the runtime cost of Python"
#~ " with this PEP should be roughly "
#~ "equal to or slightly better than "
#~ ":pep:`563` semantics, and slightly better "
#~ "than \"stock\" Python semantics.  The "
#~ "specifics depend on the object being "
#~ "annotated:"
#~ msgstr ""

#~ msgid ""
#~ "In :pep:`563` semantics, for function "
#~ "objects, a single constant (a tuple) "
#~ "is set as an attribute of the "
#~ "function.  For class and module objects,"
#~ " the annotations dict is always built"
#~ " and set as an attribute of the"
#~ " class or module."
#~ msgstr ""

#~ msgid ""
#~ "With this PEP, a single object is"
#~ " set as an attribute of the "
#~ "object being annotated.  Most often, "
#~ "this object is a constant (a code"
#~ " object).  In cases where the "
#~ "annotation refers to local variables or"
#~ " class variables, the code object "
#~ "will be bound to a function "
#~ "object, and the function object is "
#~ "set as the attribute of the object"
#~ " being annotated."
#~ msgstr ""

#~ msgid ""
#~ "When annotations are both defined and"
#~ " referenced, code using this PEP "
#~ "should be much faster than code "
#~ "using :pep:`563` semantics, and equivalent "
#~ "to or slightly improved over original"
#~ " Python semantics.  :pep:`563` semantics "
#~ "requires invoking ``eval()`` for every "
#~ "value inside an annotations dict, which"
#~ " is enormously slow. And, as already"
#~ " mentioned, this PEP generates measurably"
#~ " more efficient bytecode for class "
#~ "and module annotations than stock "
#~ "semantics; for function annotations, this "
#~ "PEP and stock semantics should be "
#~ "roughly equivalent."
#~ msgstr ""

#~ msgid ""
#~ "Memory use should also be comparable "
#~ "in all three scenarios across all "
#~ "three semantic contexts.  In the first"
#~ " and third scenarios, memory usage "
#~ "should be roughly equivalent in all "
#~ "cases. In the second scenario, when "
#~ "annotations are defined but not "
#~ "referenced, using this PEP's semantics "
#~ "will mean the function/class/module will "
#~ "store one unused code object (possibly"
#~ " bound to an unused function object);"
#~ " with the other two semantics, "
#~ "they'll store one unused dictionary (or"
#~ " constant tuple)."
#~ msgstr ""

#~ msgid "Bytecode Comparison"
#~ msgstr ""

#~ msgid ""
#~ "The bytecode generated for annotations "
#~ "functions with this PEP uses the "
#~ "efficient ``BUILD_CONST_KEY_MAP`` opcode to "
#~ "build the dict for all annotatable "
#~ "objects: functions, classes, and modules."
#~ msgstr ""

#~ msgid ""
#~ "Stock semantics also uses "
#~ "``BUILD_CONST_KEY_MAP`` bytecode for function "
#~ "annotations. :pep:`563` has an even more"
#~ " efficient method for building annotations"
#~ " dicts on functions, leveraging the "
#~ "fact that its annotations dicts only "
#~ "contain strings for both keys and "
#~ "values.  At compile-time it constructs"
#~ " a tuple containing pairs of keys "
#~ "and values at compile-time, then "
#~ "at runtime it converts that tuple "
#~ "into a dict on demand. This is "
#~ "a faster technique than either stock "
#~ "semantics or this PEP can employ, "
#~ "because in those two cases annotations"
#~ " dicts can contain Python values of"
#~ " any type. Of course, this "
#~ "performance win is negated if the "
#~ "annotations are examined, due to the "
#~ "overhead of ``eval()``."
#~ msgstr ""

#~ msgid ""
#~ "For class and module annotations, both"
#~ " stock semantics and :pep:`563` generate"
#~ " a longer and slightly-less-efficient"
#~ " stanza of bytecode, creating the "
#~ "dict and setting the annotations "
#~ "individually."
#~ msgstr ""

#~ msgid "For Future Discussion"
#~ msgstr ""

#~ msgid "Circular Imports"
#~ msgstr ""

#~ msgid ""
#~ "There is one unfortunately-common "
#~ "scenario where :pep:`563` currently provides"
#~ " a better experience, and it has "
#~ "to do with large code bases, with"
#~ " circular dependencies and imports, that"
#~ " examine their annotations at run-"
#~ "time."
#~ msgstr ""

#~ msgid ""
#~ ":pep:`563` permitted defining *and examining*"
#~ " invalid expressions as annotations.  Its"
#~ " implementation requires annotations to be"
#~ " legal Python expressions, which it "
#~ "then converts into strings at "
#~ "compile-time.  But legal Python expressions"
#~ " may not be computable at runtime,"
#~ " if for example the expression "
#~ "references a name that isn't defined."
#~ " This is a problem for stringized "
#~ "annotations if they're evaluated, e.g. "
#~ "with ``typing.get_type_hints()``.  But any "
#~ "stringized annotation may be examined "
#~ "harmlessly at any time--as long as"
#~ " you don't evaluate it, and only "
#~ "examine it as a string."
#~ msgstr ""

#~ msgid ""
#~ "Some large organizations have code bases"
#~ " that unfortunately have circular "
#~ "dependency problems with their annotations"
#~ "--class A has methods annotated with"
#~ " class B, but class B has "
#~ "methods annotated with class A--that "
#~ "can be difficult to resolve. Since "
#~ ":pep:`563` stringizes their annotations, it"
#~ " allows them to leave these circular"
#~ " dependencies in place, and they can"
#~ " sidestep the circular import problem "
#~ "by never importing the module that "
#~ "defines the types used in the "
#~ "annotations.  Their annotations can no "
#~ "longer be evaluated, but this appears"
#~ " not to be a concern in "
#~ "practice.  They can then examine the "
#~ "stringized form of the annotations at"
#~ " runtime and this seems to be "
#~ "sufficient for their needs."
#~ msgstr ""

#~ msgid ""
#~ "This PEP allows for many of the"
#~ " same behaviors. Annotations must be "
#~ "legal Python expressions, which are "
#~ "compiled into a function at compile-"
#~ "time. And if the code never "
#~ "examines an annotation, it won't have"
#~ " any runtime effect, so here too "
#~ "annotations can harmlessly refer to "
#~ "undefined names.  (It's exactly like "
#~ "defining a function that refers to "
#~ "undefined names--then never calling that"
#~ " function.  Until you call the "
#~ "function, nothing bad will happen.)"
#~ msgstr ""

#~ msgid ""
#~ "But examining an annotation when this"
#~ " PEP is active means evaluating it,"
#~ " which means the names evaluated in"
#~ " that expression must be defined.  An"
#~ " undefined name will throw a "
#~ "``NameError`` in an annotation function, "
#~ "just as it would with a stringized"
#~ " annotation passed in to "
#~ "``typing.get_type_hints()``, and just like any"
#~ " other context in Python where an "
#~ "expression is evaluated."
#~ msgstr ""

#~ msgid ""
#~ "In discussions we have yet to find"
#~ " a solution to this problem that "
#~ "makes all the participants in the "
#~ "conversation happy.  There are various "
#~ "avenues to explore here:"
#~ msgstr ""

#~ msgid ""
#~ "One workaround is to continue to "
#~ "stringize one's annotations, either by "
#~ "hand or done automatically by the "
#~ "Python compiler (as it does today "
#~ "with ``from __future__ import annotations``)."
#~ "  This might mean preserving Python's "
#~ "current stringizing annotations going forward,"
#~ " although leaving it turned off by"
#~ " default, only available by explicit "
#~ "request (though likely with a different"
#~ " mechanism than ``from __future__ import"
#~ " annotations``)."
#~ msgstr ""

#~ msgid ""
#~ "Another possible workaround involves importing"
#~ " the circularly-dependent modules "
#~ "separately, then externally adding "
#~ "(\"monkey-patching\") their dependencies to "
#~ "each other after the modules are "
#~ "loaded.  As long as the modules "
#~ "don't examine their annotations until "
#~ "after they are completely loaded, this"
#~ " should work fine and be maintainable"
#~ " with a minimum of effort."
#~ msgstr ""

#~ msgid ""
#~ "A third and more radical approach "
#~ "would be to change the semantics "
#~ "of annotations so that they don't "
#~ "raise a ``NameError`` when an unknown"
#~ " name is evaluated, but instead "
#~ "create some sort of proxy \"reference\""
#~ " object."
#~ msgstr ""

#~ msgid ""
#~ "Of course, even if we do deprecate"
#~ " :pep:`563`, it will be several "
#~ "releases before the functionality is "
#~ "removed, giving us several years in "
#~ "which to research and innovate new "
#~ "solutions for this problem."
#~ msgstr ""

#~ msgid ""
#~ "In any case, the participants of "
#~ "the discussion agree that this PEP "
#~ "should still move forward, even as "
#~ "this issue remains currently unresolved "
#~ "[1]_."
#~ msgstr ""

#~ msgid "https://github.com/larryhastings/co_annotations/issues/1"
#~ msgstr ""

#~ msgid "cls.__globals__ and fn.__locals__"
#~ msgstr ""

#~ msgid ""
#~ "Is it permissible to add the "
#~ "``__globals__`` reference to class objects "
#~ "as proposed here?  It's not clear "
#~ "why this hasn't already been done; "
#~ ":pep:`563` could have made use of "
#~ "class globals, but instead made do "
#~ "with looking up classes inside "
#~ "``sys.modules``.  Python seems strangely "
#~ "allergic to adding a ``__globals__`` "
#~ "reference to class objects."
#~ msgstr ""

#~ msgid ""
#~ "If adding ``__globals__`` to class "
#~ "objects is indeed a bad idea (for"
#~ " reasons I don't know), here are "
#~ "two alternatives as to how classes "
#~ "could get a reference to their "
#~ "globals for the implementation of this"
#~ " PEP:"
#~ msgstr ""

#~ msgid ""
#~ "The generate code for a class "
#~ "could bind its annotations code object"
#~ " to a function at the time the"
#~ " class is bound, rather than waiting"
#~ " for ``__annotations__`` to be referenced,"
#~ " making them an exception to the "
#~ "rule (even though \"special cases aren't"
#~ " special enough to break the "
#~ "rules\").  This would result in a "
#~ "small additional runtime cost when "
#~ "annotations were defined but not "
#~ "referenced on class objects.  Honestly "
#~ "I'm more worried about the lack of"
#~ " symmetry in semantics.  (But I "
#~ "wouldn't want to pre-bind all "
#~ "annotations code objects, as that would"
#~ " become much more costly for function"
#~ " objects, even as annotations are "
#~ "rarely used at runtime.)"
#~ msgstr ""

#~ msgid ""
#~ "Use the class's ``__module__`` attribute "
#~ "to look up its module by name "
#~ "in ``sys.modules``.  This is what "
#~ ":pep:`563` advises. While this is "
#~ "passable for userspace or library code,"
#~ " it seems like a little bit of"
#~ " a code smell for this to be"
#~ " defined semantics baked into the "
#~ "language itself."
#~ msgstr ""

#~ msgid ""
#~ "Also, the prototype gets globals for "
#~ "class objects by calling ``globals()`` "
#~ "then storing the result.  I'm sure "
#~ "there's a much faster way to do"
#~ " this, I just didn't know what "
#~ "it was when I was prototyping.  "
#~ "I'm sure we can revise this to "
#~ "something much faster and much more "
#~ "sanitary.  I'd prefer to make it "
#~ "completely internal anyway, and not make"
#~ " it visible to the user (via "
#~ "this new __globals__ attribute).  There's "
#~ "possibly already a good place to "
#~ "put it anyway--``ht_module``."
#~ msgstr ""

#~ msgid ""
#~ "Similarly, this PEP adds one new "
#~ "dunder member to functions, classes, and"
#~ " modules (``__co_annotations__``), and a "
#~ "second new dunder member to functions"
#~ " (``__locals__``).  This might be "
#~ "considered excessive."
#~ msgstr ""

#~ msgid "Bikeshedding the name"
#~ msgstr ""

#~ msgid ""
#~ "During most of the development of "
#~ "this PEP, user code actually could "
#~ "see the raw annotation code objects."
#~ "  ``__co_annotations__`` could only be set"
#~ " to a code object; functions and "
#~ "other callables weren't permitted.  In "
#~ "that context the name ``co_annotations`` "
#~ "makes a lot of sense.  But with"
#~ " this last-minute pivot where "
#~ "``__co_annotations__`` now presents itself as"
#~ " a callable, perhaps the name of "
#~ "the attribute and the name of the"
#~ " ``from __future__ import`` needs a "
#~ "re-think."
#~ msgstr ""

#~ msgid ""
#~ "Thanks to Barry Warsaw, Eric V. "
#~ "Smith, Mark Shannon, and Guido van "
#~ "Rossum for feedback and encouragement. "
#~ "Thanks in particular to Mark Shannon "
#~ "for two key suggestions—build the entire"
#~ " annotations dict inside a single "
#~ "code object, and only bind it to"
#~ " a function on demand—that quickly "
#~ "became among the best aspects of "
#~ "this proposal.  Also, thanks in "
#~ "particular to Guido van Rossum for "
#~ "suggesting that ``__co_annotations__`` functions "
#~ "should duplicate the name visibility "
#~ "rules of annotations under \"stock\" "
#~ "semantics--this resulted in a sizeable"
#~ " improvement to the second draft.  "
#~ "Finally, special thanks to Jelle "
#~ "Zijlstra, who contributed not just "
#~ "feedback--but code!"
#~ msgstr ""

