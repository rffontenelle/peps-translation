# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0642.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-0642.rst:5
msgid "Alyssa Coghlan <ncoghlan@gmail.com>"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "BDFL-Delegate"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/pep-0642.rst:7
msgid "python-dev@python.org"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-0642.rst:8
msgid "Rejected"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-0642.rst:9
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "Requires"
msgstr ""

#: ../../peps/pep-0642.rst:11
msgid "634"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-0642.rst:12
msgid "26-Sep-2020"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0642.rst:13
msgid "3.10"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-0642.rst:14
msgid "31-Oct-2020, 08-Nov-2020, 03-Jan-2021"
msgstr ""

#: ../../peps/pep-0642.rst
msgid "Resolution"
msgstr ""

#: ../../peps/pep-0642.rst:15
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/message/SQC2FTLFV5A7DV7RCEAR2I2IKJKGK7W3/"
msgstr ""

#: ../../peps/pep-0642.rst:18
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0642.rst:20
msgid ""
"This PEP covers an alternative syntax proposal for :pep:`634`'s "
"structural pattern matching that requires explicit prefixes on all "
"capture patterns and value constraints. It also proposes a new dedicated "
"syntax for instance attribute patterns that aligns more closely with the "
"proposed mapping pattern syntax."
msgstr ""

#: ../../peps/pep-0642.rst:25
msgid ""
"While the result is necessarily more verbose than the proposed syntax in "
":pep:`634`, it is still significantly less verbose than the status quo."
msgstr ""

#: ../../peps/pep-0642.rst:28
msgid ""
"As an example, the following match statement would extract \"host\" and "
"\"port\" details from a 2 item sequence, a mapping with \"host\" and "
"\"port\" keys, any object with \"host\" and \"port\" attributes, or a "
"\"host:port\" string, treating the \"port\" as optional in the latter "
"three cases::"
msgstr ""

#: ../../peps/pep-0642.rst:54
msgid ""
"At a high level, this PEP proposes to categorise the different available "
"pattern types as follows:"
msgstr ""

#: ../../peps/pep-0642.rst:57
msgid "wildcard pattern: ``__``"
msgstr ""

#: ../../peps/pep-0642.rst:58
msgid "group patterns: ``(PTRN)``"
msgstr ""

#: ../../peps/pep-0642.rst:60
msgid "value constraint patterns:"
msgstr ""

#: ../../peps/pep-0642.rst:60
msgid "equality constraints: ``== EXPR``"
msgstr ""

#: ../../peps/pep-0642.rst:61
msgid "identity constraints: ``is EXPR``"
msgstr ""

#: ../../peps/pep-0642.rst:67
msgid "structural constraint patterns:"
msgstr ""

#: ../../peps/pep-0642.rst:63
msgid "sequence constraint patterns: ``[PTRN, as NAME, PTRN as NAME]``"
msgstr ""

#: ../../peps/pep-0642.rst:64
msgid "mapping constraint patterns: ``{EXPR: PTRN, EXPR as NAME}``"
msgstr ""

#: ../../peps/pep-0642.rst:65
msgid ""
"instance attribute constraint patterns: ``CLS{.NAME, .NAME: PTRN, .NAME "
"== EXPR, .NAME as NAME}``"
msgstr ""

#: ../../peps/pep-0642.rst:67
msgid ""
"class defined constraint patterns: ``CLS(PTRN, PTRN, **{.NAME, .NAME: "
"PTRN, .NAME == EXPR, .NAME as NAME})``"
msgstr ""

#: ../../peps/pep-0642.rst:69
msgid "OR patterns: ``PTRN | PTRN | PTRN``"
msgstr ""

#: ../../peps/pep-0642.rst:70
msgid "AS patterns: ``PTRN as NAME`` (omitting the pattern implies ``__``)"
msgstr ""

#: ../../peps/pep-0642.rst:72
msgid "The intent of this approach is to:"
msgstr ""

#: ../../peps/pep-0642.rst:74
msgid ""
"allow an initial form of pattern matching to be developed and released "
"without needing to decide up front on the best default options for "
"handling bare names, attribute lookups, and literal values"
msgstr ""

#: ../../peps/pep-0642.rst:77
msgid ""
"ensure that pattern matching is defined explicitly at the Abstract Syntax"
" Tree level, allowing the specifications of the semantics and the surface"
" syntax for pattern matching to be clearly separated"
msgstr ""

#: ../../peps/pep-0642.rst:80
msgid ""
"define a clear and concise \"ducktyping\" syntax that could potentially "
"be adopted in ordinary expressions as a way to more easily retrieve a "
"tuple containing multiple attributes from the same object"
msgstr ""

#: ../../peps/pep-0642.rst:84
msgid ""
"Relative to :pep:`634`, the proposal also deliberately eliminates any "
"syntax that \"binds to the right\" without using the ``as`` keyword "
"(using capture patterns in :pep:`634`'s mapping patterns and class "
"patterns) or binds to both the left and the right in the same pattern "
"(using :pep:`634`'s capture patterns with AS patterns)"
msgstr ""

#: ../../peps/pep-0642.rst:91
msgid "Relationship with other PEPs"
msgstr ""

#: ../../peps/pep-0642.rst:93
msgid ""
"This PEP both depends on and competes with :pep:`634` - the PEP author "
"agrees that match statements would be a sufficiently valuable addition to"
" the language to be worth the additional complexity that they add to the "
"learning process, but disagrees with the idea that \"simple name vs "
"literal or attribute lookup\" really offers an adequate syntactic "
"distinction between name binding and value lookup operations in match "
"patterns (at least for Python)."
msgstr ""

#: ../../peps/pep-0642.rst:100
msgid ""
"This PEP agrees with the spirit of :pep:`640` (that the chosen wildcard "
"pattern to skip a name binding should be supported everywhere, not just "
"in match patterns), but is now proposing a different spelling for the "
"wildcard syntax (``__`` rather than ``?``). As such, it competes with "
":pep:`640` as written, but would complement a proposal to deprecate the "
"use of ``__`` as an ordinary identifier and instead turn it into a "
"general purpose wildcard marker that always skips making a new local "
"variable binding."
msgstr ""

#: ../../peps/pep-0642.rst:108
msgid ""
"While it has not yet been put forward as a PEP, Mark Shannon has a pre-"
"PEP draft [8]_ expressing several concerns about the runtime semantics of"
" the pattern matching proposal in :pep:`634`. This PEP is somewhat "
"complementary to that one, as even though this PEP is mostly about "
"surface syntax changes rather than major semantic changes, it does "
"propose that the Abstract Syntax Tree definition be made more explicit to"
" better separate the details of the surface syntax from the semantics of "
"the code generation step. There is one specific idea in that pre-PEP "
"draft that this PEP explicitly rejects: the idea that the different kinds"
" of matching are mutually exclusive. It's entirely possible for the same "
"value to match different kinds of structural pattern, and which one takes"
" precedence will intentionally be governed by the order of the cases in "
"the match statement."
msgstr ""

#: ../../peps/pep-0642.rst:122
msgid "Motivation"
msgstr ""

#: ../../peps/pep-0642.rst:124
msgid ""
"The original :pep:`622` (which was later split into :pep:`634`, "
":pep:`635`, and :pep:`636`) incorporated an unstated but essential "
"assumption in its syntax design: that neither ordinary expressions *nor* "
"the existing assignment target syntax provide an adequate foundation for "
"the syntax used in match patterns."
msgstr ""

#: ../../peps/pep-0642.rst:129
msgid ""
"While the PEP didn't explicitly state this assumption, one of the PEP "
"authors explained it clearly on python-dev [1]_:"
msgstr ""

#: ../../peps/pep-0642.rst:132
msgid ""
"The actual problem that I see is that we have different "
"cultures/intuitions fundamentally clashing here.  In particular, so many "
"programmers welcome pattern matching as an \"extended switch statement\" "
"and find it therefore strange that names are binding and not expressions "
"for comparison.  Others argue that it is at odds with current assignment "
"statements, say, and question why dotted names are _/not/_ binding.  What"
" all groups seem to have in common, though, is that they refer to "
"_/their/_ understanding and interpretation of the new match statement as "
"'consistent' or 'intuitive' --- naturally pointing out where we as PEP "
"authors went wrong with our design."
msgstr ""

#: ../../peps/pep-0642.rst:143
msgid ""
"But here is the catch: at least in the Python world, pattern matching as "
"proposed by this PEP is an unprecedented and new way of approaching a "
"common problem.  It is not simply an extension of something already "
"there.  Even worse: while designing the PEP we found that no matter from "
"which angle you approach it, you will run into issues of seeming "
"'inconsistencies' (which is to say that pattern matching cannot be "
"reduced to a 'linear' extension of existing features in a meaningful "
"way): there is always something that goes fundamentally beyond what is "
"already there in Python.  That's why I argue that arguments based on what"
" is 'intuitive' or 'consistent' just do not make sense _/in this case/_."
msgstr ""

#: ../../peps/pep-0642.rst:154
msgid ""
"The first iteration of this PEP was then born out of an attempt to show "
"that the second assertion was not accurate, and that match patterns could"
" be treated as a variation on assignment targets without leading to "
"inherent contradictions. (An earlier PR submitted to list this option in "
"the \"Rejected Ideas\" section of the original :pep:`622` had previously "
"been declined [2]_)."
msgstr ""

#: ../../peps/pep-0642.rst:160
msgid ""
"However, the review process for this PEP strongly suggested that not only"
" did the contradictions that Tobias mentioned in his email exist, but "
"they were also concerning enough to cast doubts on the syntax proposal "
"presented in :pep:`634`. Accordingly, this PEP was changed to go even "
"further than :pep:`634`, and largely abandon alignment between the "
"sequence matching syntax and the existing iterable unpacking syntax "
"(effectively answering \"Not really, as least as far as the exact syntax "
"is concerned\" to the first question raised in the DLS'20 paper [9]_: "
"\"Can we extend a feature like iterable unpacking to work for more "
"general object and data layouts?\")."
msgstr ""

#: ../../peps/pep-0642.rst:170
msgid ""
"This resulted in a complete reversal of the goals of the PEP: rather than"
" attempting to emphasise the similarities between assignment and pattern "
"matching, the PEP now attempts to make sure that assignment target syntax"
" isn't being reused *at all*, reducing the likelihood of incorrect "
"inferences being drawn about the new construct based on experience with "
"existing ones."
msgstr ""

#: ../../peps/pep-0642.rst:176
msgid ""
"Finally, before completing the 3rd iteration of the proposal (which "
"dropped inferred patterns entirely), the PEP author spent quite a bit of "
"time reflecting on the following entries in :pep:`20`:"
msgstr ""

#: ../../peps/pep-0642.rst:180
msgid "Explicit is better than implicit."
msgstr ""

#: ../../peps/pep-0642.rst:181
msgid "Special cases aren't special enough to break the rules."
msgstr ""

#: ../../peps/pep-0642.rst:182
msgid "In the face of ambiguity, refuse the temptation to guess."
msgstr ""

#: ../../peps/pep-0642.rst:184
msgid ""
"If we start with an explicit syntax, we can always add syntactic "
"shortcuts later (e.g. consider the recent proposals to add shortcuts for "
"``Union`` and ``Optional`` type hints only after years of experience with"
" the original more verbose forms), while if we start out with only the "
"abbreviated forms, then we don't have any real way to revisit those "
"decisions in a future release."
msgstr ""

#: ../../peps/pep-0642.rst:192
msgid "Specification"
msgstr ""

#: ../../peps/pep-0642.rst:194
msgid ""
"This PEP retains the overall ``match``/``case`` statement structure and "
"semantics from :pep:`634`, but proposes multiple changes that mean that "
"user intent is explicitly specified in the concrete syntax rather than "
"needing to be inferred from the pattern matching context."
msgstr ""

#: ../../peps/pep-0642.rst:199
msgid ""
"In the proposed Abstract Syntax Tree, the semantics are also always "
"explicit, with no inference required."
msgstr ""

#: ../../peps/pep-0642.rst:204
msgid "The Match Statement"
msgstr ""

#: ../../peps/pep-0642.rst:206 ../../peps/pep-0642.rst:358
#: ../../peps/pep-0642.rst:401 ../../peps/pep-0642.rst:431
#: ../../peps/pep-0642.rst:555 ../../peps/pep-0642.rst:585
#: ../../peps/pep-0642.rst:603 ../../peps/pep-0642.rst:626
#: ../../peps/pep-0642.rst:705 ../../peps/pep-0642.rst:770
#: ../../peps/pep-0642.rst:827
msgid "Surface syntax::"
msgstr ""

#: ../../peps/pep-0642.rst:225 ../../peps/pep-0642.rst:366
#: ../../peps/pep-0642.rst:409 ../../peps/pep-0642.rst:449
#: ../../peps/pep-0642.rst:559 ../../peps/pep-0642.rst:642
#: ../../peps/pep-0642.rst:720 ../../peps/pep-0642.rst:781
#: ../../peps/pep-0642.rst:841
msgid "Abstract syntax::"
msgstr ""

#: ../../peps/pep-0642.rst:231
msgid ""
"The rules ``star_named_expression``, ``star_named_expressions``, "
"``named_expression`` and ``block`` are part of the `standard Python "
"grammar <https://docs.python.org/3.10/reference/grammar.html>`_."
msgstr ""

#: ../../peps/pep-0642.rst:235
msgid ""
"Open patterns are patterns which consist of multiple tokens, and aren't "
"necessarily terminated by a closing delimiter (for example, ``__ as x``, "
"``int() | bool()``). To avoid ambiguity for human readers, their usage is"
" restricted to top level patterns and to group patterns (which are "
"patterns surrounded by parentheses)."
msgstr ""

#: ../../peps/pep-0642.rst:241
msgid ""
"Closed patterns are patterns which either consist of a single token (i.e."
" ``__``), or else have a closing delimiter as a required part of their "
"syntax (e.g. ``[as x, as y]``, ``object{.x as x, .y as y}``)."
msgstr ""

#: ../../peps/pep-0642.rst:245
msgid ""
"As in :pep:`634`, the ``match`` and ``case`` keywords are soft keywords, "
"i.e. they are not reserved words in other grammatical contexts (including"
" at the start of a line if there is no colon where expected).  This means"
" that they are recognized as keywords when part of a match statement or "
"case block only, and are allowed to be used in all other contexts as "
"variable or argument names."
msgstr ""

#: ../../peps/pep-0642.rst:252
msgid ""
"Unlike :pep:`634`, patterns are explicitly defined as a new kind of node "
"in the abstract syntax tree - even when surface syntax is shared with "
"existing expression nodes, a distinct abstract node is emitted by the "
"parser."
msgstr ""

#: ../../peps/pep-0642.rst:256
msgid ""
"For context, ``match_stmt`` is a new alternative for "
"``compound_statement`` in the surface syntax and ``Match`` is a new "
"alternative for ``stmt`` in the abstract syntax."
msgstr ""

#: ../../peps/pep-0642.rst:262
msgid "Match Semantics"
msgstr ""

#: ../../peps/pep-0642.rst:264
msgid ""
"This PEP largely retains the overall pattern matching semantics proposed "
"in :pep:`634`."
msgstr ""

#: ../../peps/pep-0642.rst:267
msgid ""
"The proposed syntax for patterns changes significantly, and is discussed "
"in detail below."
msgstr ""

#: ../../peps/pep-0642.rst:270
msgid ""
"There are also some proposed changes to the semantics of class defined "
"constraints (class patterns in :pep:`634`) to eliminate the need to "
"special case any builtin types (instead, the introduction of dedicated "
"syntax for instance attribute constraints allows the behaviour needed by "
"those builtin types to be specified as applying to any type that sets "
"``__match_args__`` to ``None``)"
msgstr ""

#: ../../peps/pep-0642.rst:278
msgid "Guards"
msgstr ""

#: ../../peps/pep-0642.rst:280
msgid "This PEP retains the guard clause semantics proposed in :pep:`634`."
msgstr ""

#: ../../peps/pep-0642.rst:282
msgid ""
"However, the syntax is changed slightly to require that when a guard "
"clause is present, the case pattern must be a *closed* pattern."
msgstr ""

#: ../../peps/pep-0642.rst:285
msgid ""
"This makes it clearer to the reader where the pattern ends and the guard "
"clause begins. (This is mainly a potential problem with OR patterns, "
"where the guard clause looks kind of like the start of a conditional "
"expression in the final pattern. Actually doing that isn't legal syntax, "
"so there's no ambiguity as far as the compiler is concerned, but the "
"distinction may not be as clear to a human reader)"
msgstr ""

#: ../../peps/pep-0642.rst:294
msgid "Irrefutable case blocks"
msgstr ""

#: ../../peps/pep-0642.rst:296
msgid ""
"The definition of irrefutable case blocks changes slightly in this PEP "
"relative to :pep:`634`, as capture patterns no longer exist as a separate"
" concept from AS patterns."
msgstr ""

#: ../../peps/pep-0642.rst:300
msgid ""
"Aside from that caveat, the handling of irrefutable cases is the same as "
"in :pep:`634`:"
msgstr ""

#: ../../peps/pep-0642.rst:303
msgid "wildcard patterns are irrefutable"
msgstr ""

#: ../../peps/pep-0642.rst:304
msgid "AS patterns whose left-hand side is irrefutable"
msgstr ""

#: ../../peps/pep-0642.rst:305
msgid "OR patterns containing at least one irrefutable pattern"
msgstr ""

#: ../../peps/pep-0642.rst:306
msgid "parenthesized irrefutable patterns"
msgstr ""

#: ../../peps/pep-0642.rst:307
msgid ""
"a case block is considered irrefutable if it has no guard and its pattern"
" is irrefutable."
msgstr ""

#: ../../peps/pep-0642.rst:309
msgid ""
"a match statement may have at most one irrefutable case block, and it "
"must be last."
msgstr ""

#: ../../peps/pep-0642.rst:314
msgid "Patterns"
msgstr ""

#: ../../peps/pep-0642.rst:316
msgid "The top-level surface syntax for patterns is as follows::"
msgstr ""

#: ../../peps/pep-0642.rst:335
msgid ""
"As described above, the usage of open patterns is limited to top level "
"case clauses and when parenthesised in a group pattern."
msgstr ""

#: ../../peps/pep-0642.rst:338
msgid ""
"The abstract syntax for patterns explicitly indicates which elements are "
"subpatterns and which elements are subexpressions or identifiers::"
msgstr ""

#: ../../peps/pep-0642.rst:356
msgid "AS Patterns"
msgstr ""

#: ../../peps/pep-0642.rst:364
msgid "(Note: the name on the right may not be ``__``.)"
msgstr ""

#: ../../peps/pep-0642.rst:370
msgid ""
"An AS pattern matches the closed pattern on the left of the ``as`` "
"keyword against the subject.  If this fails, the AS pattern fails. "
"Otherwise, the AS pattern binds the subject to the name on the right of "
"the ``as`` keyword and succeeds."
msgstr ""

#: ../../peps/pep-0642.rst:375
msgid "If no pattern to match is given, the wildcard pattern (``__``) is implied."
msgstr ""

#: ../../peps/pep-0642.rst:377
msgid ""
"To avoid confusion with the `wildcard pattern`_, the double underscore "
"(``__``) is not permitted as a capture target (this is what ``!\"__\"`` "
"expresses)."
msgstr ""

#: ../../peps/pep-0642.rst:380
msgid ""
"A capture pattern always succeeds.  It binds the subject value to the "
"name using the scoping rules for name binding established for named "
"expressions in :pep:`572`.  (Summary: the name becomes a local variable "
"in the closest containing function scope unless there's an applicable "
"``nonlocal`` or ``global`` statement.)"
msgstr ""

#: ../../peps/pep-0642.rst:386
msgid ""
"In a given pattern, a given name may be bound only once.  This disallows "
"for example ``case [as x, as x]: ...`` but allows ``case [as x] | (as "
"x)``:"
msgstr ""

#: ../../peps/pep-0642.rst:390
msgid ""
"As an open pattern, the usage of AS patterns is limited to top level case"
" clauses and when parenthesised in a group pattern. However, several of "
"the structural constraints allow the use of ``pattern_as_clause`` in "
"relevant locations to bind extracted elements of the matched subject to "
"local variables. These are mostly represented in the abstract syntax tree"
" as ``MatchAs`` nodes, aside from the dedicated ``MatchRestOfSequence`` "
"node in sequence patterns."
msgstr ""

#: ../../peps/pep-0642.rst:399
msgid "OR Patterns"
msgstr ""

#: ../../peps/pep-0642.rst:413
msgid ""
"When two or more patterns are separated by vertical bars (``|``), this is"
" called an OR pattern. (A single simple pattern is just that)"
msgstr ""

#: ../../peps/pep-0642.rst:416
msgid "Only the final subpattern may be irrefutable."
msgstr ""

#: ../../peps/pep-0642.rst:418
msgid "Each subpattern must bind the same set of names."
msgstr ""

#: ../../peps/pep-0642.rst:420
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject, "
"until one succeeds.  The OR pattern is then deemed to succeed. If none of"
" the subpatterns succeed the OR pattern fails."
msgstr ""

#: ../../peps/pep-0642.rst:424
msgid ""
"Subpatterns are mostly required to be closed patterns, but the "
"parentheses may be omitted for value constraints."
msgstr ""

#: ../../peps/pep-0642.rst:429
msgid "Value constraints"
msgstr ""

#: ../../peps/pep-0642.rst:455
msgid ""
"The rule ``primary`` is defined in the standard Python grammar, and only "
"allows expressions that either consist of a single token, or else are "
"required to end with a closing delimiter."
msgstr ""

#: ../../peps/pep-0642.rst:459
msgid ""
"Value constraints replace :pep:`634`'s literal patterns and value "
"patterns."
msgstr ""

#: ../../peps/pep-0642.rst:461
msgid ""
"Equality constraints are written as ``== EXPR``, while identity "
"constraints are written as ``is EXPR``."
msgstr ""

#: ../../peps/pep-0642.rst:464
msgid ""
"An equality constraint succeeds if the subject value compares equal to "
"the value given on the right, while an identity constraint succeeds only "
"if they are the exact same object."
msgstr ""

#: ../../peps/pep-0642.rst:468
msgid ""
"The expressions to be compared against are largely restricted to either "
"single tokens (e.g. names, strings, numbers, builtin constants), or else "
"to expressions that are required to end with a closing delimiter."
msgstr ""

#: ../../peps/pep-0642.rst:472
msgid ""
"The use of the high precedence unary operators is also permitted, as the "
"risk of perceived ambiguity is low, and being able to specify negative "
"numbers without parentheses is desirable."
msgstr ""

#: ../../peps/pep-0642.rst:476
msgid ""
"When the same constraint expression occurs multiple times in the same "
"match statement, the interpreter may cache the first value calculated and"
" reuse it, rather than repeat the expression evaluation. (As for "
":pep:`634` value patterns, this cache is strictly tied to a given "
"execution of a given match statement.)"
msgstr ""

#: ../../peps/pep-0642.rst:481
msgid ""
"Unlike literal patterns in :pep:`634`, this PEP requires that complex "
"literals be parenthesised to be accepted by the parser. See the Deferred "
"Ideas section for discussion on that point."
msgstr ""

#: ../../peps/pep-0642.rst:485
msgid ""
"If this PEP were to be adopted in preference to :pep:`634`, then all "
"literal and value patterns would instead be written more explicitly as "
"value constraints::"
msgstr ""

#: ../../peps/pep-0642.rst:544
msgid ""
"Note the ``== preferred_side`` example: using an explicit prefix marker "
"on constraint expressions removes the restriction to only working with "
"attributes or literals for value lookups."
msgstr ""

#: ../../peps/pep-0642.rst:548
msgid ""
"The ``== (1-1j)`` example illustrates the use of parentheses to turn any "
"subexpression into a closed one."
msgstr ""

#: ../../peps/pep-0642.rst:553
msgid "Wildcard Pattern"
msgstr ""

#: ../../peps/pep-0642.rst:563
msgid "A wildcard pattern always succeeds.  As in :pep:`634`, it binds no name."
msgstr ""

#: ../../peps/pep-0642.rst:565
msgid ""
"Where :pep:`634` chooses the single underscore as its wildcard pattern "
"for consistency with other languages, this PEP chooses the double "
"underscore as that has a clearer path towards potentially being made "
"consistent across the entire language, whereas that path is blocked for "
"``\"_\"`` by i18n related use cases."
msgstr ""

#: ../../peps/pep-0642.rst:570
msgid "Example usage::"
msgstr ""

#: ../../peps/pep-0642.rst:583
msgid "Group Patterns"
msgstr ""

#: ../../peps/pep-0642.rst:589
msgid "For the syntax of ``open_pattern``, see Patterns above."
msgstr ""

#: ../../peps/pep-0642.rst:591
msgid ""
"A parenthesized pattern has no additional syntax and is not represented "
"in the abstract syntax tree.  It allows users to add parentheses around "
"patterns to emphasize the intended grouping, and to allow nesting of open"
" patterns when the grammar requires a closed pattern."
msgstr ""

#: ../../peps/pep-0642.rst:596
msgid ""
"Unlike :pep:`634`, there is no potential ambiguity with sequence "
"patterns, as this PEP requires that all sequence patterns be written with"
" square brackets."
msgstr ""

#: ../../peps/pep-0642.rst:601
msgid "Structural constraints"
msgstr ""

#: ../../peps/pep-0642.rst:611
msgid ""
"Note: the separate \"structural constraint\" subcategory isn't used in "
"the abstract syntax tree, it's merely used as a convenient grouping node "
"in the surface syntax definition."
msgstr ""

#: ../../peps/pep-0642.rst:615
msgid ""
"Structural constraints are patterns used to both make assertions about "
"complex objects and to extract values from them."
msgstr ""

#: ../../peps/pep-0642.rst:618
msgid ""
"These patterns may all bind multiple values, either through the use of "
"nested AS patterns, or else through the use of ``pattern_as_clause`` "
"elements included in the definition of the pattern."
msgstr ""

#: ../../peps/pep-0642.rst:624
msgid "Sequence constraints"
msgstr ""

#: ../../peps/pep-0642.rst:648
msgid ""
"Sequence constraints allow items within a sequence to be checked and "
"optionally extracted."
msgstr ""

#: ../../peps/pep-0642.rst:651
msgid ""
"A sequence pattern fails if the subject value is not an instance of "
"``collections.abc.Sequence``.  It also fails if the subject value is an "
"instance of ``str``, ``bytes`` or ``bytearray`` (see Deferred Ideas for a"
" discussion on potentially removing the need for this special casing)."
msgstr ""

#: ../../peps/pep-0642.rst:656
msgid ""
"A sequence pattern may contain at most one star subpattern.  The star "
"subpattern may occur in any position and is represented in the AST using "
"the ``MatchRestOfSequence`` node."
msgstr ""

#: ../../peps/pep-0642.rst:660
msgid ""
"If no star subpattern is present, the sequence pattern is a fixed-length "
"sequence pattern; otherwise it is a variable-length sequence pattern."
msgstr ""

#: ../../peps/pep-0642.rst:663
msgid ""
"A fixed-length sequence pattern fails if the length of the subject "
"sequence is not equal to the number of subpatterns."
msgstr ""

#: ../../peps/pep-0642.rst:666
msgid ""
"A variable-length sequence pattern fails if the length of the subject "
"sequence is less than the number of non-star subpatterns."
msgstr ""

#: ../../peps/pep-0642.rst:669
msgid ""
"The length of the subject sequence is obtained using the builtin "
"``len()`` function (i.e., via the ``__len__`` protocol).  However, the "
"interpreter may cache this value in a similar manner as described for "
"value constraint expressions."
msgstr ""

#: ../../peps/pep-0642.rst:674
msgid ""
"A fixed-length sequence pattern matches the subpatterns to corresponding "
"items of the subject sequence, from left to right. Matching stops (with a"
" failure) as soon as a subpattern fails.  If all subpatterns succeed in "
"matching their corresponding item, the sequence pattern succeeds."
msgstr ""

#: ../../peps/pep-0642.rst:680
msgid ""
"A variable-length sequence pattern first matches the leading non-star "
"subpatterns to the corresponding items of the subject sequence, as for a "
"fixed-length sequence.  If this succeeds, the star subpattern matches a "
"list formed of the remaining subject items, with items removed from the "
"end corresponding to the non-star subpatterns following the star "
"subpattern.  The remaining non-star subpatterns are then matched to the "
"corresponding subject items, as for a fixed-length sequence."
msgstr ""

#: ../../peps/pep-0642.rst:689
msgid ""
"Subpatterns are mostly required to be closed patterns, but the "
"parentheses may be omitted for value constraints. Sequence elements may "
"also be captured unconditionally without parentheses."
msgstr ""

#: ../../peps/pep-0642.rst:693
msgid ""
"Note: where :pep:`634` allows all the same syntactic flexibility as "
"iterable unpacking in assignment statements, this PEP restricts sequence "
"patterns specifically to the square bracket form. Given that the open and"
" parenthesised forms are far more popular than square brackets for "
"iterable unpacking, this helps emphasise that iterable unpacking and "
"sequence matching are *not* the same operation. It also avoids the "
"parenthesised form's ambiguity problem between single element sequence "
"patterns and group patterns."
msgstr ""

#: ../../peps/pep-0642.rst:703
msgid "Mapping constraints"
msgstr ""

#: ../../peps/pep-0642.rst:715
msgid ""
"(Note that ``**__`` is deliberately disallowed by this syntax, as "
"additional mapping entries are ignored by default)"
msgstr ""

#: ../../peps/pep-0642.rst:718
msgid "closed_expr is defined above, under value constraints."
msgstr ""

#: ../../peps/pep-0642.rst:724
msgid ""
"Mapping constraints allow keys and values within a sequence to be checked"
" and values to optionally be extracted."
msgstr ""

#: ../../peps/pep-0642.rst:727
msgid ""
"A mapping pattern fails if the subject value is not an instance of "
"``collections.abc.Mapping``."
msgstr ""

#: ../../peps/pep-0642.rst:730
msgid ""
"A mapping pattern succeeds if every key given in the mapping pattern is "
"present in the subject mapping, and the pattern for each key matches the "
"corresponding item of the subject mapping."
msgstr ""

#: ../../peps/pep-0642.rst:734
msgid ""
"The presence of keys is checked using the two argument form of the "
"``get`` method and a unique sentinel value, which offers the following "
"benefits:"
msgstr ""

#: ../../peps/pep-0642.rst:737
msgid "no exceptions need to be created in the lookup process"
msgstr ""

#: ../../peps/pep-0642.rst:738
msgid ""
"mappings that implement ``__missing__`` (such as "
"``collections.defaultdict``) only match on keys that they already "
"contain, they don't implicitly add keys"
msgstr ""

#: ../../peps/pep-0642.rst:741
msgid ""
"A mapping pattern may not contain duplicate key values. If duplicate keys"
" are detected when checking the mapping pattern, the pattern is "
"considered invalid, and a ``ValueError`` is raised. While it would "
"theoretically be possible to checked for duplicated constant keys at "
"compile time, no such check is currently defined or implemented."
msgstr ""

#: ../../peps/pep-0642.rst:747
msgid ""
"(Note: This semantic description is derived from the :pep:`634` reference"
" implementation, which differs from the :pep:`634` specification text at "
"time of writing. The implementation seems reasonable, so amending the PEP"
" text seems like the best way to resolve the discrepancy)"
msgstr ""

#: ../../peps/pep-0642.rst:752
msgid ""
"If a ``'**' as NAME`` double star pattern is present, that name is bound "
"to a ``dict`` containing any remaining key-value pairs from the subject "
"mapping (the dict will be empty if there are no additional key-value "
"pairs)."
msgstr ""

#: ../../peps/pep-0642.rst:756
msgid ""
"A mapping pattern may contain at most one double star pattern, and it "
"must be last."
msgstr ""

#: ../../peps/pep-0642.rst:759
msgid ""
"Value subpatterns are mostly required to be closed patterns, but the "
"parentheses may be omitted for value constraints (the ``:`` key/value "
"separator is still required to ensure the entry doesn't look like an "
"ordinary comparison operation)."
msgstr ""

#: ../../peps/pep-0642.rst:763
msgid ""
"Mapping values may also be captured unconditionally using the ``KEY as "
"NAME`` form, without either parentheses or the ``:`` key/value separator."
msgstr ""

#: ../../peps/pep-0642.rst:768
msgid "Instance attribute constraints"
msgstr ""

#: ../../peps/pep-0642.rst:785
msgid ""
"Instance attribute constraints allow an instance's type to be checked and"
" attributes to optionally be extracted."
msgstr ""

#: ../../peps/pep-0642.rst:788
msgid ""
"An instance attribute constraint may not repeat the same attribute name "
"multiple times. Attempting to do so will result in a syntax error."
msgstr ""

#: ../../peps/pep-0642.rst:791
msgid ""
"An instance attribute pattern fails if the subject is not an instance of "
"``name_or_attr``. This is tested using ``isinstance()``."
msgstr ""

#: ../../peps/pep-0642.rst:794
msgid ""
"If ``name_or_attr`` is not an instance of the builtin ``type``, "
"``TypeError`` is raised."
msgstr ""

#: ../../peps/pep-0642.rst:797
msgid ""
"If no attribute subpatterns are present, the constraint succeeds if the "
"``isinstance()`` check succeeds. Otherwise:"
msgstr ""

#: ../../peps/pep-0642.rst:800
msgid "Each given attribute name is looked up as an attribute on the subject."
msgstr ""

#: ../../peps/pep-0642.rst:802
msgid ""
"If this raises an exception other than ``AttributeError``, the exception "
"bubbles up."
msgstr ""

#: ../../peps/pep-0642.rst:805
msgid "If this raises ``AttributeError`` the constraint fails."
msgstr ""

#: ../../peps/pep-0642.rst:807
msgid ""
"Otherwise, the subpattern associated with the keyword is matched against "
"the attribute value. If no subpattern is specified, the wildcard pattern "
"is assumed. If this fails, the constraint fails. If it succeeds, the "
"match proceeds to the next attribute."
msgstr ""

#: ../../peps/pep-0642.rst:812
msgid "If all attribute subpatterns succeed, the constraint as a whole succeeds."
msgstr ""

#: ../../peps/pep-0642.rst:814
msgid ""
"Instance attribute constraints allow ducktyping checks to be implemented "
"by using ``object`` as the required instance type (e.g. ``case "
"object{.host as host, .port as port}:``)."
msgstr ""

#: ../../peps/pep-0642.rst:818
msgid ""
"The syntax being proposed here could potentially also be used as the "
"basis for a new syntax for retrieving multiple attributes from an object "
"instance in one assignment statement (e.g. ``host, port = addr{.host, "
".port}``). See the Deferred Ideas section for further discussion of this "
"point."
msgstr ""

#: ../../peps/pep-0642.rst:825
msgid "Class defined constraints"
msgstr ""

#: ../../peps/pep-0642.rst:845
msgid ""
"Class defined constraints allow a sequence of common attributes to be "
"specified on a class and checked positionally, rather than needing to "
"specify the attribute names in every related match pattern."
msgstr ""

#: ../../peps/pep-0642.rst:849
msgid "As for instance attribute patterns:"
msgstr ""

#: ../../peps/pep-0642.rst:851
msgid ""
"a class defined pattern fails if the subject is not an instance of "
"``name_or_attr``. This is tested using ``isinstance()``."
msgstr ""

#: ../../peps/pep-0642.rst:853
msgid ""
"if ``name_or_attr`` is not an instance of the builtin ``type``, "
"``TypeError`` is raised."
msgstr ""

#: ../../peps/pep-0642.rst:856
msgid ""
"Regardless of whether or not any arguments are present, the subject is "
"checked for a ``__match_args__`` attribute using the equivalent of "
"``getattr(cls, \"__match_args__\", _SENTINEL))``."
msgstr ""

#: ../../peps/pep-0642.rst:860
msgid "If this raises an exception the exception bubbles up."
msgstr ""

#: ../../peps/pep-0642.rst:862
msgid ""
"If the returned value is not a list, tuple, or ``None``, the conversion "
"fails and ``TypeError`` is raised at runtime."
msgstr ""

#: ../../peps/pep-0642.rst:865
msgid ""
"This means that only types that actually define ``__match_args__`` will "
"be usable in class defined patterns. Types that don't define "
"``__match_args__`` will still be usable in instance attribute patterns."
msgstr ""

#: ../../peps/pep-0642.rst:869
msgid ""
"If ``__match_args__`` is ``None``, then only a single positional "
"subpattern is permitted. Attempting to specify additional attribute "
"patterns either positionally or using the double star syntax will cause "
"``TypeError`` to be raised at runtime."
msgstr ""

#: ../../peps/pep-0642.rst:874
msgid ""
"This positional subpattern is then matched against the entire subject, "
"allowing a type check to be combined with another match pattern (e.g. "
"checking both the type and contents of a container, or the type and value"
" of a number)."
msgstr ""

#: ../../peps/pep-0642.rst:878
msgid ""
"If ``__match_args__`` is a list or tuple, then the class defined "
"constraint is converted to an instance attributes constraint as follows:"
msgstr ""

#: ../../peps/pep-0642.rst:881
msgid ""
"if only the double star attribute constraints subpattern is present, "
"matching proceeds as if for the equivalent instance attributes "
"constraint."
msgstr ""

#: ../../peps/pep-0642.rst:883
msgid ""
"if there are more positional subpatterns than the length of "
"``__match_args__`` (as obtained using ``len()``), ``TypeError`` is "
"raised."
msgstr ""

#: ../../peps/pep-0642.rst:885
msgid ""
"Otherwise, positional pattern ``i`` is converted to an attribute pattern "
"using ``__match_args__[i]`` as the attribute name."
msgstr ""

#: ../../peps/pep-0642.rst:887
msgid ""
"if any element in ``__match_args__`` is not a string, ``TypeError`` is "
"raised."
msgstr ""

#: ../../peps/pep-0642.rst:888
msgid ""
"once the positional patterns have been converted to attribute patterns, "
"then they are combined with any attribute constraints given in the double"
" star attribute constraints subpattern, and matching proceeds as if for "
"the equivalent instance attributes constraint."
msgstr ""

#: ../../peps/pep-0642.rst:893
msgid ""
"Note: the ``__match_args__ is None`` handling in this PEP replaces the "
"special casing of ``bool``, ``bytearray``, ``bytes``, ``dict``, "
"``float``, ``frozenset``, ``int``, ``list``, ``set``, ``str``, and "
"``tuple`` in :pep:`634`. However, the optimised fast path for those types"
" is retained in the implementation."
msgstr ""

#: ../../peps/pep-0642.rst:901
msgid "Design Discussion"
msgstr ""

#: ../../peps/pep-0642.rst:904
msgid "Requiring explicit qualification of simple names in match patterns"
msgstr ""

#: ../../peps/pep-0642.rst:906
msgid ""
"The first iteration of this PEP accepted the basic premise of :pep:`634` "
"that iterable unpacking syntax would provide a good foundation for "
"defining a new syntax for pattern matching."
msgstr ""

#: ../../peps/pep-0642.rst:910
msgid ""
"During the review process, however, two major and one minor ambiguity "
"problems were highlighted that arise directly from that core assumption:"
msgstr ""

#: ../../peps/pep-0642.rst:913
msgid ""
"most problematically, when binding simple names by default is extended to"
" :pep:`634`'s proposed class pattern syntax, the ``ATTR=TARGET_NAME`` "
"construct binds to the right without using the ``as`` keyword, and uses "
"the normal assignment-to-the-left sigil (``=``) to do it!"
msgstr ""

#: ../../peps/pep-0642.rst:917
msgid ""
"when binding simple names by default is extended to :pep:`634`'s proposed"
" mapping pattern syntax, the ``KEY: TARGET_NAME`` construct binds to the "
"right without using the ``as`` keyword"
msgstr ""

#: ../../peps/pep-0642.rst:920
msgid ""
"using a :pep:`634` capture pattern together with an AS pattern "
"(``TARGET_NAME_1 as TARGET_NAME_2``) gives an odd \"binds to both the "
"left and right\" behaviour"
msgstr ""

#: ../../peps/pep-0642.rst:924
msgid ""
"The third revision of this PEP accounted for this problem by abandoning "
"the alignment with iterable unpacking syntax, and instead requiring that "
"all uses of bare simple names for anything other than a variable lookup "
"be qualified by a preceding sigil or keyword:"
msgstr ""

#: ../../peps/pep-0642.rst:929
msgid "``as NAME``: local variable binding"
msgstr ""

#: ../../peps/pep-0642.rst:930
msgid "``.NAME``: attribute lookup"
msgstr ""

#: ../../peps/pep-0642.rst:931
msgid "``== NAME``: variable lookup"
msgstr ""

#: ../../peps/pep-0642.rst:932
msgid "``is NAME``: variable lookup"
msgstr ""

#: ../../peps/pep-0642.rst:933
msgid "any other usage: variable lookup"
msgstr ""

#: ../../peps/pep-0642.rst:935
msgid ""
"The key benefit of this approach is that it makes interpretation of "
"simple names in patterns a local activity: a leading ``as`` indicates a "
"name binding, a leading ``.`` indicates an attribute lookup, and anything"
" else is a variable lookup (regardless of whether we're reading a "
"subpattern or a subexpression)."
msgstr ""

#: ../../peps/pep-0642.rst:940
msgid ""
"With the syntax now proposed in this PEP, the problematic cases "
"identified above no longer read poorly:"
msgstr ""

#: ../../peps/pep-0642.rst:943
msgid ""
"``.ATTR as TARGET_NAME`` is more obviously a binding than "
"``ATTR=TARGET_NAME``"
msgstr ""

#: ../../peps/pep-0642.rst:944
msgid ""
"``KEY as TARGET_NAME`` is more obviously a binding than ``KEY: "
"TARGET_NAME``"
msgstr ""

#: ../../peps/pep-0642.rst:945
msgid ""
"``(as TARGET_NAME_1) as TARGET_NAME_2`` is more obviously two bindings "
"than ``TARGET_NAME_1 as TARGET_NAME_2``"
msgstr ""

#: ../../peps/pep-0642.rst:950
msgid "Resisting the temptation to guess"
msgstr ""

#: ../../peps/pep-0642.rst:952
msgid ""
":pep:`635` looks at the way pattern matching is used in other languages, "
"and attempts to use that information to make plausible predictions about "
"the way pattern matching will be used in Python:"
msgstr ""

#: ../../peps/pep-0642.rst:956
msgid ""
"wanting to extract values to local names will *probably* be more common "
"than wanting to match against values stored in local names"
msgstr ""

#: ../../peps/pep-0642.rst:958
msgid ""
"wanting comparison by equality will *probably* be more common than "
"wanting comparison by identity"
msgstr ""

#: ../../peps/pep-0642.rst:960
msgid ""
"users will *probably* be able to at least remember that bare names bind "
"values and attribute references look up values, even if they can't figure"
" that out for themselves without reading the documentation or having "
"someone tell them"
msgstr ""

#: ../../peps/pep-0642.rst:964
msgid ""
"To be clear, I think these predictions actually *are* plausible. However,"
" I also don't think we need to guess about this up front: I think we can "
"start out with a more explicit syntax that requires users to state their "
"intent using a prefix marker (either ``as``, ``==``, or ``is``), and then"
" reassess the situation in a few years based on how pattern matching is "
"actually being used *in Python*."
msgstr ""

#: ../../peps/pep-0642.rst:970
msgid ""
"At that point, we'll be able to choose amongst at least the following "
"options:"
msgstr ""

#: ../../peps/pep-0642.rst:972
msgid "deciding the explicit syntax is concise enough, and not changing anything"
msgstr ""

#: ../../peps/pep-0642.rst:973
msgid ""
"adding inferred identity constraints for one or more of ``None``, "
"``...``, ``True`` and ``False``"
msgstr ""

#: ../../peps/pep-0642.rst:975
msgid ""
"adding inferred equality constraints for other literals (potentially "
"including complex literals)"
msgstr ""

#: ../../peps/pep-0642.rst:977
msgid "adding inferred equality constraints for attribute lookups"
msgstr ""

#: ../../peps/pep-0642.rst:978
msgid ""
"adding either inferred equality constraints or inferred capture patterns "
"for bare names"
msgstr ""

#: ../../peps/pep-0642.rst:981
msgid ""
"All of those ideas could be considered independently on their own merits,"
" rather than being a potential barrier to introducing pattern matching in"
" the first place."
msgstr ""

#: ../../peps/pep-0642.rst:985
msgid ""
"If any of these syntactic shortcuts were to eventually be introduced, "
"they'd also be straightforward to explain in terms of the underlying more"
" explicit syntax (the leading ``as``, ``==``, or ``is`` would just be "
"getting inferred by the parser, without the user needing to provide it "
"explicitly). At the implementation level, only the parser should need to "
"be change, as the existing AST nodes could be reused."
msgstr ""

#: ../../peps/pep-0642.rst:994
msgid "Interaction with caching of attribute lookups in local variables"
msgstr ""

#: ../../peps/pep-0642.rst:996
msgid ""
"One of the major changes between this PEP and :pep:`634` is to use ``== "
"EXPR`` for equality constraint lookups, rather than only offering "
"``NAME.ATTR``. The original motivation for this was to avoid the semantic"
" conflict with regular assignment targets, where ``NAME.ATTR`` is already"
" used in assignment statements to set attributes, so if ``NAME.ATTR`` "
"were the *only* syntax for symbolic value matching, then we're pre-"
"emptively ruling out any future attempts to allow matching against single"
" patterns using the existing assignment statement syntax. The current "
"motivation is more about the general desire to avoid guessing about "
"user's intent, and instead requiring them to state it explicitly in the "
"syntax."
msgstr ""

#: ../../peps/pep-0642.rst:1006
msgid ""
"However, even within match statements themselves, the ``name.attr`` "
"syntax for value patterns has an undesirable interaction with local "
"variable assignment, where routine refactorings that would be "
"semantically neutral for any other Python statement introduce a major "
"semantic change when applied to a :pep:`634` style match statement."
msgstr ""

#: ../../peps/pep-0642.rst:1012
msgid "Consider the following code::"
msgstr ""

#: ../../peps/pep-0642.rst:1017
msgid ""
"The attribute lookup can be safely lifted out of the loop and only "
"performed once::"
msgstr ""

#: ../../peps/pep-0642.rst:1024
msgid ""
"With the marker prefix based syntax proposal in this PEP, value "
"constraints would be similarly tolerant of match patterns being "
"refactored to use a local variable instead of an attribute lookup, with "
"the following two statements being functionally equivalent::"
msgstr ""

#: ../../peps/pep-0642.rst:1042
msgid ""
"By contrast, when using :pep:`634`'s value and capture pattern syntaxes "
"that omit the marker prefix, the following two statements wouldn't be "
"equivalent at all::"
msgstr ""

#: ../../peps/pep-0642.rst:1060
msgid ""
"This PEP ensures the original semantics are retained under this style of "
"simplistic refactoring: use ``== name`` to force interpretation of the "
"result as a value constraint, use ``as name`` for a name binding."
msgstr ""

#: ../../peps/pep-0642.rst:1064
msgid ""
":pep:`634`'s proposal to offer only the shorthand syntax, with no "
"explicitly prefixed form, means that the primary answer on offer is "
"\"Well, don't do that, then, only compare against attributes in "
"namespaces, don't compare against simple names\"."
msgstr ""

#: ../../peps/pep-0642.rst:1069
msgid ""
":pep:`622`'s walrus pattern syntax had another odd interaction where it "
"might not bind the same object as the exact same walrus expression in the"
" body of the case clause, but :pep:`634` fixed that discrepancy by "
"replacing walrus patterns with AS patterns (where the fact that the value"
" bound to the name on the RHS might not be the same value as returned by "
"the LHS is a standard feature common to all uses of the \"as\" keyword)."
msgstr ""

#: ../../peps/pep-0642.rst:1078
msgid "Using existing comparison operators as the value constraint prefix"
msgstr ""

#: ../../peps/pep-0642.rst:1080
msgid ""
"If the benefit of a dedicated value constraint prefix is accepted, then "
"the next question is to ask exactly what that prefix should be."
msgstr ""

#: ../../peps/pep-0642.rst:1083
msgid ""
"The initially published version of this PEP proposed using the previously"
" unused ``?`` symbol as the prefix for equality constraints, and ``?is`` "
"as the prefix for identity constraints. When reviewing the PEP, Steven "
"D'Aprano presented a compelling counterproposal [5]_ to use the existing "
"comparison operators (``==`` and ``is``) instead."
msgstr ""

#: ../../peps/pep-0642.rst:1089
msgid ""
"There were a few concerns with ``==`` as a prefix that kept it from being"
" chosen as the prefix in the initial iteration of the PEP:"
msgstr ""

#: ../../peps/pep-0642.rst:1092
msgid ""
"for common use cases, it's even more visually noisy than ``?``, as a lot "
"of folks with :pep:`8` trained aesthetic sensibilities are going to want "
"to put a space between it and the following expression, effectively "
"making it a 3 character prefix instead of 1"
msgstr ""

#: ../../peps/pep-0642.rst:1096
msgid ""
"when used in a mapping pattern, there needs to be a space between the "
"``:`` key/value separator and the ``==`` prefix, or the tokeniser will "
"split them up incorrectly (getting ``:=`` and ``=`` instead of ``:`` and "
"``==``)"
msgstr ""

#: ../../peps/pep-0642.rst:1099
msgid ""
"when used in an OR pattern, there needs to be a space between the ``|`` "
"pattern separator and the ``==`` prefix, or the tokeniser will split them"
" up incorrectly (getting ``|=`` and ``=`` instead of ``|`` and ``==``)"
msgstr ""

#: ../../peps/pep-0642.rst:1102
msgid ""
"if used in a :pep:`634` style class pattern, there needs to be a space "
"between the ``=`` keyword separator and the ``==`` prefix, or the "
"tokeniser will split them up incorrectly (getting ``==`` and ``=`` "
"instead of ``=`` and ``==``)"
msgstr ""

#: ../../peps/pep-0642.rst:1106
msgid ""
"Rather than introducing a completely new symbol, Steven's proposed "
"resolution to this verbosity problem was to retain the ability to omit "
"the prefix marker in syntactically unambiguous cases."
msgstr ""

#: ../../peps/pep-0642.rst:1110
msgid ""
"While the idea of omitting the prefix marker was accepted for the second "
"revision of the proposal, it was dropped again in the third revision due "
"to ambiguity concerns. Instead, the following points apply:"
msgstr ""

#: ../../peps/pep-0642.rst:1114
msgid ""
"for class patterns, other syntax changes allow equality constraints to be"
" written as ``.ATTR == EXPR``, and identity constraints to be written as "
"``.ATTR is EXPR``, both of which are quite easy to read"
msgstr ""

#: ../../peps/pep-0642.rst:1117
msgid ""
"for mapping patterns, the extra syntactic noise is just tolerated (at "
"least for now)"
msgstr ""

#: ../../peps/pep-0642.rst:1119
msgid ""
"for OR patterns, the extra syntactic noise is just tolerated (at least "
"for now). However, `membership constraints`_ may offer a future path to "
"reducing the need to combine OR patterns with equality constraints "
"(instead, the values to be checked against would be collected as a set, "
"list, or tuple)."
msgstr ""

#: ../../peps/pep-0642.rst:1124
msgid ""
"Given that perspective, :pep:`635`'s arguments against using ``?`` as "
"part of the pattern matching syntax held for this proposal as well, and "
"so the PEP was amended accordingly."
msgstr ""

#: ../../peps/pep-0642.rst:1130
msgid "Using ``__`` as the wildcard pattern marker"
msgstr ""

#: ../../peps/pep-0642.rst:1132
msgid ""
":pep:`635` makes a solid case that introducing ``?`` *solely* as a "
"wildcard pattern marker would be a bad idea. With the syntax for value "
"constraints changed to use existing comparison operations rather than "
"``?`` and ``?is``, that argument holds for this PEP as well."
msgstr ""

#: ../../peps/pep-0642.rst:1137
msgid ""
"However, as noted by Thomas Wouters in [6]_, :pep:`634`'s choice of ``_``"
" remains problematic as it would likely mean that match patterns would "
"have a *permanent* difference from all other parts of Python - the use of"
" ``_`` in software internationalisation and at the interactive prompt "
"means that there isn't really a plausible path towards using it as a "
"general purpose \"skipped binding\" marker."
msgstr ""

#: ../../peps/pep-0642.rst:1143
msgid ""
"``__`` is an alternative \"this value is not needed\" marker drawn from a"
" Stack Overflow answer [7]_ (originally posted by the author of this PEP)"
" on the various meanings of ``_`` in existing Python code."
msgstr ""

#: ../../peps/pep-0642.rst:1147
msgid ""
"This PEP also proposes adopting an implementation technique that limits "
"the scope of the associated special casing of ``__`` to the parser: "
"defining a new AST node type (``MatchAlways``) specifically for wildcard "
"markers, rather than passing it through to the AST as a ``Name`` node."
msgstr ""

#: ../../peps/pep-0642.rst:1152
msgid ""
"Within the parser, ``__`` still means either a regular name or a wildcard"
" marker in a match pattern depending on where you were in the parse tree,"
" but within the rest of the compiler, ``Name(\"__\")`` is still a normal "
"variable name, while ``MatchAlways()`` is always a wildcard marker in a "
"match pattern."
msgstr ""

#: ../../peps/pep-0642.rst:1157
msgid ""
"Unlike ``_``, the lack of other use cases for ``__`` means that there "
"would be a plausible path towards restoring identifier handling "
"consistency with the rest of the language by making ``__`` mean \"skip "
"this name binding\" everywhere in Python:"
msgstr ""

#: ../../peps/pep-0642.rst:1162
msgid ""
"in the interpreter itself, deprecate loading variables with the name "
"``__``. This would make reading from ``__`` emit a deprecation warning, "
"while writing to it would initially be unchanged. To avoid slowing down "
"all name loads, this could be handled by having the compiler emit "
"additional code for the deprecated name, rather than using a runtime "
"check in the standard name loading opcodes."
msgstr ""

#: ../../peps/pep-0642.rst:1168
msgid ""
"after a suitable number of releases, change the parser to emit a new "
"``SkippedBinding`` AST node for all uses of ``__`` as an assignment "
"target, and update the rest of the compiler accordingly"
msgstr ""

#: ../../peps/pep-0642.rst:1171
msgid "consider making ``__`` a true hard keyword rather than a soft keyword"
msgstr ""

#: ../../peps/pep-0642.rst:1173
msgid ""
"This deprecation path couldn't be followed for ``_``, as there's no way "
"for the interpreter to distinguish between attempts to read back ``_`` "
"when nominally used as a \"don't care\" marker, and legitimate reads of "
"``_`` as either an i18n text translation function or as the last "
"statement result at the interactive prompt."
msgstr ""

#: ../../peps/pep-0642.rst:1179
msgid ""
"Names starting with double-underscores are also already reserved for use "
"by the language, whether that is for compile time constants (i.e. "
"``__debug__``), special methods, or class attribute name mangling, so "
"using ``__`` here would be consistent with that existing approach."
msgstr ""

#: ../../peps/pep-0642.rst:1186
msgid "Representing patterns explicitly in the Abstract Syntax Tree"
msgstr ""

#: ../../peps/pep-0642.rst:1188
msgid ""
":pep:`634` doesn't explicitly discuss how match statements should be "
"represented in the Abstract Syntax Tree, instead leaving that detail to "
"be defined as part of the implementation."
msgstr ""

#: ../../peps/pep-0642.rst:1192
msgid ""
"As a result, while the reference implementation of :pep:`634` definitely "
"works (and formed the basis of the reference implementation of this PEP),"
" it does contain a significant design flaw: despite the notes in "
":pep:`635` that patterns should be considered as distinct from "
"expressions, the reference implementation goes ahead and represents them "
"in the AST as expression nodes."
msgstr ""

#: ../../peps/pep-0642.rst:1198
msgid ""
"The result is an AST that isn't very abstract at all: nodes that should "
"be compiled completely differently (because they're patterns rather than "
"expressions) are represented the same way, and the type system of the "
"implementation language (e.g. C for CPython) can't offer any assistance "
"in keeping track of which subnodes should be ordinary expressions and "
"which should be subpatterns."
msgstr ""

#: ../../peps/pep-0642.rst:1205
msgid ""
"Rather than continuing with that approach, this PEP has instead defined a"
" new explicit \"pattern\" node in the AST, which allows the patterns and "
"their permitted subnodes to be defined explicitly in the AST itself, "
"making the code implementing the new feature clearer, and allowing the C "
"compiler to provide more assistance in keeping track of when the code "
"generator is dealing with patterns or expressions."
msgstr ""

#: ../../peps/pep-0642.rst:1212
msgid ""
"This change in implementation approach is actually orthogonal to the "
"surface syntax changes proposed in this PEP, so it could still be adopted"
" even if the rest of the PEP were to be rejected."
msgstr ""

#: ../../peps/pep-0642.rst:1218
msgid "Changes to sequence patterns"
msgstr ""

#: ../../peps/pep-0642.rst:1220
msgid ""
"This PEP makes one notable change to sequence patterns relative to "
":pep:`634`:"
msgstr ""

#: ../../peps/pep-0642.rst:1222
msgid ""
"only the square bracket form of sequence pattern is supported. Neither "
"open (no delimiters) nor tuple style (parentheses as delimiters) sequence"
" patterns are supported."
msgstr ""

#: ../../peps/pep-0642.rst:1226
msgid ""
"Relative to :pep:`634`, sequence patterns are also significantly affected"
" by the change to require explicit qualification of capture patterns and "
"value constraints, as it means ``case [a, b, c]:`` must instead be "
"written as ``case [as a, as b, as c]:`` and ``case [0, 1]:`` must instead"
" be written as ``case [== 0, == 1]:``."
msgstr ""

#: ../../peps/pep-0642.rst:1232
msgid ""
"With the syntax for sequence patterns no longer being derived directly "
"from the syntax for iterable unpacking, it no longer made sense to keep "
"the syntactic flexibility that had been included in the original syntax "
"proposal purely for consistency with iterable unpacking."
msgstr ""

#: ../../peps/pep-0642.rst:1237
msgid ""
"Allowing open and tuple style sequence patterns didn't increase "
"expressivity, only ambiguity of intent (especially relative to group "
"patterns), and encouraged readers down the path of viewing pattern "
"matching syntax as intrinsically linked to assignment target syntax "
"(which the :pep:`634` authors have stated multiple times is not a "
"desirable path to have readers take, and a view the author of this PEP "
"now shares, despite disagreeing with it originally)."
msgstr ""

#: ../../peps/pep-0642.rst:1246
msgid "Changes to mapping patterns"
msgstr ""

#: ../../peps/pep-0642.rst:1248
msgid ""
"This PEP makes two notable changes to mapping patterns relative to "
":pep:`634`:"
msgstr ""

#: ../../peps/pep-0642.rst:1250
msgid "value capturing is written as ``KEY as NAME`` rather than as ``KEY: NAME``"
msgstr ""

#: ../../peps/pep-0642.rst:1251
msgid ""
"a wider range of keys are permitted: any \"closed expression\", rather "
"than only literals and attribute references"
msgstr ""

#: ../../peps/pep-0642.rst:1254
msgid ""
"As discussed above, the first change is part of ensuring that all binding"
" operations with the target name to the right of a subexpression or "
"pattern use the ``as`` keyword."
msgstr ""

#: ../../peps/pep-0642.rst:1258
msgid ""
"The second change is mostly a matter of simplifying the parser and code "
"generator code by reusing the existing expression handling machinery. The"
" restriction to closed expressions is designed to help reduce ambiguity "
"as to where the key expression ends and the match pattern begins. This "
"mostly allows a superset of what :pep:`634` allows, except that complex "
"literals must be written in parentheses (at least for now)."
msgstr ""

#: ../../peps/pep-0642.rst:1265
msgid ""
"Adapting :pep:`635`'s mapping pattern examples to the syntax proposed in "
"this PEP::"
msgstr ""

#: ../../peps/pep-0642.rst:1283 ../../peps/pep-0642.rst:1376
msgid "For reference, the equivalent :pep:`634` syntax::"
msgstr ""

#: ../../peps/pep-0642.rst:1303
msgid "Changes to class patterns"
msgstr ""

#: ../../peps/pep-0642.rst:1305
msgid ""
"This PEP makes several notable changes to class patterns relative to "
":pep:`634`:"
msgstr ""

#: ../../peps/pep-0642.rst:1307
msgid ""
"the syntactic alignment with class instantiation is abandoned as being "
"actively misleading and unhelpful. Instead, a new dedicated syntax for "
"checking additional attributes is introduced that draws inspiration from "
"mapping patterns rather than class instantiation"
msgstr ""

#: ../../peps/pep-0642.rst:1311
msgid ""
"a new dedicated syntax for simple ducktyping that will work for any class"
" is introduced"
msgstr ""

#: ../../peps/pep-0642.rst:1313
msgid ""
"the special casing of various builtin and standard library types is "
"supplemented by a general check for the existence of a ``__match_args__``"
" attribute with the value of ``None``"
msgstr ""

#: ../../peps/pep-0642.rst:1317
msgid "As discussed above, the first change has two purposes:"
msgstr ""

#: ../../peps/pep-0642.rst:1319
msgid ""
"it's part of ensuring that all binding operations with the target name to"
" the right of a subexpression or pattern use the ``as`` keyword. Using "
"``=`` to assign to the right is particularly problematic."
msgstr ""

#: ../../peps/pep-0642.rst:1322
msgid ""
"it's part of ensuring that all uses of simple names in patterns have a "
"prefix that indicates their purpose (in this case, a leading ``.`` to "
"indicate an attribute lookup)"
msgstr ""

#: ../../peps/pep-0642.rst:1326
msgid ""
"The syntactic alignment with class instantion was also judged to be "
"unhelpful in general, as class patterns are about matching patterns "
"against attributes, while class instantiation is about matching call "
"arguments to parameters in class constructors, which may not bear much "
"resemblance to the resulting instance attributes at all."
msgstr ""

#: ../../peps/pep-0642.rst:1332
msgid ""
"The second change is intended to make it easier to use pattern matching "
"for the \"ducktyping\" style checks that are already common in Python."
msgstr ""

#: ../../peps/pep-0642.rst:1335
msgid ""
"The concrete syntax proposal for these patterns then arose from viewing "
"instances as mappings of attribute names to values, and combining the "
"attribute lookup syntax (``.ATTR``), with the mapping pattern syntax "
"``{KEY: PATTERN}`` to give ``cls{.ATTR: PATTERN}``."
msgstr ""

#: ../../peps/pep-0642.rst:1340
msgid ""
"Allowing ``cls{.ATTR}`` to mean the same thing as ``cls{.ATTR: __}`` was "
"a matter of considering the leading ``.`` sufficient to render the name "
"usage unambiguous (it's clearly an attribute reference, whereas matching "
"against a variable key in a mapping pattern would be arguably ambiguous)"
msgstr ""

#: ../../peps/pep-0642.rst:1345
msgid ""
"The final change just supplements a CPython-internal-only check in the "
":pep:`634` reference implementation by making it the default behaviour "
"that classes get if they don't define ``__match_args__`` (the optimised "
"fast path for the builtin and standard library types named in :pep:`634` "
"is retained)."
msgstr ""

#: ../../peps/pep-0642.rst:1350
msgid ""
"Adapting the class matching example `linked from PEP 635 "
"<https://github.com/gvanrossum/patma/blob/be5969442d0584005492134c3b24eea408709db2/examples/expr.py#L231>`_"
" shows that for purely positional class matching, the main impact comes "
"from the changes to value constraints and name binding, not from the "
"class matching changes::"
msgstr ""

#: ../../peps/pep-0642.rst:1398
msgid ""
"The changes to the class pattern syntax itself are more relevant when "
"checking for named attributes and extracting their values without relying"
" on ``__match_args__``::"
msgstr ""

#: ../../peps/pep-0642.rst:1408
msgid ""
"Compare this to the :pep:`634` equivalent, where it really isn't clear "
"which names are referring to attributes of the match subject and which "
"names are referring to local variables::"
msgstr ""

#: ../../peps/pep-0642.rst:1418
msgid ""
"In this specific case, that ambiguity doesn't matter (since the attribute"
" and variable names are the same), but in the general case, knowing which"
" is which will be critical to reasoning correctly about the code being "
"read."
msgstr ""

#: ../../peps/pep-0642.rst:1424
msgid "Deferred Ideas"
msgstr ""

#: ../../peps/pep-0642.rst:1427
msgid "Inferred value constraints"
msgstr ""

#: ../../peps/pep-0642.rst:1429
msgid ""
"As discussed above, this PEP doesn't rule out the possibility of adding "
"inferred equality and identity constraints in the future."
msgstr ""

#: ../../peps/pep-0642.rst:1432
msgid ""
"These could be particularly valuable for literals, as it is quite likely "
"that many \"magic\" strings and numbers with self-evident meanings will "
"be written directly into match patterns, rather than being stored in "
"named variables. (Think constants like ``None``, or obviously special "
"numbers like ``0`` and ``1``, or strings where their contents are as "
"descriptive as any variable name, rather than cryptic checks against "
"opaque numbers like ``739452``)"
msgstr ""

#: ../../peps/pep-0642.rst:1441
msgid "Making some required parentheses optional"
msgstr ""

#: ../../peps/pep-0642.rst:1443
msgid ""
"The PEP currently errs heavily on the side of requiring parentheses in "
"the face of potential ambiguity."
msgstr ""

#: ../../peps/pep-0642.rst:1446
msgid ""
"However, there are a number of cases where it at least arguably goes too "
"far, mostly involving AS patterns with an explicit pattern."
msgstr ""

#: ../../peps/pep-0642.rst:1449
msgid ""
"In any position that requires a closed pattern, AS patterns may end up "
"starting with doubled parentheses, as the nested pattern is also required"
" to be a closed pattern: ``((OPEN PTRN) as NAME)``"
msgstr ""

#: ../../peps/pep-0642.rst:1453
msgid ""
"Due to the requirement that the subpattern be closed, it should be "
"reasonable in many of these cases (e.g. sequence pattern subpatterns) to "
"accept ``CLOSED_PTRN as NAME`` directly."
msgstr ""

#: ../../peps/pep-0642.rst:1457
msgid ""
"Further consideration of this point has been deferred, as making required"
" parentheses optional is a backwards compatible change, and hence "
"relaxing the restrictions later can be considered on a case-by-case "
"basis."
msgstr ""

#: ../../peps/pep-0642.rst:1463
msgid "Accepting complex literals as closed expressions"
msgstr ""

#: ../../peps/pep-0642.rst:1465
msgid ""
":pep:`634`'s reference implementation includes a lot of special casing of"
" binary operations in both the parser and the rest of the compiler in "
"order to accept complex literals without accepting arbitrary binary "
"numeric operations on literal values."
msgstr ""

#: ../../peps/pep-0642.rst:1470
msgid ""
"Ideally, this problem would be dealt with at the parser layer, with the "
"parser directly emitting a Constant AST node prepopulated with a complex "
"number. If that was the way things worked, then complex literals could be"
" accepted through a similar mechanism to any other literal."
msgstr ""

#: ../../peps/pep-0642.rst:1475
msgid ""
"This isn't how complex literals are handled, however. Instead, they're "
"passed through to the AST as regular ``BinOp`` nodes, and then the "
"constant folding pass on the AST resolves them down to ``Constant`` nodes"
" with a complex value."
msgstr ""

#: ../../peps/pep-0642.rst:1479
msgid ""
"For the parser to resolve complex literals directly, the compiler would "
"need to be able to tell the tokenizer to generate a distinct token type "
"for imaginary numbers (e.g. ``INUMBER``), which would then allow the "
"parser to handle ``NUMBER + INUMBER`` and ``NUMBER - INUMBER`` separately"
" from other binary operations."
msgstr ""

#: ../../peps/pep-0642.rst:1485
msgid ""
"Alternatively, a new ``ComplexNumber`` AST node type could be defined, "
"which would allow the parser to notify the subsequent compiler stages "
"that a particular node should specifically be a complex literal, rather "
"than an arbitrary binary operation. Then the parser could accept ``NUMBER"
" + NUMBER`` and ``NUMBER - NUMBER`` for that node, while letting the AST "
"validation for ``ComplexNumber`` take care of ensuring that the real and "
"imaginary parts of the literal were real and imaginary numbers as "
"expected."
msgstr ""

#: ../../peps/pep-0642.rst:1493
msgid ""
"For now, this PEP has postponed dealing with this question, and instead "
"just requires that complex literals be parenthesised in order to be used "
"in value constraints and as mapping pattern keys."
msgstr ""

#: ../../peps/pep-0642.rst:1499
msgid "Allowing negated constraints in match patterns"
msgstr ""

#: ../../peps/pep-0642.rst:1501
msgid ""
"With the syntax proposed in this PEP, it isn't permitted to write ``!= "
"expr`` or ``is not expr`` as a match pattern."
msgstr ""

#: ../../peps/pep-0642.rst:1504
msgid ""
"Both of these forms have clear potential interpretations as a negated "
"equality constraint (i.e. ``x != expr``) and a negated identity "
"constraint (i.e. ``x is not expr``)."
msgstr ""

#: ../../peps/pep-0642.rst:1508
msgid ""
"However, it's far from clear either form would come up often enough to "
"justify the dedicated syntax, so the possible extension has been deferred"
" pending further community experience with match statements."
msgstr ""

#: ../../peps/pep-0642.rst:1516
msgid "Allowing membership checks in match patterns"
msgstr ""

#: ../../peps/pep-0642.rst:1518
msgid ""
"The syntax used for equality and identity constraints would be "
"straightforward to extend to membership checks: ``in container``."
msgstr ""

#: ../../peps/pep-0642.rst:1521
msgid ""
"One downside of the proposals in both this PEP and :pep:`634` is that "
"checking for multiple values in the same case doesn't look like any "
"existing container membership check in Python::"
msgstr ""

#: ../../peps/pep-0642.rst:1535
msgid ""
"Allowing inferred equality constraints under this PEP would only make it "
"look like the :pep:`634` example, it still wouldn't look like the "
"equivalent ``if`` statement header (``if value in {0, 1, 2, 3}:``)."
msgstr ""

#: ../../peps/pep-0642.rst:1539
msgid ""
"Membership constraints would provide a more explicit, but still concise, "
"way to check if the match subject was present in a container, and it "
"would look the same as an ordinary containment check::"
msgstr ""

#: ../../peps/pep-0642.rst:1551
msgid ""
"Such a feature would also be readily extensible to allow all kinds of "
"case clauses without any further syntax updates, simply by defining "
"``__contains__`` appropriately on a custom class definition."
msgstr ""

#: ../../peps/pep-0642.rst:1555
msgid ""
"However, while this does seem like a useful extension, and a good way to "
"resolve this PEP's verbosity problem when combining multiple equality "
"checks in an OR pattern, it isn't essential to making match statements a "
"valuable addition to the language, so it seems more appropriate to defer "
"it to a separate proposal, rather than including it here."
msgstr ""

#: ../../peps/pep-0642.rst:1563
msgid "Inferring a default type for instance attribute constraints"
msgstr ""

#: ../../peps/pep-0642.rst:1565
msgid ""
"The dedicated syntax for instance attribute constraints means that "
"``object`` could be omitted from ``object{.ATTR}`` to give ``{.ATTR}`` "
"without introducing any syntactic ambiguity (if no class was given, "
"``object`` would be implied, just as it is for the base class list in "
"class definitions)."
msgstr ""

#: ../../peps/pep-0642.rst:1570
msgid ""
"However, it's far from clear saving six characters is worth making it "
"harder to visually distinguish mapping patterns from instance attribute "
"patterns, so allowing this has been deferred as a topic for possible "
"future consideration."
msgstr ""

#: ../../peps/pep-0642.rst:1576
msgid "Avoiding special cases in sequence patterns"
msgstr ""

#: ../../peps/pep-0642.rst:1578
msgid ""
"Sequence patterns in both this PEP and :pep:`634` currently special case "
"``str``, ``bytes``, and ``bytearray`` as specifically *never* matching a "
"sequence pattern."
msgstr ""

#: ../../peps/pep-0642.rst:1582
msgid ""
"This special casing could potentially be removed if we were to define a "
"new ``collections.abc.AtomicSequence`` abstract base class for types like"
" these, where they're conceptually a single item, but still implement the"
" sequence protocol to allow random access to their component parts."
msgstr ""

#: ../../peps/pep-0642.rst:1589 ../../peps/pep-0642.rst:1608
msgid "Expression syntax to retrieve multiple attributes from an instance"
msgstr ""

#: ../../peps/pep-0642.rst:1591
msgid ""
"The instance attribute pattern syntax has been designed such that it "
"could be used as the basis for a general purpose syntax for retrieving "
"multiple attributes from an object in a single expression::"
msgstr ""

#: ../../peps/pep-0642.rst:1597
msgid ""
"Similar to slice syntax only being allowed inside bracket subscrpts, the "
"``.attr`` syntax for naming attributes would only be allowed inside brace"
" subscripts."
msgstr ""

#: ../../peps/pep-0642.rst:1601
msgid ""
"This idea isn't required for pattern matching to be useful, so it isn't "
"part of this PEP. However, it's mentioned as a possible path towards "
"making pattern matching feel more integrated into the rest of the "
"language, rather than existing forever in its own completely separated "
"world."
msgstr ""

#: ../../peps/pep-0642.rst:1610
msgid ""
"If the brace subscript syntax were to be accepted for instance attribute "
"pattern matching, and then subsequently extended to offer general purpose"
" extraction of multiple attributes, then it could be extended even "
"further to allow for retrieval of multiple items from containers based on"
" the syntax used for mapping pattern matching::"
msgstr ""

#: ../../peps/pep-0642.rst:1619
msgid ""
"Again, this idea isn't required for pattern matching to be useful, so it "
"isn't part of this PEP. As with retrieving multiple attributes, however, "
"it is included as an example of the proposed pattern matching syntax "
"inspiring ideas for making object deconstruction easier in general."
msgstr ""

#: ../../peps/pep-0642.rst:1626
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/pep-0642.rst:1629
msgid ""
"Restricting permitted expressions in value constraints and mapping "
"pattern keys"
msgstr ""

#: ../../peps/pep-0642.rst:1631
msgid ""
"While it's entirely technically possible to restrict the kinds of "
"expressions permitted in value constraints and mapping pattern keys to "
"just attribute lookups and constant literals (as :pep:`634` does), there "
"isn't any clear runtime value in doing so, so this PEP proposes allowing "
"any kind of primary expression (primary expressions are an existing node "
"type in the grammar that includes things like literals, names, attribute "
"lookups, function calls, container subscripts, parenthesised groups, "
"etc), as well as high precedence unary operations (``+``, ``-``, ``~``) "
"on primary expressions."
msgstr ""

#: ../../peps/pep-0642.rst:1640
msgid ""
"While :pep:`635` does emphasise several times that literal patterns and "
"value patterns are not full expressions, it doesn't ever articulate a "
"concrete benefit that is obtained from that restriction (just a "
"theoretical appeal to it being useful to separate static checks from "
"dynamic checks, which a code style tool could still enforce, even if the "
"compiler itself is more permissive)."
msgstr ""

#: ../../peps/pep-0642.rst:1646
msgid ""
"The last time we imposed such a restriction was for decorator expressions"
" and the primary outcome of that was that users had to put up with years "
"of awkward syntactic workarounds (like nesting arbitrary expressions "
"inside function calls that just returned their argument) to express the "
"behaviour they wanted before the language definition was finally updated "
"to allow arbitrary expressions and let users make their own decisions "
"about readability."
msgstr ""

#: ../../peps/pep-0642.rst:1653
msgid ""
"The situation in :pep:`634` that bears a resemblance to the situation "
"with decorator expressions is that arbitrary expressions are technically "
"supported in value patterns, they just require awkward workarounds where "
"either all the values to match need to be specified in a helper class "
"that is placed before the match statement::"
msgstr ""

#: ../../peps/pep-0642.rst:1666
msgid ""
"Or else they need to be written as a combination of a capture pattern and"
" a guard expression::"
msgstr ""

#: ../../peps/pep-0642.rst:1674
msgid ""
"This PEP proposes skipping requiring any such workarounds, and instead "
"supporting arbitrary value constraints from the start::"
msgstr ""

#: ../../peps/pep-0642.rst:1681
msgid ""
"Whether actually writing that kind of code is a good idea would be a "
"topic for style guides and code linters, not the language compiler."
msgstr ""

#: ../../peps/pep-0642.rst:1684
msgid ""
"In particular, if static analysers can't follow certain kinds of dynamic "
"checks, then they can limit the permitted expressions at analysis time, "
"rather than the compiler restricting them at compile time."
msgstr ""

#: ../../peps/pep-0642.rst:1688
msgid ""
"There are also some kinds of expressions that are almost certain to give "
"nonsensical results (e.g. ``yield``, ``yield from``, ``await``) due to "
"the pattern caching rule, where the number of times the constraint "
"expression actually gets evaluated will be implementation dependent. Even"
" here, the PEP takes the view of letting users write nonsense if they "
"really want to."
msgstr ""

#: ../../peps/pep-0642.rst:1694
msgid ""
"Aside from the recently updated decorator expressions, another situation "
"where Python's formal syntax offers full freedom of expression that is "
"almost never used in practice is in ``except`` clauses: the exceptions to"
" match against almost always take the form of a simple name, a dotted "
"name, or a tuple of those, but the language grammar permits arbitrary "
"expressions at that point. This is a good indication that Python's user "
"base can be trusted to take responsibility for finding readable ways to "
"use permissive language features, by avoiding writing hard to read "
"constructs even when they're permitted by the compiler."
msgstr ""

#: ../../peps/pep-0642.rst:1704
msgid ""
"This permissiveness comes with a real concrete benefit on the "
"implementation side: dozens of lines of match statement specific code in "
"the compiler is replaced by simple calls to the existing code for "
"compiling expressions (including in the AST validation pass, the AST "
"optimization pass, the symbol table analysis pass, and the code "
"generation pass). This implementation benefit would accrue not just to "
"CPython, but to every other Python implementation looking to add match "
"statement support."
msgstr ""

#: ../../peps/pep-0642.rst:1714
msgid "Requiring the use of constraint prefix markers for mapping pattern keys"
msgstr ""

#: ../../peps/pep-0642.rst:1716
msgid ""
"The initial (unpublished) draft of this proposal suggested requiring "
"mapping pattern keys be value constraints, just as :pep:`634` requires "
"that they be valid literal or value patterns::"
msgstr ""

#: ../../peps/pep-0642.rst:1728
msgid ""
"However, the extra characters were syntactically noisy and unlike its use"
" in value constraints (where it distinguishes them from non-pattern "
"expressions), the prefix doesn't provide any additional information here "
"that isn't already conveyed by the expression's position as a key within "
"a mapping pattern."
msgstr ""

#: ../../peps/pep-0642.rst:1733
msgid ""
"Accordingly, the proposal was simplified to omit the marker prefix from "
"mapping pattern keys."
msgstr ""

#: ../../peps/pep-0642.rst:1736
msgid ""
"This omission also aligns with the fact that containers may incorporate "
"both identity and equality checks into their lookup process - they don't "
"purely rely on equality checks, as would be incorrectly implied by the "
"use of the equality constraint prefix."
msgstr ""

#: ../../peps/pep-0642.rst:1743
msgid ""
"Allowing the key/value separator to be omitted for mapping value "
"constraints"
msgstr ""

#: ../../peps/pep-0642.rst:1745
msgid ""
"Instance attribute patterns allow the ``:`` separator to be omitted when "
"writing attribute value constraints like ``case object{.attr == expr}``."
msgstr ""

#: ../../peps/pep-0642.rst:1748
msgid ""
"Offering a similar shorthand for mapping value constraints was "
"considered, but permitting it allows thoroughly baffling constructs like "
"``case {0 == 0}:`` where the compiler knows this is the key ``0`` with "
"the value constraint ``== 0``, but a human reader sees the tautological "
"comparison operation ``0 == 0``. With the key/value separator included, "
"the intent is more obvious to a human reader as well: ``case {0: == 0}:``"
msgstr ""

#: ../../peps/pep-0642.rst:1757
msgid "Reference Implementation"
msgstr ""

#: ../../peps/pep-0642.rst:1759
msgid ""
"A draft reference implementation for this PEP [3]_ has been derived from "
"Brandt Bucher's reference implementation for :pep:`634` [4]_."
msgstr ""

#: ../../peps/pep-0642.rst:1762
msgid ""
"Relative to the text of this PEP, the draft reference implementation has "
"not yet complemented the special casing of several builtin and standard "
"library types in ``MATCH_CLASS`` with the more general check for "
"``__match_args__`` being set to ``None``. Class defined patterns also "
"currently still accept classes that don't define ``__match_args__``."
msgstr ""

#: ../../peps/pep-0642.rst:1768
msgid ""
"All other modified patterns have been updated to follow this PEP rather "
"than :pep:`634`."
msgstr ""

#: ../../peps/pep-0642.rst:1771
msgid ""
"Unparsing for match patterns has not yet been migrated to the updated v3 "
"AST."
msgstr ""

#: ../../peps/pep-0642.rst:1773
msgid "The AST validator for match patterns has not yet been implemented."
msgstr ""

#: ../../peps/pep-0642.rst:1775
msgid ""
"The AST validator in general has not yet been reviewed to ensure that it "
"is checking that only expression nodes are being passed in where "
"expression nodes are expected."
msgstr ""

#: ../../peps/pep-0642.rst:1779
msgid ""
"The examples in this PEP have not yet been converted to test cases, so "
"could plausibly contain typos and other errors."
msgstr ""

#: ../../peps/pep-0642.rst:1782
msgid ""
"Several of the old :pep:`634` tests are still to be converted to new "
"SyntaxError tests."
msgstr ""

#: ../../peps/pep-0642.rst:1785
msgid "The documentation has not yet been updated."
msgstr ""

#: ../../peps/pep-0642.rst:1789
msgid "Acknowledgments"
msgstr ""

#: ../../peps/pep-0642.rst:1791
msgid ""
"The :pep:`622` and :pep:`634`/:pep:`635`/:pep:`636` authors, as the "
"proposal in this PEP is merely an attempt to improve the readability of "
"an already well-constructed idea by proposing that starting with a more "
"explicit syntax and potentially introducing syntactic shortcuts for "
"particularly common operations later is a better option than attempting "
"to *only* define the shortcut version. For areas of the specification "
"where the two PEPs are the same (or at least very similar), the text "
"describing the intended behaviour in this PEP is often derived directly "
"from the :pep:`634` text."
msgstr ""

#: ../../peps/pep-0642.rst:1801
msgid ""
"Steven D'Aprano, who made a compelling case that the key goals of this "
"PEP could be achieved by using existing comparison tokens to tell the "
"ability to override the compiler when our guesses as to \"what most users"
" will want most of the time\" are inevitably incorrect for at least some "
"users some of the time, and retaining some of :pep:`634`'s syntactic "
"sugar (with a slightly different semantic definition) to obtain the same "
"level of brevity as :pep:`634` in most situations. (Paul Sokolosvsky also"
" independently suggested using ``==`` instead of ``?`` as a more easily "
"understood prefix for equality constraints)."
msgstr ""

#: ../../peps/pep-0642.rst:1810
msgid ""
"Thomas Wouters, whose publication of :pep:`640` and public review of the "
"structured pattern matching proposals persuaded the author of this PEP to"
" continue advocating for a wildcard pattern syntax that a future PEP "
"could plausibly turn into a hard keyword that always skips binding a "
"reference in any location a simple name is expected, rather than "
"continuing indefinitely as the match pattern specific soft keyword that "
"is proposed here."
msgstr ""

#: ../../peps/pep-0642.rst:1817
msgid ""
"Joao Bueno and Jim Jewett for nudging the PEP author to take a closer "
"look at the proposed syntax for subelement capturing within class "
"patterns and mapping patterns (particularly the problems with \"capturing"
" to the right\"). This review is what prompted the significant changes "
"between v2 and v3 of the proposal."
msgstr ""

#: ../../peps/pep-0642.rst:1825
msgid "References"
msgstr "Referências"

#: ../../peps/pep-0642.rst:1827
msgid ""
"Post explaining the syntactic novelties in PEP 622 "
"https://mail.python.org/archives/list/python-"
"dev@python.org/message/2VRPDW4EE243QT3QNNCO7XFZYZGIY6N3/>"
msgstr ""

#: ../../peps/pep-0642.rst:1830
msgid ""
"Declined pull request proposing to list this as a Rejected Idea in PEP "
"622 https://github.com/python/peps/pull/1564"
msgstr ""

#: ../../peps/pep-0642.rst:1833
msgid ""
"In-progress reference implementation for this PEP "
"https://github.com/ncoghlan/cpython/tree/pep-642-constraint-patterns"
msgstr ""

#: ../../peps/pep-0642.rst:1836
msgid ""
"PEP 634 reference implementation "
"https://github.com/python/cpython/pull/22917"
msgstr ""

#: ../../peps/pep-0642.rst:1839
msgid ""
"Steven D'Aprano's cogent criticism of the first published iteration of "
"this PEP https://mail.python.org/archives/list/python-"
"dev@python.org/message/BTHFWG6MWLHALOD6CHTUFPHAR65YN6BP/"
msgstr ""

#: ../../peps/pep-0642.rst:1842
msgid ""
"Thomas Wouter's initial review of the structured pattern matching "
"proposals https://mail.python.org/archives/list/python-"
"dev@python.org/thread/4SBR3J5IQUYE752KR7C6432HNBSYKC5X/"
msgstr ""

#: ../../peps/pep-0642.rst:1845
msgid ""
"Stack Overflow answer regarding the use cases for ``_`` as an identifier "
"https://stackoverflow.com/questions/5893163/what-is-the-purpose-of-the-"
"single-underscore-variable-in-python/5893946#5893946"
msgstr ""

#: ../../peps/pep-0642.rst:1848
msgid ""
"Pre-publication draft of \"Precise Semantics for Pattern Matching\" "
"https://github.com/markshannon/pattern-"
"matching/blob/master/precise_semantics.rst"
msgstr ""

#: ../../peps/pep-0642.rst:1851
msgid ""
"Kohn et al., Dynamic Pattern Matching with Python "
"https://gvanrossum.github.io/docs/PyPatternMatching.pdf"
msgstr ""

#: ../../peps/pep-0642.rst:1858
msgid "Appendix A -- Full Grammar"
msgstr ""

#: ../../peps/pep-0642.rst:1860
msgid ""
"Here is the full modified grammar for ``match_stmt``, replacing Appendix "
"A in :pep:`634`."
msgstr ""

#: ../../peps/pep-0642.rst:1863
msgid "Notation used beyond standard EBNF is as per :pep:`534`:"
msgstr ""

#: ../../peps/pep-0642.rst:1865
msgid "``'KWD'`` denotes a hard keyword"
msgstr ""

#: ../../peps/pep-0642.rst:1866
msgid "``\"KWD\"`` denotes a soft keyword"
msgstr ""

#: ../../peps/pep-0642.rst:1867
msgid "``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr ""

#: ../../peps/pep-0642.rst:1868
msgid "``!RULE`` is a negative lookahead assertion"
msgstr ""

#: ../../peps/pep-0642.rst:1968
msgid "Appendix B: Summary of Abstract Syntax Tree changes"
msgstr ""

#: ../../peps/pep-0642.rst:1970
msgid "The following new nodes are added to the AST by this PEP::"
msgstr ""

#: ../../peps/pep-0642.rst:2001
msgid "Appendix C: Summary of changes relative to PEP 634"
msgstr ""

#: ../../peps/pep-0642.rst:2003
msgid ""
"The overall ``match``/``case`` statement syntax and the guard expression "
"syntax remain the same as they are in :pep:`634`."
msgstr ""

#: ../../peps/pep-0642.rst:2006
msgid "Relative to :pep:`634` this PEP makes the following key changes:"
msgstr ""

#: ../../peps/pep-0642.rst:2008
msgid ""
"a new ``pattern`` type is defined in the AST, rather than reusing the "
"``expr`` type for patterns"
msgstr ""

#: ../../peps/pep-0642.rst:2010
msgid ""
"the new ``MatchAs`` and ``MatchOr`` AST nodes are moved from the ``expr``"
" type to the ``pattern`` type"
msgstr ""

#: ../../peps/pep-0642.rst:2012
msgid ""
"the wildcard pattern changes from ``_`` (single underscore) to ``__`` "
"(double underscore), and gains a dedicated ``MatchAlways`` node in the "
"AST"
msgstr ""

#: ../../peps/pep-0642.rst:2014
msgid ""
"due to ambiguity of intent, value patterns and literal patterns are "
"removed"
msgstr ""

#: ../../peps/pep-0642.rst:2015
msgid "a new expression category is introduced: \"closed expressions\""
msgstr ""

#: ../../peps/pep-0642.rst:2016
msgid ""
"closed expressions are either primary expressions, or a closed expression"
" preceded by one of the high precedence unary operators (``+``, ``-``, "
"``~``)"
msgstr ""

#: ../../peps/pep-0642.rst:2018
msgid "a new pattern type is introduced: \"value constraint patterns\""
msgstr ""

#: ../../peps/pep-0642.rst:2019
msgid ""
"value constraints have a dedicated ``MatchValue`` AST node rather than "
"allowing a combination of ``Constant`` (literals), ``UnaryOp`` (negative "
"numbers), ``BinOp`` (complex numbers), and ``Attribute`` (attribute "
"lookups)"
msgstr ""

#: ../../peps/pep-0642.rst:2023
msgid ""
"value constraint patterns are either equality constraints or identity "
"constraints"
msgstr ""

#: ../../peps/pep-0642.rst:2024
msgid ""
"equality constraints use ``==`` as a prefix marker on an otherwise "
"arbitrary closed expression: ``== EXPR``"
msgstr ""

#: ../../peps/pep-0642.rst:2026
msgid ""
"identity constraints use ``is`` as a prefix marker on an otherwise "
"arbitrary closed expression: ``is EXPR``"
msgstr ""

#: ../../peps/pep-0642.rst:2028
msgid ""
"due to ambiguity of intent, capture patterns are removed. All capture "
"operations use the ``as`` keyword (even in sequence matching) and are "
"represented in the AST as either ``MatchAs`` or ``MatchRestOfSequence`` "
"nodes."
msgstr ""

#: ../../peps/pep-0642.rst:2031
msgid ""
"to reduce verbosity in AS patterns, ``as NAME`` is permitted, with the "
"same meaning as ``__ as NAME``"
msgstr ""

#: ../../peps/pep-0642.rst:2033
msgid ""
"sequence patterns change to *require* the use of square brackets, rather "
"than offering the same syntactic flexibility as assignment targets "
"(assignment statements allow iterable unpacking to be indicated by any "
"use of a tuple separated target, with or without surrounding parentheses "
"or square brackets)"
msgstr ""

#: ../../peps/pep-0642.rst:2037
msgid ""
"sequence patterns gain a dedicated ``MatchSequence`` AST node rather than"
" reusing ``List``"
msgstr ""

#: ../../peps/pep-0642.rst:2039
msgid "mapping patterns change to allow arbitrary closed expressions as keys"
msgstr ""

#: ../../peps/pep-0642.rst:2040
msgid ""
"mapping patterns gain a dedicated ``MatchMapping`` AST node rather than "
"reusing ``Dict``"
msgstr ""

#: ../../peps/pep-0642.rst:2042
msgid ""
"to reduce verbosity in mapping patterns, ``KEY : __ as NAME`` may be "
"shortened to ``KEY as NAME``"
msgstr ""

#: ../../peps/pep-0642.rst:2044
msgid ""
"class patterns no longer use individual keyword argument syntax for "
"attribute matching. Instead they use double-star syntax, along with a "
"variant on mapping pattern syntax with a dot prefix on the attribute "
"names"
msgstr ""

#: ../../peps/pep-0642.rst:2047
msgid ""
"class patterns gain a dedicated ``MatchClass`` AST node rather than "
"reusing ``Call``"
msgstr ""

#: ../../peps/pep-0642.rst:2049
msgid ""
"to reduce verbosity, class attribute matching allows ``:`` to be omitted "
"when the pattern to be matched starts with ``==``, ``is``, or ``as``"
msgstr ""

#: ../../peps/pep-0642.rst:2051
msgid ""
"class patterns treat any class that sets ``__match_args__`` to ``None`` "
"as accepting a single positional pattern that is matched against the "
"entire object (avoiding the special casing required in :pep:`634`)"
msgstr ""

#: ../../peps/pep-0642.rst:2054
msgid ""
"class patterns raise ``TypeError`` when used with an object that does not"
" define ``__match_args__``"
msgstr ""

#: ../../peps/pep-0642.rst:2056
msgid ""
"dedicated syntax for ducktyping is added, such that ``case cls{...}:`` is"
" roughly equivalent to ``case cls(**{...}):``, but skips the check for "
"the existence of ``__match_args__``. This pattern also has a dedicated "
"AST node, ``MatchAttrs``"
msgstr ""

#: ../../peps/pep-0642.rst:2061
msgid ""
"Note that postponing literal patterns also makes it possible to postpone "
"the question of whether we need an \"INUMBER\" token in the tokeniser for"
" imaginary literals. Without it, the parser can't distinguish complex "
"literals from other binary addition and subtraction operations on "
"constants, so proposals like :pep:`634` have to do work in later "
"compilation steps to check for correct usage."
msgstr ""

#: ../../peps/pep-0642.rst:2071
msgid "Appendix D: History of changes to this proposal"
msgstr ""

#: ../../peps/pep-0642.rst:2073
msgid ""
"The first published iteration of this proposal mostly followed "
":pep:`634`, but suggested using ``?EXPR`` for equality constraints and "
"``?is EXPR`` for identity constraints rather than :pep:`634`'s value "
"patterns and literal patterns."
msgstr ""

#: ../../peps/pep-0642.rst:2077
msgid ""
"The second published iteration mostly adopted a counter-proposal from "
"Steven D'Aprano that kept the :pep:`634` style inferred constraints in "
"many situations, but also allowed the use of ``== EXPR`` for explicit "
"equality constraints, and ``is EXPR`` for explicit identity constraints."
msgstr ""

#: ../../peps/pep-0642.rst:2082
msgid ""
"The third published (and current) iteration dropped inferred patterns "
"entirely, in an attempt to resolve the concerns with the fact that the "
"patterns ``case {key: NAME}:`` and ``case cls(attr=NAME):`` would both "
"bind ``NAME`` despite it appearing to the right of another subexpression "
"without using the ``as`` keyword. The revised proposal also eliminates "
"the possibility of writing ``case TARGET1 as TARGET2:``, which would bind"
" to both of the given names. Of those changes, the most concerning was "
"``case cls(attr=TARGET_NAME):``, since it involved the use of ``=`` with "
"the binding target on the right, the exact opposite of what happens in "
"assignment statements, function calls, and function signature "
"declarations."
msgstr ""

#: ../../peps/pep-0642.rst:2095
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-0642.rst:2097
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

#~ msgid "Nick Coghlan <ncoghlan@gmail.com>"
#~ msgstr ""

#~ msgid ""
#~ "Aside from the recenty updated decorator"
#~ " expressions, another situation where "
#~ "Python's formal syntax offers full "
#~ "freedom of expression that is almost "
#~ "never used in practice is in "
#~ "``except`` clauses: the exceptions to "
#~ "match against almost always take the "
#~ "form of a simple name, a dotted"
#~ " name, or a tuple of those, but"
#~ " the language grammar permits arbitrary "
#~ "expressions at that point. This is "
#~ "a good indication that Python's user "
#~ "base can be trusted to take "
#~ "responsibility for finding readable ways "
#~ "to use permissive language features, by"
#~ " avoiding writing hard to read "
#~ "constructs even when they're permitted "
#~ "by the compiler."
#~ msgstr ""

