# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-14 02:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: pt_BR\n"
"Language-Team: pt_BR <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../peps/peps/pep-0742.rst
msgid "Author"
msgstr ""

#: ../../peps/peps/pep-0742.rst:3
msgid "Jelle Zijlstra <jelle.zijlstra@gmail.com>"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/peps/pep-0742.rst:4
msgid ""
"https://discuss.python.org/t/pep-742-narrowing-types-with-typenarrower/45613"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Status"
msgstr ""

#: ../../peps/peps/pep-0742.rst:5
msgid "Accepted"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Type"
msgstr ""

#: ../../peps/peps/pep-0742.rst:6
msgid "Standards Track"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Topic"
msgstr ""

#: ../../peps/peps/pep-0742.rst:7
msgid "Typing"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Created"
msgstr ""

#: ../../peps/peps/pep-0742.rst:8
msgid "07-Feb-2024"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/peps/pep-0742.rst:9
msgid "3.13"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Post-History"
msgstr ""

#: ../../peps/peps/pep-0742.rst:10
msgid ""
"`11-Feb-2024 <https://discuss.python.org/t/pep-742-narrowing-types-with-"
"typenarrower/45613>`__"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Replaces"
msgstr ""

#: ../../peps/peps/pep-0742.rst:11
msgid "724"
msgstr ""

#: ../../peps/peps/pep-0742.rst
msgid "Resolution"
msgstr ""

#: ../../peps/peps/pep-0742.rst:12
msgid ""
"https://discuss.python.org/t/pep-742-narrowing-types-with-typeis/45613/35"
msgstr ""

#: ../../peps/peps/pep-0742.rst:16
msgid "Abstract"
msgstr ""

#: ../../peps/peps/pep-0742.rst:18
msgid ""
"This PEP proposes a new special form, ``TypeIs``, to allow annotating "
"functions that can be used to narrow the type of a value, similar to the "
"builtin :py:func:`isinstance`. Unlike the existing :py:data:`typing."
"TypeGuard` special form, ``TypeIs`` can narrow the type in both the ``if`` "
"and ``else`` branches of a conditional."
msgstr ""

#: ../../peps/peps/pep-0742.rst:25
msgid "Motivation"
msgstr ""

#: ../../peps/peps/pep-0742.rst:27
msgid ""
"Typed Python code often requires users to narrow the type of a variable "
"based on a conditional. For example, if a function accepts a union of two "
"types, it may use an :py:func:`isinstance` check to discriminate between the "
"two types. Type checkers commonly support type narrowing based on various "
"builtin function and operations, but occasionally, it is useful to use a "
"user-defined function to perform type narrowing."
msgstr ""

#: ../../peps/peps/pep-0742.rst:33
msgid ""
"To support such use cases, :pep:`647` introduced the :py:data:`typing."
"TypeGuard` special form, which allows users to define type guards::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:47
msgid ""
"Unfortunately, the behavior of :py:data:`typing.TypeGuard` has some "
"limitations that make it less useful for many common use cases, as explained "
"also in the \"Motivation\" section of :pep:`724`. In particular:"
msgstr ""

#: ../../peps/peps/pep-0742.rst:51
msgid ""
"Type checkers must use exactly the ``TypeGuard`` return type as the narrowed "
"type if the type guard returns ``True``. They cannot use pre-existing "
"knowledge about the type of the variable."
msgstr ""

#: ../../peps/peps/pep-0742.rst:54
msgid ""
"In the case where the type guard returns ``False``, the type checker cannot "
"apply any additional narrowing."
msgstr ""

#: ../../peps/peps/pep-0742.rst:57
msgid ""
"The standard library function :py:func:`inspect.isawaitable` may serve as an "
"example. It returns whether the argument is an awaitable object, and "
"`typeshed <https://github.com/python/typeshed/blob/"
"a4f81a67a07c18dd184dd068c459b02e71bcac22/stdlib/inspect.pyi#L219>`__ "
"currently annotates it as::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:64
msgid ""
"A user `reported <https://github.com/python/mypy/issues/15520>`__ an issue "
"to mypy about the behavior of this function. They observed the following "
"behavior::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:77
msgid ""
"This behavior is consistent with :pep:`647`, but it did not match the user's "
"expectations. Instead, they would expect the type of ``t`` to be narrowed to "
"``Awaitable[int]`` in the ``if`` branch, and to ``int`` in the ``else`` "
"branch. This PEP proposes a new construct that does exactly that."
msgstr ""

#: ../../peps/peps/pep-0742.rst:82
msgid ""
"Other examples of issues that arose out of the current behavior of "
"``TypeGuard`` include:"
msgstr ""

#: ../../peps/peps/pep-0742.rst:84
msgid ""
"`Python typing issue <https://github.com/python/typing/issues/996>`__ "
"(``numpy.isscalar``)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:85
msgid ""
"`Python typing issue <https://github.com/python/typing/issues/1351>`__ (:py:"
"func:`dataclasses.is_dataclass`)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:86
msgid ""
"`Pyright issue <https://github.com/microsoft/pyright/issues/3450>`__ "
"(expecting :py:data:`typing.TypeGuard` to work like :py:func:`isinstance`)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:87
msgid ""
"`Pyright issue <https://github.com/microsoft/pyright/issues/3466>`__ "
"(expecting narrowing in the ``else`` branch)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:88
msgid ""
"`Mypy issue <https://github.com/python/mypy/issues/13957>`__ (expecting "
"narrowing in the ``else`` branch)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:89
msgid ""
"`Mypy issue <https://github.com/python/mypy/issues/14434>`__ (combining "
"multiple TypeGuards)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:90
msgid ""
"`Mypy issue <https://github.com/python/mypy/issues/15305>`__ (expecting "
"narrowing in the ``else`` branch)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:91
msgid ""
"`Mypy issue <https://github.com/python/mypy/issues/11907>`__ (user-defined "
"function similar to :py:func:`inspect.isawaitable`)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:92
msgid ""
"`Typeshed issue <https://github.com/python/typeshed/issues/8009>`__ "
"(``asyncio.iscoroutinefunction``)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:95
msgid "Rationale"
msgstr ""

#: ../../peps/peps/pep-0742.rst:97
msgid ""
"The problems with the current behavior of :py:data:`typing.TypeGuard` compel "
"us to improve the type system to allow a different type narrowing behavior. :"
"pep:`724` proposed to change the behavior of the existing :py:data:`typing."
"TypeGuard` construct, but we :ref:`believe <pep-742-change-typeguard>` that "
"the backwards compatibility implications of that change are too severe. "
"Instead, we propose adding a new special form with the desired semantics."
msgstr ""

#: ../../peps/peps/pep-0742.rst:103
msgid ""
"We acknowledge that this leads to an unfortunate situation where there are "
"two constructs with a similar purpose and similar semantics. We believe that "
"users are more likely to want the behavior of ``TypeIs``, the new form "
"proposed in this PEP, and therefore we recommend that documentation "
"emphasize ``TypeIs`` over ``TypeGuard`` as a more commonly applicable tool. "
"However, the semantics of ``TypeGuard`` are occasionally useful, and we do "
"not propose to deprecate or remove it. In the long run, most users should "
"use ``TypeIs``, and ``TypeGuard`` should be reserved for rare cases where "
"its behavior is specifically desired."
msgstr ""

#: ../../peps/peps/pep-0742.rst:113
msgid "Specification"
msgstr ""

#: ../../peps/peps/pep-0742.rst:115
msgid ""
"A new special form, ``TypeIs``, is added to the :py:mod:`typing` module. Its "
"usage, behavior, and runtime implementation are similar to those of :py:data:"
"`typing.TypeGuard`."
msgstr ""

#: ../../peps/peps/pep-0742.rst:119
msgid ""
"It accepts a single argument and can be used as the return type of a "
"function. A function annotated as returning a ``TypeIs`` is called a type "
"narrowing function. Type narrowing functions must return ``bool`` values, "
"and the type checker should verify that all return paths return ``bool``."
msgstr ""

#: ../../peps/peps/pep-0742.rst:125
msgid ""
"Type narrowing functions must accept at least one positional argument. The "
"type narrowing behavior is applied to the first positional argument passed "
"to the function. The function may accept additional arguments, but they are "
"not affected by type narrowing. If a type narrowing function is implemented "
"as an instance method or class method, the first positional argument maps to "
"the second parameter (after ``self`` or ``cls``)."
msgstr ""

#: ../../peps/peps/pep-0742.rst:133
msgid "Type narrowing behavior"
msgstr ""

#: ../../peps/peps/pep-0742.rst:135
msgid ""
"To specify the behavior of ``TypeIs``, we use the following terminology:"
msgstr ""

#: ../../peps/peps/pep-0742.rst:137
msgid "I = ``TypeIs`` input type"
msgstr ""

#: ../../peps/peps/pep-0742.rst:138
msgid "R = ``TypeIs`` return type"
msgstr ""

#: ../../peps/peps/pep-0742.rst:139
msgid "A = Type of argument passed to type narrowing function (pre-narrowed)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:140
msgid "NP = Narrowed type (positive; used when ``TypeIs`` returned ``True``)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:141
msgid "NN = Narrowed type (negative; used when ``TypeIs`` returned ``False``)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:153
msgid ""
"The return type ``R`` must be :ref:`consistent with <pep-483-gradual-"
"typing>` ``I``. The type checker should emit an error if this condition is "
"not met."
msgstr ""

#: ../../peps/peps/pep-0742.rst:156
msgid ""
"Formally, type *NP* should be narrowed to :math:`A \\land R`, the "
"intersection of *A* and *R*, and type *NN* should be narrowed to :math:`A "
"\\land \\neg R`, the intersection of *A* and the complement of *R*. In "
"practice, the theoretic types for strict type guards cannot be expressed "
"precisely in the Python type system. Type checkers should fall back on "
"practical approximations of these types. As a rule of thumb, a type checker "
"should use the same type narrowing logic -- and get results that are "
"consistent with -- its handling of :py:func:`isinstance`. This guidance "
"allows for changes and improvements if the type system is extended in the "
"future."
msgstr ""

#: ../../peps/peps/pep-0742.rst:167
msgid "Examples"
msgstr ""

#: ../../peps/peps/pep-0742.rst:169
msgid "Type narrowing is applied in both the positive and negative case::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:182
msgid ""
"The final narrowed type may be narrower than **R**, due to the constraints "
"of the argument's previously-known type::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:200
msgid ""
"It is an error to narrow to a type that is not consistent with the input "
"type::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:208
msgid "Subtyping"
msgstr ""

#: ../../peps/peps/pep-0742.rst:210
msgid ""
"``TypeIs`` is also valid as the return type of a callable, for example in "
"callback protocols and in the ``Callable`` special form. In these contexts, "
"it is treated as a subtype of bool. For example, ``Callable[..., "
"TypeIs[int]]`` is assignable to ``Callable[..., bool]``."
msgstr ""

#: ../../peps/peps/pep-0742.rst:215
msgid ""
"Unlike ``TypeGuard``, ``TypeIs`` is invariant in its argument type: "
"``TypeIs[B]`` is not a subtype of ``TypeIs[A]``, even if ``B`` is a subtype "
"of ``A``. To see why, consider the following example::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:231
msgid ""
"(Note that ``bool`` is a subtype of ``int``.) This code fails at runtime, "
"because the narrower returns ``False`` (1 is not a ``bool``) and the "
"``else`` branch is taken in ``takes_narrower()``. If the call "
"``takes_narrower(1, is_bool)`` was allowed, type checkers would fail to "
"detect this error."
msgstr ""

#: ../../peps/peps/pep-0742.rst:238
msgid "Backwards Compatibility"
msgstr ""

#: ../../peps/peps/pep-0742.rst:240
msgid ""
"As this PEP only proposes a new special form, there are no implications on "
"backwards compatibility."
msgstr ""

#: ../../peps/peps/pep-0742.rst:245
msgid "Security Implications"
msgstr ""

#: ../../peps/peps/pep-0742.rst:247
msgid "None known."
msgstr ""

#: ../../peps/peps/pep-0742.rst:251
msgid "How to Teach This"
msgstr ""

#: ../../peps/peps/pep-0742.rst:253
msgid ""
"Introductions to typing should cover ``TypeIs`` when discussing how to "
"narrow types, along with discussion of other narrowing constructs such as :"
"py:func:`isinstance`. The documentation should emphasize ``TypeIs`` over :py:"
"data:`typing.TypeGuard`; while the latter is not being deprecated and its "
"behavior is occasionally useful, we expect that the behavior of ``TypeIs`` "
"is usually more intuitive, and most users should reach for ``TypeIs`` first. "
"The rest of this section contains some example content that could be used in "
"introductory user-facing documentation."
msgstr ""

#: ../../peps/peps/pep-0742.rst:262
msgid "When to use ``TypeIs``"
msgstr ""

#: ../../peps/peps/pep-0742.rst:264
msgid ""
"Python code often uses functions like ``isinstance()`` to distinguish "
"between different possible types of a value. Type checkers understand "
"``isinstance()`` and various other checks and use them to narrow the type of "
"a variable. However, sometimes you want to reuse a more complicated check in "
"multiple places, or you use a check that the type checker doesn't "
"understand. In these cases, you can define a ``TypeIs`` function to perform "
"the check and allow type checkers to use it to narrow the type of a variable."
msgstr ""

#: ../../peps/peps/pep-0742.rst:272
msgid ""
"A ``TypeIs`` function takes a single argument and is annotated as returning "
"``TypeIs[T]``, where ``T`` is the type that you want to narrow to. The "
"function must return ``True`` if the argument is of type ``T``, and "
"``False`` otherwise. The function can then be used in ``if`` checks, just "
"like you would use ``isinstance()``. For example::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:292
msgid "Writing a safe ``TypeIs`` function"
msgstr ""

#: ../../peps/peps/pep-0742.rst:294
msgid ""
"A ``TypeIs`` function allows you to override your type checker's type "
"narrowing behavior. This is a powerful tool, but it can be dangerous because "
"an incorrectly written ``TypeIs`` function can lead to unsound type "
"checking, and type checkers cannot detect such errors."
msgstr ""

#: ../../peps/peps/pep-0742.rst:299
msgid ""
"For a function returning ``TypeIs[T]`` to be safe, it must return ``True`` "
"if and only if the argument is compatible with type ``T``, and ``False`` "
"otherwise. If this condition is not met, the type checker may infer "
"incorrect types."
msgstr ""

#: ../../peps/peps/pep-0742.rst:303
msgid "Below are some examples of correct and incorrect ``TypeIs`` functions::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:319
msgid ""
"This function demonstrates some errors that can occur when using a poorly "
"written ``TypeIs`` function. These errors are not detected by type checkers::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:335
msgid ""
"Here is an example of a correct ``TypeIs`` function for a more complicated "
"type::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:354
msgid "``TypeIs`` and ``TypeGuard``"
msgstr ""

#: ../../peps/peps/pep-0742.rst:356
msgid ""
"``TypeIs`` and :py:data:`typing.TypeGuard` are both tools for narrowing the "
"type of a variable based on a user-defined function. Both can be used to "
"annotate functions that take an argument and return a boolean depending on "
"whether the input argument is compatible with the narrowed type. These "
"function can then be used in ``if`` checks to narrow the type of a variable."
msgstr ""

#: ../../peps/peps/pep-0742.rst:362
msgid ""
"``TypeIs`` usually has the most intuitive behavior, but it introduces more "
"restrictions. ``TypeGuard`` is the right tool to use if:"
msgstr ""

#: ../../peps/peps/pep-0742.rst:365
msgid ""
"You want to narrow to a type that is not compatible with the input type, for "
"example from ``list[object]`` to ``list[int]``.  ``TypeIs`` only allows "
"narrowing between compatible types."
msgstr ""

#: ../../peps/peps/pep-0742.rst:368
msgid ""
"Your function does not return ``True`` for all input values that are "
"compatible with the narrowed type. For example, you could have a "
"``TypeGuard[int]`` that returns ``True`` only for positive integers."
msgstr ""

#: ../../peps/peps/pep-0742.rst:372
msgid "``TypeIs`` and ``TypeGuard`` differ in the following ways:"
msgstr ""

#: ../../peps/peps/pep-0742.rst:374
msgid ""
"``TypeIs`` requires the narrowed type to be a subtype of the input type, "
"while ``TypeGuard`` does not."
msgstr ""

#: ../../peps/peps/pep-0742.rst:376
msgid ""
"When a ``TypeGuard`` function returns ``True``, type checkers narrow the "
"type of the variable to exactly the ``TypeGuard`` type. When a ``TypeIs`` "
"function returns ``True``, type checkers can infer a more precise type "
"combining the previously known type of the variable with the ``TypeIs`` "
"type. (Technically, this is known as an intersection type.)"
msgstr ""

#: ../../peps/peps/pep-0742.rst:380
msgid ""
"When a ``TypeGuard`` function returns ``False``, type checkers cannot narrow "
"the type of the variable at all. When a ``TypeIs`` function returns "
"``False``, type checkers can narrow the type of the variable to exclude the "
"``TypeIs`` type."
msgstr ""

#: ../../peps/peps/pep-0742.rst:384
msgid "This behavior can be seen in the following example::"
msgstr ""

#: ../../peps/peps/pep-0742.rst:412
msgid "Reference Implementation"
msgstr ""

#: ../../peps/peps/pep-0742.rst:414
msgid ""
"The ``TypeIs`` special form `has been implemented <https://github.com/python/"
"typing_extensions/pull/330>`__ in the ``typing_extensions`` module and will "
"be released in typing_extensions 4.10.0."
msgstr ""

#: ../../peps/peps/pep-0742.rst:417
msgid "Implementations are available for several type checkers:"
msgstr ""

#: ../../peps/peps/pep-0742.rst:419
msgid "Mypy: `pull request open <https://github.com/python/mypy/pull/16898>`__"
msgstr ""

#: ../../peps/peps/pep-0742.rst:420
msgid ""
"Pyanalyze: `pull request <https://github.com/quora/pyanalyze/pull/718>`__"
msgstr ""

#: ../../peps/peps/pep-0742.rst:421
msgid ""
"Pyright: `added in version 1.1.351 <https://github.com/microsoft/pyright/"
"releases/tag/1.1.351>`__"
msgstr ""

#: ../../peps/peps/pep-0742.rst:424
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/peps/pep-0742.rst:429
msgid "Change the behavior of ``TypeGuard``"
msgstr ""

#: ../../peps/peps/pep-0742.rst:431
msgid ""
":pep:`724` previously proposed changing the specified behavior of :py:data:"
"`typing.TypeGuard` so that if the return type of the guard is consistent "
"with the input type, the behavior proposed here for ``TypeIs`` would apply. "
"This proposal has some important advantages: because it does not require any "
"runtime changes, it requires changes only in type checkers, making it easier "
"for users to take advantage of the new, usually more intuitive behavior."
msgstr ""

#: ../../peps/peps/pep-0742.rst:437
msgid ""
"However, this approach has some major problems. Users who have written "
"``TypeGuard`` functions expecting the existing semantics specified in :pep:"
"`647` would see subtle and potentially breaking changes in how type checkers "
"interpret their code. The split behavior of ``TypeGuard``, where it works "
"one way if the return type is consistent with the input type and another way "
"if it is not, could be confusing for users. The Typing Council was unable to "
"come to an agreement in favor of :pep:`724`; as a result, we are proposing "
"this alternative PEP."
msgstr ""

#: ../../peps/peps/pep-0742.rst:445
msgid "Do nothing"
msgstr ""

#: ../../peps/peps/pep-0742.rst:447
msgid ""
"Both this PEP and the alternative proposed in :pep:`724` have shortcomings. "
"The latter are discussed above. As for this PEP, it introduces two special "
"forms with very similar semantics, and it potentially creates a long "
"migration path for users currently using ``TypeGuard`` who would be better "
"off with different narrowing semantics."
msgstr ""

#: ../../peps/peps/pep-0742.rst:452
msgid ""
"One way forward, then, is to do nothing and live with the current "
"limitations of the type system. However, we believe that the limitations of "
"the current ``TypeGuard``, as outlined in the \"Motivation\" section, are "
"significant enough that it is worthwhile to change the type system to "
"address them. If we do not make any change, users will continue to encounter "
"the same unintuitive behaviors from ``TypeGuard``, and the type system will "
"be unable to properly represent common type narrowing functions like "
"``inspect.isawaitable``."
msgstr ""

#: ../../peps/peps/pep-0742.rst:460
msgid "Alternative names"
msgstr ""

#: ../../peps/peps/pep-0742.rst:462
msgid ""
"This PEP currently proposes the name ``TypeIs``, emphasizing that the "
"special form ``TypeIs[T]`` returns whether the argument is of type ``T``, "
"and mirroring `TypeScript's syntax <https://www.typescriptlang.org/docs/"
"handbook/2/narrowing.html#using-type-predicates>`__. Other names were "
"considered, including in an earlier version of this PEP."
msgstr ""

#: ../../peps/peps/pep-0742.rst:467
msgid "Options include:"
msgstr ""

#: ../../peps/peps/pep-0742.rst:469
msgid ""
"``IsInstance`` (`post by Paul Moore <https://discuss.python.org/t/pep-724-"
"stricter-type-guards/34124/60>`__): emphasizes that the new construct "
"behaves similarly to the builtin :py:func:`isinstance`."
msgstr ""

#: ../../peps/peps/pep-0742.rst:471
msgid ""
"``Narrowed`` or ``NarrowedTo``: shorter than ``TypeNarrower`` but keeps the "
"connection to \"type narrowing\" (suggested by Eric Traut)."
msgstr ""

#: ../../peps/peps/pep-0742.rst:473
msgid ""
"``Predicate`` or ``TypePredicate``: mirrors TypeScript's name for the "
"feature, \"type predicates\"."
msgstr ""

#: ../../peps/peps/pep-0742.rst:474
msgid ""
"``StrictTypeGuard`` (earlier drafts of :pep:`724`): emphasizes that the new "
"construct performs a stricter version of type narrowing than :py:data:"
"`typing.TypeGuard`."
msgstr ""

#: ../../peps/peps/pep-0742.rst:476
msgid ""
"``TypeCheck`` (`post by Nicolas Tessore <https://discuss.python.org/t/"
"pep-724-stricter-type-guards/34124/59>`__): emphasizes the binary nature of "
"the check."
msgstr ""

#: ../../peps/peps/pep-0742.rst:478
msgid ""
"``TypeNarrower``: emphasizes that the function narrows its argument type. "
"Used in an earlier version of this PEP."
msgstr ""

#: ../../peps/peps/pep-0742.rst:481
msgid "Acknowledgments"
msgstr ""

#: ../../peps/peps/pep-0742.rst:483
msgid ""
"Much of the motivation and specification for this PEP derives from :pep:"
"`724`. While this PEP proposes a different solution for the problem at hand, "
"the authors of :pep:`724`, Eric Traut, Rich Chiodo, and Erik De Bonte, made "
"a strong case for their proposal and this proposal would not have been "
"possible without their work."
msgstr ""

#: ../../peps/peps/pep-0742.rst:490
msgid "Copyright"
msgstr ""

#: ../../peps/peps/pep-0742.rst:492
msgid ""
"This document is placed in the public domain or under the CC0-1.0-Universal "
"license, whichever is more permissive."
msgstr ""
