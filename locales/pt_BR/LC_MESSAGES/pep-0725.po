# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-14 02:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: pt_BR\n"
"Language-Team: pt_BR <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../peps/peps/pep-0725.rst
msgid "Author"
msgstr ""

#: ../../peps/peps/pep-0725.rst:3
msgid ""
"Pradyun Gedam <pradyunsg@gmail.com>, Ralf Gommers <ralf.gommers@gmail.com>"
msgstr ""

#: ../../peps/peps/pep-0725.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/peps/pep-0725.rst:5
msgid "https://discuss.python.org/t/31888"
msgstr ""

#: ../../peps/peps/pep-0725.rst
msgid "Status"
msgstr ""

#: ../../peps/peps/pep-0725.rst:6
msgid "Draft"
msgstr ""

#: ../../peps/peps/pep-0725.rst
msgid "Type"
msgstr ""

#: ../../peps/peps/pep-0725.rst:7
msgid "Standards Track"
msgstr ""

#: ../../peps/peps/pep-0725.rst
msgid "Topic"
msgstr ""

#: ../../peps/peps/pep-0725.rst:8
msgid "Packaging"
msgstr ""

#: ../../peps/peps/pep-0725.rst
msgid "Created"
msgstr ""

#: ../../peps/peps/pep-0725.rst:10
msgid "17-Aug-2023"
msgstr ""

#: ../../peps/peps/pep-0725.rst
msgid "Post-History"
msgstr ""

#: ../../peps/peps/pep-0725.rst:11
msgid "`18-Aug-2023 <https://discuss.python.org/t/31888>`__"
msgstr ""

#: ../../peps/peps/pep-0725.rst:15
msgid "Abstract"
msgstr ""

#: ../../peps/peps/pep-0725.rst:17
msgid ""
"This PEP specifies how to write a project's external, or non-PyPI, build and "
"runtime dependencies in a ``pyproject.toml`` file for packaging-related "
"tools to consume."
msgstr ""

#: ../../peps/peps/pep-0725.rst:21
msgid ""
"This PEP proposes to add an ``[external]`` table to ``pyproject.toml`` with "
"three keys: \"build-requires\", \"host-requires\" and \"dependencies\". "
"These are for specifying three types of dependencies:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:25
msgid "``build-requires``, build tools to run on the build machine"
msgstr ""

#: ../../peps/peps/pep-0725.rst:26
msgid ""
"``host-requires``, build dependencies needed for host machine but also "
"needed at build time."
msgstr ""

#: ../../peps/peps/pep-0725.rst:27
msgid ""
"``dependencies``, needed at runtime on the host machine but not needed at "
"build time."
msgstr ""

#: ../../peps/peps/pep-0725.rst:29
msgid ""
"Cross compilation is taken into account by distinguishing build and host "
"dependencies. Optional build-time and runtime dependencies are supported "
"too, in a manner analogies to how that is supported in the ``[project]`` "
"table."
msgstr ""

#: ../../peps/peps/pep-0725.rst:35
msgid "Motivation"
msgstr ""

#: ../../peps/peps/pep-0725.rst:37
msgid ""
"Python packages may have dependencies on build tools, libraries, command-"
"line tools, or other software that is not present on PyPI. Currently there "
"is no way to express those dependencies in standardized metadata [#singular-"
"vision-native-deps]_, [#pypacking-native-deps]_. Key motivators for this PEP "
"are to:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:43
msgid ""
"Enable tools to automatically map external dependencies to packages in other "
"packaging repositories,"
msgstr ""

#: ../../peps/peps/pep-0725.rst:45
msgid ""
"Make it possible to include needed dependencies in error messages emitting "
"by Python package installers and build frontends,"
msgstr ""

#: ../../peps/peps/pep-0725.rst:47
msgid ""
"Provide a canonical place for package authors to record this dependency "
"information."
msgstr ""

#: ../../peps/peps/pep-0725.rst:50
msgid ""
"Packaging ecosystems like Linux distros, Conda, Homebrew, Spack, and Nix "
"need full sets of dependencies for Python packages, and have tools like "
"pyp2spec_ (Fedora), Grayskull_ (Conda), and dh_python_ (Debian) which "
"attempt to automatically generate dependency metadata for their own package "
"managers from the metadata in upstream Python packages. External "
"dependencies are currently handled manually, because there is no metadata "
"for this in ``pyproject.toml`` or any other standard location. Enabling "
"automating this conversion is a key benefit of this PEP, making packaging "
"Python packages for distros easier and more reliable. In addition, the "
"authors envision other types of tools making use of this information, e.g., "
"dependency analysis tools like Repology_, Dependabot_ and libraries.io_. "
"Software bill of materials (SBOM) generation tools may also be able to use "
"this information, e.g. for flagging that external dependencies listed in "
"``pyproject.toml`` but not contained in wheel metadata are likely vendored "
"within the wheel."
msgstr ""

#: ../../peps/peps/pep-0725.rst:65
msgid ""
"Packages with external dependencies are typically hard to build from source, "
"and error messages from build failures tend to be hard to decipher for end "
"users. Missing external dependencies on the end user's system are the most "
"likely cause of build failures. If installers can show the required external "
"dependencies as part of their error message, this may save users a lot of "
"time."
msgstr ""

#: ../../peps/peps/pep-0725.rst:71
msgid ""
"At the moment, information on external dependencies is only captured in "
"installation documentation of individual packages. It is hard to maintain "
"for package authors and tends to go out of date. It's also hard for users "
"and distro packagers to find it. Having a canonical place to record this "
"dependency information will improve this situation."
msgstr ""

#: ../../peps/peps/pep-0725.rst:77
msgid ""
"This PEP is not trying to specify how the external dependencies should be "
"used, nor a mechanism to implement a name mapping from names of individual "
"packages that are canonical for Python projects published on PyPI to those "
"of other packaging ecosystems. Those topics should be addressed in separate "
"PEPs."
msgstr ""

#: ../../peps/peps/pep-0725.rst:84
msgid "Rationale"
msgstr ""

#: ../../peps/peps/pep-0725.rst:87
msgid "Types of external dependencies"
msgstr ""

#: ../../peps/peps/pep-0725.rst:89
msgid "Multiple types of external dependencies can be distinguished:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:91
msgid ""
"Concrete packages that can be identified by name and have a canonical "
"location in another language-specific package repository. E.g., Rust "
"packages on `crates.io <https://crates.io/>`__, R packages on `CRAN <https://"
"cran.r-project.org/>`__, JavaScript packages on the `npm registry <https://"
"www.npmjs.com/>`__."
msgstr ""

#: ../../peps/peps/pep-0725.rst:96
msgid ""
"Concrete packages that can be identified by name but do not have a clear "
"canonical location. This is typically the case for libraries and tools "
"written in C, C++, Fortran, CUDA and other low-level languages. E.g., Boost, "
"OpenSSL, Protobuf, Intel MKL, GCC."
msgstr ""

#: ../../peps/peps/pep-0725.rst:100
msgid ""
"\"Virtual\" packages, which are names for concepts, types of tools or "
"interfaces. These typically have multiple implementations, which *are* "
"concrete packages. E.g., a C++ compiler, BLAS, LAPACK, OpenMP, MPI."
msgstr ""

#: ../../peps/peps/pep-0725.rst:104
msgid ""
"Concrete packages are straightforward to understand, and are a concept "
"present in virtually every package management system. Virtual packages are a "
"concept also present in a number of packaging systems -- but not always, and "
"the details of their implementation varies."
msgstr ""

#: ../../peps/peps/pep-0725.rst:110
msgid "Cross compilation"
msgstr ""

#: ../../peps/peps/pep-0725.rst:112
msgid ""
"Cross compilation is not yet (as of August 2023) well-supported by stdlib "
"modules and ``pyproject.toml`` metadata. It is however important when "
"translating external dependencies to those of other packaging systems (with "
"tools like ``pyp2spec``). Introducing support for cross compilation "
"immediately in this PEP is much easier than extending ``[external]`` in the "
"future, hence the authors choose to include this now."
msgstr ""

#: ../../peps/peps/pep-0725.rst:120
msgid "Terminology"
msgstr ""

#: ../../peps/peps/pep-0725.rst:122
msgid "This PEP uses the following terminology:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:124
msgid ""
"*build machine*: the machine on which the package build process is being "
"executed"
msgstr ""

#: ../../peps/peps/pep-0725.rst:126
msgid ""
"*host machine*: the machine on which the produced artifact will be installed "
"and run"
msgstr ""

#: ../../peps/peps/pep-0725.rst:128
msgid ""
"*build dependency*: dependency for building the package that needs to be "
"present at build time and itself was built for the build machine's OS and "
"architecture"
msgstr ""

#: ../../peps/peps/pep-0725.rst:131
msgid ""
"*host dependency*: dependency for building the package that needs to be "
"present at build time and itself was built for the host machine's OS and "
"architecture"
msgstr ""

#: ../../peps/peps/pep-0725.rst:135
msgid ""
"Note that this terminology is not consistent across build and packaging "
"tools, so care must be taken when comparing build/host dependencies in "
"``pyproject.toml`` to dependencies from other package managers."
msgstr ""

#: ../../peps/peps/pep-0725.rst:139
msgid ""
"Note that \"target machine\" or \"target dependency\" is not used in this "
"PEP. That is typically only relevant for cross-compiling compilers or other "
"such advanced scenarios [#gcc-cross-terminology]_, [#meson-cross]_ - this is "
"out of scope for this PEP."
msgstr ""

#: ../../peps/peps/pep-0725.rst:144
msgid ""
"Finally, note that while \"dependency\" is the term most widely used for "
"packages needed at build time, the existing key in ``pyproject.toml`` for "
"PyPI build-time dependencies is ``build-requires``. Hence this PEP uses the "
"keys ``build-requires`` and ``host-requires`` under ``[external]`` for "
"consistency."
msgstr ""

#: ../../peps/peps/pep-0725.rst:150
msgid "Build and host dependencies"
msgstr ""

#: ../../peps/peps/pep-0725.rst:152
msgid ""
"Clear separation of metadata associated with the definition of build and "
"target platforms, rather than assuming that build and target platform will "
"always be the same, is important [#pypackaging-native-cross]_."
msgstr ""

#: ../../peps/peps/pep-0725.rst:156
msgid ""
"Build dependencies are typically run during the build process - they may be "
"compilers, code generators, or other such tools. In case the use of a build "
"dependency implies a runtime dependency, that runtime dependency does not "
"have to be declared explicitly. For example, when compiling Fortran code "
"with ``gfortran`` into a Python extension module, the package likely incurs "
"a dependency on the ``libgfortran`` runtime library. The rationale for not "
"explicitly listing such runtime dependencies is two-fold: (1) it may depend "
"on compiler/linker flags or details of the build environment whether the "
"dependency is present, and (2) these runtime dependencies can be detected "
"and handled automatically by tools like ``auditwheel``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:167
msgid ""
"Host dependencies are typically not run during the build process, but only "
"used for linking against. This is not a rule though -- it may be possible or "
"necessary to run a host dependency under an emulator, or through a custom "
"tool like crossenv_. When host dependencies imply a runtime dependency, that "
"runtime dependency also does not have to be declared, just like for build "
"dependencies."
msgstr ""

#: ../../peps/peps/pep-0725.rst:173
msgid ""
"When host dependencies are declared and a tool is not cross-compilation "
"aware and has to do something with external dependencies, the tool MAY merge "
"the ``host-requires`` list into ``build-requires``. This may for example "
"happen if an installer like ``pip`` starts reporting external dependencies "
"as a likely cause of a build failure when a package fails to build from an "
"sdist."
msgstr ""

#: ../../peps/peps/pep-0725.rst:180
msgid "Specifying external dependencies"
msgstr ""

#: ../../peps/peps/pep-0725.rst:183
msgid "Concrete package specification through PURL"
msgstr ""

#: ../../peps/peps/pep-0725.rst:185
msgid ""
"The two types of concrete packages are supported by PURL_ (Package URL), "
"which implements a scheme for identifying packages that is meant to be "
"portable across packaging ecosystems. Its design is::"
msgstr ""

#: ../../peps/peps/pep-0725.rst:191
msgid ""
"The ``scheme`` component is a fixed string, ``pkg``, and of the other "
"components only ``type`` and ``name`` are required. As an example, a package "
"URL for the ``requests`` package on PyPI would be::"
msgstr ""

#: ../../peps/peps/pep-0725.rst:197
msgid ""
"Adopting PURL to specify external dependencies in ``pyproject.toml`` solves "
"a number of problems at once - and there are already implementations of the "
"specification in Python and multiple languages. PURL is also already "
"supported by dependency-related tooling like SPDX (see `External Repository "
"Identifiers in the SPDX 2.3 spec <https://spdx.github.io/spdx-spec/v2.3/"
"external-repository-identifiers/#f35-purl>`__), the `Open Source "
"Vulnerability format <https://ossf.github.io/osv-schema/#affectedpackage-"
"field>`__, and the `Sonatype OSS Index <https://ossindex.sonatype.org/doc/"
"coordinates>`__; not having to wait years before support in such tooling "
"arrives is valuable."
msgstr ""

#: ../../peps/peps/pep-0725.rst:206
msgid ""
"For concrete packages without a canonical package manager to refer to, "
"either ``pkg:generic/pkg-name`` can be used, or a direct reference to the "
"VCS system that the package is maintained in (e.g., ``pkg:github/user-or-org-"
"name/pkg-name``). Which of these is more appropriate is situation-dependent. "
"This PEP recommends using ``pkg:generic`` when the package name is "
"unambiguous and well-known (e.g., ``pkg:generic/git`` or ``pkg:generic/"
"openblas``), and using the VCS as the PURL type otherwise."
msgstr ""

#: ../../peps/peps/pep-0725.rst:215
msgid "Virtual package specification"
msgstr ""

#: ../../peps/peps/pep-0725.rst:217
msgid ""
"There is no ready-made support for virtual packages in PURL or another "
"standard. There are a relatively limited number of such dependencies though, "
"and adopting a scheme similar to PURL but with the ``virtual:`` rather than "
"``pkg:`` scheme seems like it will be understandable and map well to Linux "
"distros with virtual packages and to the likes of Conda and Spack."
msgstr ""

#: ../../peps/peps/pep-0725.rst:223
msgid "The two known virtual package types are ``compiler`` and ``interface``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:226
msgid "Versioning"
msgstr ""

#: ../../peps/peps/pep-0725.rst:228
msgid ""
"Support in PURL for version expressions and ranges beyond a fixed version is "
"still pending, see the Open Issues section."
msgstr ""

#: ../../peps/peps/pep-0725.rst:232
msgid "Dependency specifiers"
msgstr ""

#: ../../peps/peps/pep-0725.rst:234
msgid ""
"Regular Python dependency specifiers (as originally defined in :pep:`508`) "
"may be used behind PURLs. PURL qualifiers, which use ``?`` followed by a "
"package type-specific dependency specifier component, must not be used. The "
"reason for this is pragmatic: dependency specifiers are already used for "
"other metadata in ``pyproject.toml``, any tooling that is used with "
"``pyproject.toml`` is likely to already have a robust implementation to "
"parse it. And we do not expect to need the extra possibilities that PURL "
"qualifiers provide (e.g. to specify a Conan or Conda channel, or a RubyGems "
"platform)."
msgstr ""

#: ../../peps/peps/pep-0725.rst:244
msgid "Usage of core metadata fields"
msgstr ""

#: ../../peps/peps/pep-0725.rst:246
msgid ""
"The `core metadata`_ specification contains one relevant field, namely "
"``Requires-External``. This has no well-defined semantics in core metadata "
"2.1; this PEP chooses to reuse the field for external runtime dependencies. "
"The core metadata specification does not contain fields for any metadata in "
"``pyproject.toml``'s ``[build-system]`` table. Therefore the ``build-"
"requires`` and ``host-requires`` content also does not need to be reflected "
"in core metadata fields. The ``optional-dependencies`` content from "
"``[external]`` would need to either reuse ``Provides-Extra`` or require a "
"new ``Provides-External-Extra`` field. Neither seems desirable."
msgstr ""

#: ../../peps/peps/pep-0725.rst:257
msgid "Differences between sdist and wheel metadata"
msgstr ""

#: ../../peps/peps/pep-0725.rst:259
msgid ""
"A wheel may vendor its external dependencies. This happens in particular "
"when distributing wheels on PyPI or other Python package indexes - and tools "
"like auditwheel_, delvewheel_ and delocate_ automate this process. As a "
"result, a ``Requires-External`` entry in an sdist may disappear from a wheel "
"built from that sdist. It is also possible that a ``Requires-External`` "
"entry remains in a wheel, either unchanged or with narrower constraints. "
"``auditwheel`` does not vendor certain allow-listed dependencies, such as "
"OpenGL, by default. In addition, ``auditwheel`` and ``delvewheel`` allow a "
"user to manually exclude dependencies via a ``--exclude`` or ``--no-dll`` "
"command-line flag. This is used to avoid vendoring large shared libraries, "
"for example those from CUDA."
msgstr ""

#: ../../peps/peps/pep-0725.rst:270
msgid ""
"``Requires-External`` entries generated from external dependencies in "
"``pyproject.toml`` in a wheel are therefore allowed to be narrower than "
"those for the corresponding sdist. They must not be wider, i.e. constraints "
"must not allow a version of a dependency for a wheel that isn't allowed for "
"an sdist, nor contain new dependencies that are not listed in the sdist's "
"metadata at all."
msgstr ""

#: ../../peps/peps/pep-0725.rst:278
msgid "Canonical names of dependencies and ``-dev(el)`` split packages"
msgstr ""

#: ../../peps/peps/pep-0725.rst:280
msgid ""
"It is fairly common for distros to split a package into two or more "
"packages. In particular, runtime components are often separately installable "
"from development components (headers, pkg-config and CMake files, etc.). The "
"latter then typically has a name with ``-dev`` or ``-devel`` appended to the "
"project/library name. This split is the responsibility of each distro to "
"maintain, and should not be reflected in the ``[external]`` table. It is not "
"possible to specify this in a reasonable way that works across distros, "
"hence only the canonical name should be used in ``[external]``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:289
msgid ""
"The intended meaning of using a PURL or virtual dependency is \"the full "
"package with the name specified\". It will depend on the context in which "
"the metadata is used whether the split is relevant. For example, if "
"``libffi`` is a host dependency and a tool wants to prepare an environment "
"for building a wheel, then if a distro has split off the headers for "
"``libffi`` into a ``libffi-devel`` package then the tool has to install both "
"``libffi`` and ``libffi-devel``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:298
msgid "Python development headers"
msgstr ""

#: ../../peps/peps/pep-0725.rst:300
msgid ""
"Python headers and other build support files may also be split. This is the "
"same situation as in the section above (because Python is simply a regular "
"package in distros). *However*, a ``python-dev|devel`` dependency is special "
"because in ``pyproject.toml`` Python itself is an implicit rather than an "
"explicit dependency. Hence a choice needs to be made here - add ``python-"
"dev`` implicitly, or make each package author add it explicitly under "
"``[external]``. For consistency between Python dependencies and external "
"dependencies, we choose to add it implicitly. Python development headers "
"must be assumed to be necessary when an ``[external]`` table contains one or "
"more compiler packages."
msgstr ""

#: ../../peps/peps/pep-0725.rst:312
msgid "Specification"
msgstr ""

#: ../../peps/peps/pep-0725.rst:314
msgid ""
"If metadata is improperly specified then tools MUST raise an error to notify "
"the user about their mistake."
msgstr ""

#: ../../peps/peps/pep-0725.rst:318
msgid "Details"
msgstr ""

#: ../../peps/peps/pep-0725.rst:320
msgid ""
"Note that ``pyproject.toml`` content is in the same format as in :pep:`621`."
msgstr ""

#: ../../peps/peps/pep-0725.rst:323
msgid "Table name"
msgstr ""

#: ../../peps/peps/pep-0725.rst:325
msgid ""
"Tools MUST specify fields defined by this PEP in a table named "
"``[external]``. No tools may add fields to this table which are not defined "
"by this PEP or subsequent PEPs. The lack of an ``[external]`` table means "
"the package either does not have any external dependencies, or the ones it "
"does have are assumed to be present on the system already."
msgstr ""

#: ../../peps/peps/pep-0725.rst:332
msgid "``build-requires``/``optional-build-requires``"
msgstr ""

#: ../../peps/peps/pep-0725.rst:334
msgid ""
"Format: Array of PURL_ strings (``build-requires``) and a table with values "
"of arrays of PURL_ strings (``optional-build-requires``)"
msgstr ""

#: ../../peps/peps/pep-0725.rst:336 ../../peps/peps/pep-0725.rst:353
msgid "`Core metadata`_: N/A"
msgstr ""

#: ../../peps/peps/pep-0725.rst:338
msgid "The (optional) external build requirements needed to build the project."
msgstr ""

#: ../../peps/peps/pep-0725.rst:340
msgid ""
"For ``build-requires``, it is a key whose value is an array of strings. Each "
"string represents a build requirement of the project and MUST be formatted "
"as either a valid PURL_ string or a ``virtual:`` string."
msgstr ""

#: ../../peps/peps/pep-0725.rst:344
msgid ""
"For ``optional-build-requires``, it is a table where each key specifies an "
"extra set of build requirements and whose value is an array of strings. The "
"strings of the arrays MUST be valid PURL_ strings."
msgstr ""

#: ../../peps/peps/pep-0725.rst:349
msgid "``host-requires``/``optional-host-requires``"
msgstr ""

#: ../../peps/peps/pep-0725.rst:351
msgid ""
"Format: Array of PURL_ strings (``host-requires``) and a table with values "
"of arrays of PURL_ strings (``optional-host-requires``)"
msgstr ""

#: ../../peps/peps/pep-0725.rst:355
msgid "The (optional) external host requirements needed to build the project."
msgstr ""

#: ../../peps/peps/pep-0725.rst:357
msgid ""
"For ``host-requires``, it is a key whose value is an array of strings. Each "
"string represents a host requirement of the project and MUST be formatted as "
"either a valid PURL_ string or a ``virtual:`` string."
msgstr ""

#: ../../peps/peps/pep-0725.rst:361
msgid ""
"For ``optional-host-requires``, it is a table where each key specifies an "
"extra set of host requirements and whose value is an array of strings. The "
"strings of the arrays MUST be valid PURL_ strings."
msgstr ""

#: ../../peps/peps/pep-0725.rst:366
msgid "``dependencies``/``optional-dependencies``"
msgstr ""

#: ../../peps/peps/pep-0725.rst:368
msgid ""
"Format: Array of PURL_ strings (``dependencies``) and a table with values of "
"arrays of PURL_ strings (``optional-dependencies``)"
msgstr ""

#: ../../peps/peps/pep-0725.rst:370
msgid "`Core metadata`_: ``Requires-External``, N/A"
msgstr ""

#: ../../peps/peps/pep-0725.rst:372
msgid "The (optional) runtime dependencies of the project."
msgstr ""

#: ../../peps/peps/pep-0725.rst:374
msgid ""
"For ``dependencies``, it is a key whose value is an array of strings. Each "
"string represents a dependency of the project and MUST be formatted as "
"either a valid PURL_ string or a ``virtual:`` string. Each string maps "
"directly to a ``Requires-External`` entry in the `core metadata`_."
msgstr ""

#: ../../peps/peps/pep-0725.rst:379
msgid ""
"For ``optional-dependencies``, it is a table where each key specifies an "
"extra and whose value is an array of strings. The strings of the arrays MUST "
"be valid PURL_ strings. Optional dependencies do not map to a core metadata "
"field."
msgstr ""

#: ../../peps/peps/pep-0725.rst:384
msgid "Examples"
msgstr ""

#: ../../peps/peps/pep-0725.rst:386
msgid ""
"These examples show what the ``[external]`` content for a number of packages "
"is expected to be."
msgstr ""

#: ../../peps/peps/pep-0725.rst:389
msgid "cryptography 39.0:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:404
msgid "SciPy 1.10:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:421
msgid "Pillow 10.1.0:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:448
msgid "NAVis 1.4.0:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:466
msgid "Spyder 6.0:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:477
msgid "jupyterlab-git 0.41.0:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:491
msgid "PyEnchant 3.2.2:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:505
msgid "Backwards Compatibility"
msgstr ""

#: ../../peps/peps/pep-0725.rst:507
msgid ""
"There is no impact on backwards compatibility, as this PEP only adds new, "
"optional metadata. In the absence of such metadata, nothing changes for "
"package authors or packaging tooling."
msgstr ""

#: ../../peps/peps/pep-0725.rst:513
msgid "Security Implications"
msgstr ""

#: ../../peps/peps/pep-0725.rst:515
msgid ""
"There are no direct security concerns as this PEP covers how to statically "
"define metadata for external dependencies. Any security issues would stem "
"from how tools consume the metadata and choose to act upon it."
msgstr ""

#: ../../peps/peps/pep-0725.rst:521
msgid "How to Teach This"
msgstr ""

#: ../../peps/peps/pep-0725.rst:523
msgid ""
"External dependencies and if and how those external dependencies are "
"vendored are topics that are typically not understood in detail by Python "
"package authors. We intend to start from how an external dependency is "
"defined, the different ways it can be depended on---from runtime-only with "
"``ctypes`` or a ``subprocess`` call to it being a build dependency that's "
"linked against--- before going into how to declare external dependencies in "
"metadata. The documentation should make explicit what is relevant for "
"package authors, and what for distro packagers."
msgstr ""

#: ../../peps/peps/pep-0725.rst:532
msgid ""
"Material on this topic will be added to the most relevant packaging "
"tutorials, primarily the `Python Packaging User Guide`_. In addition, we "
"expect that any build backend that adds support for external dependencies "
"metadata will include information about that in its documentation, as will "
"tools like ``auditwheel``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:539
msgid "Reference Implementation"
msgstr ""

#: ../../peps/peps/pep-0725.rst:541
msgid ""
"This PEP contains a metadata specification, rather that a code feature - "
"hence there will not be code implementing the metadata spec as a whole. "
"However, there are parts that do have a reference implementation:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:545
msgid ""
"The ``[external]`` table has to be valid TOML and therefore can be loaded "
"with ``tomllib``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:547
msgid ""
"The PURL specification, as a key part of this spec, has a Python package "
"with a reference implementation for constructing and parsing PURLs: "
"`packageurl-python`_."
msgstr ""

#: ../../peps/peps/pep-0725.rst:551
msgid ""
"There are multiple possible consumers and use cases of this metadata, once "
"that metadata gets added to Python packages. Tested metadata for all of the "
"top 150 most-downloaded packages from PyPI with published platform-specific "
"wheels can be found in `rgommers/external-deps-build`_. This metadata has "
"been validated by using it to build wheels from sdists patched with that "
"metadata in clean Docker containers."
msgstr ""

#: ../../peps/peps/pep-0725.rst:560
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/peps/pep-0725.rst:563
msgid ""
"Specific syntax for external dependencies which are also packaged on PyPI"
msgstr ""

#: ../../peps/peps/pep-0725.rst:565
msgid ""
"There are non-Python packages which are packaged on PyPI, such as Ninja, "
"patchelf and CMake. What is typically desired is to use the system version "
"of those, and if it's not present on the system then install the PyPI "
"package for it. The authors believe that specific support for this scenario "
"is not necessary (or too complex to justify such support); a dependency "
"provider for external dependencies can treat PyPI as one possible source for "
"obtaining the package."
msgstr ""

#: ../../peps/peps/pep-0725.rst:574
msgid "Using library and header names as external dependencies"
msgstr ""

#: ../../peps/peps/pep-0725.rst:576
msgid ""
"A previous draft PEP (`\"External dependencies\" (2015) <https://github.com/"
"pypa/interoperability-peps/pull/30>`__) proposed using specific library and "
"header names as external dependencies. This is too granular; using package "
"names is a well-established pattern across packaging ecosystems and should "
"be preferred."
msgstr ""

#: ../../peps/peps/pep-0725.rst:583
msgid "Open Issues"
msgstr ""

#: ../../peps/peps/pep-0725.rst:586
msgid "Version specifiers for PURLs"
msgstr ""

#: ../../peps/peps/pep-0725.rst:588
msgid ""
"Support in PURL for version expressions and ranges is still pending. The "
"pull request at `vers implementation for PURL`_ seems close to being merged, "
"at which point this PEP could adopt it."
msgstr ""

#: ../../peps/peps/pep-0725.rst:593
msgid "Versioning of virtual dependencies"
msgstr ""

#: ../../peps/peps/pep-0725.rst:595
msgid ""
"Once PURL supports version expressions, virtual dependencies can be "
"versioned with the same syntax. It must be better specified however what the "
"version scheme is, because this is not as clear for virtual dependencies as "
"it is for PURLs (e.g., there can be multiple implementations, and abstract "
"interfaces may not be unambiguously versioned). E.g.:"
msgstr ""

#: ../../peps/peps/pep-0725.rst:601
msgid ""
"OpenMP: has regular ``MAJOR.MINOR`` versions of its standard, so would look "
"like ``>=4.5``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:603
msgid ""
"BLAS/LAPACK: should use the versioning used by `Reference LAPACK`_, which "
"defines what the standard APIs are. Uses ``MAJOR.MINOR.MICRO``, so would "
"look like ``>=3.10.0``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:606
msgid ""
"Compilers: these implement language standards. For C, C++ and Fortran these "
"are versioned by year. In order for versions to sort correctly, we choose to "
"use the full year (four digits). So \"at least C99\" would be ``>=1999``, "
"and selecting C++14 or Fortran 77 would be ``==2014`` or ``==1977`` "
"respectively. Other languages may use different versioning schemes. These "
"should be described somewhere before they are used in ``pyproject.toml``."
msgstr ""

#: ../../peps/peps/pep-0725.rst:613
msgid ""
"A logistical challenge is where to describe the versioning - given that this "
"will evolve over time, this PEP itself is not the right location for it. "
"Instead, this PEP should point at that (to be created) location."
msgstr ""

#: ../../peps/peps/pep-0725.rst:618
msgid "Who defines canonical names and canonical package structure?"
msgstr ""

#: ../../peps/peps/pep-0725.rst:620
msgid ""
"Similarly to the logistics around versioning is the question about what "
"names are allowed and where they are described. And then who is in control "
"of that description and responsible for maintaining it. Our tentative answer "
"is: there should be a central list for virtual dependencies and ``pkg:"
"generic`` PURLs, maintained as a PyPA project. See https://discuss.python."
"org/t/pep-725-specifying-external-dependencies-in-pyproject-toml/31888/62. "
"TODO: once that list/project is prototyped, include it in the PEP and close "
"this open issue."
msgstr ""

#: ../../peps/peps/pep-0725.rst:630
msgid "Syntax for virtual dependencies"
msgstr ""

#: ../../peps/peps/pep-0725.rst:632
msgid ""
"The current syntax this PEP uses for virtual dependencies is ``virtual:type/"
"name``, which is analogous to but not part of the PURL spec. This open issue "
"discusses supporting virtual dependencies within PURL: `purl-spec#222 "
"<https://github.com/package-url/purl-spec/issues/222>`__."
msgstr ""

#: ../../peps/peps/pep-0725.rst:638
msgid "Should a ``host-requires`` key be added under ``[build-system]``?"
msgstr ""

#: ../../peps/peps/pep-0725.rst:640
msgid ""
"Adding ``host-requires`` for host dependencies that are on PyPI in order to "
"better support name mapping to other packaging systems with support for "
"cross-compiling may make sense. `This issue <https://github.com/rgommers/"
"peps/issues/6>`__ tracks this topic and has arguments in favor and against "
"adding ``host-requires`` under ``[build-system]`` as part of this PEP."
msgstr ""

#: ../../peps/peps/pep-0725.rst:649
msgid "References"
msgstr ""

#: ../../peps/peps/pep-0725.rst:651
msgid ""
"The \"define native requirements metadata\" part of the \"Wanting a singular "
"packaging vision\" thread (2022, Discourse): https://discuss.python.org/t/"
"wanting-a-singular-packaging-tool-vision/21141/92"
msgstr ""

#: ../../peps/peps/pep-0725.rst:655
msgid ""
"pypackaging-native: \"Native dependencies\" https://pypackaging-native."
"github.io/key-issues/native-dependencies/"
msgstr ""

#: ../../peps/peps/pep-0725.rst:658
msgid ""
"GCC documentation - Configure Terms and History, https://gcc.gnu.org/"
"onlinedocs/gccint/Configure-Terms.html"
msgstr ""

#: ../../peps/peps/pep-0725.rst:661
msgid ""
"Meson documentation - Cross compilation https://mesonbuild.com/Cross-"
"compilation.html"
msgstr ""

#: ../../peps/peps/pep-0725.rst:664
msgid ""
"pypackaging-native: \"Cross compilation\" https://pypackaging-native.github."
"io/key-issues/cross_compilation/"
msgstr ""

#: ../../peps/peps/pep-0725.rst:667
msgid ""
"The \"``pkgconfig`` specification as an alternative to ``ctypes.util."
"find_library``\" thread (2023, Discourse): https://discuss.python.org/t/"
"pkgconfig-specification-as-an-alternative-to-ctypes-util-find-library/31379"
msgstr ""

#: ../../peps/peps/pep-0725.rst:673
msgid "Copyright"
msgstr ""

#: ../../peps/peps/pep-0725.rst:675
msgid ""
"This document is placed in the public domain or under the CC0-1.0-Universal "
"license, whichever is more permissive."
msgstr ""
