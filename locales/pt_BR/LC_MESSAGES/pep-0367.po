# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0367.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-0367.rst:5
msgid ""
"Calvin Spealman <ironfroggy@gmail.com>, Tim Delaney "
"<timothy.c.delaney@gmail.com>"
msgstr ""

#: ../../peps/pep-0367.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-0367.rst:7
msgid "Superseded"
msgstr ""

#: ../../peps/pep-0367.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-0367.rst:8
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0367.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-0367.rst:10
msgid "28-Apr-2007"
msgstr ""

#: ../../peps/pep-0367.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0367.rst:11
msgid "2.6"
msgstr ""

#: ../../peps/pep-0367.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-0367.rst:12
msgid ""
"`28-Apr-2007 <https://mail.python.org/pipermail/python-"
"dev/2007-April/072807.html>`__, `29-Apr-2007 "
"<https://mail.python.org/pipermail/python-dev/2007-April/072835.html>`__,"
" `29-Apr-2007 <https://mail.python.org/pipermail/python-"
"dev/2007-April/072858.html>`__, `14-May-2007 "
"<https://mail.python.org/pipermail/python-dev/2007-May/073127.html>`__"
msgstr ""

#: ../../peps/pep-0367.rst:18
msgid "Numbering Note"
msgstr ""

#: ../../peps/pep-0367.rst:20
msgid ""
"This PEP has been renumbered to :pep:`3135`.  The text below is the last "
"version submitted under the old number."
msgstr ""

#: ../../peps/pep-0367.rst:24
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0367.rst:26
msgid ""
"This PEP proposes syntactic sugar for use of the ``super`` type to "
"automatically construct instances of the super type binding to the class "
"that a method was defined in, and the instance (or class object for "
"classmethods) that the method is currently acting upon."
msgstr ""

#: ../../peps/pep-0367.rst:31
msgid "The premise of the new super usage suggested is as follows::"
msgstr ""

#: ../../peps/pep-0367.rst:35
msgid "to replace the old::"
msgstr ""

#: ../../peps/pep-0367.rst:39
msgid ""
"and the current ``__builtin__.super`` be aliased to "
"``__builtin__.__super__`` (with ``__builtin__.super`` to be removed in "
"Python 3.0)."
msgstr ""

#: ../../peps/pep-0367.rst:42
msgid ""
"It is further proposed that assignment to ``super`` become a "
"``SyntaxError``, similar to the behaviour of ``None``."
msgstr ""

#: ../../peps/pep-0367.rst:47
msgid "Rationale"
msgstr ""

#: ../../peps/pep-0367.rst:49
msgid ""
"The current usage of super requires an explicit passing of both the class"
" and instance it must operate from, requiring a breaking of the DRY "
"(Don't Repeat Yourself) rule. This hinders any change in class name, and "
"is often considered a wart by many."
msgstr ""

#: ../../peps/pep-0367.rst:56
msgid "Specification"
msgstr ""

#: ../../peps/pep-0367.rst:58
msgid ""
"Within the specification section, some special terminology will be used "
"to distinguish similar and closely related concepts. \"super type\" will "
"refer to the actual builtin type named \"super\". A \"super instance\" is"
" simply an instance of the super type, which is associated with a class "
"and possibly with an instance of that class."
msgstr ""

#: ../../peps/pep-0367.rst:64
msgid ""
"Because the new ``super`` semantics are not backwards compatible with "
"Python 2.5, the new semantics will require a ``__future__`` import::"
msgstr ""

#: ../../peps/pep-0367.rst:69
msgid ""
"The current ``__builtin__.super`` will be aliased to "
"``__builtin__.__super__``. This will occur regardless of whether the new "
"``super`` semantics are active. It is not possible to simply rename "
"``__builtin__.super``, as that would affect modules that do not use the "
"new ``super`` semantics. In Python 3.0 it is proposed that the name "
"``__builtin__.super`` will be removed."
msgstr ""

#: ../../peps/pep-0367.rst:75
msgid ""
"Replacing the old usage of super, calls to the next class in the MRO "
"(method resolution order) can be made without explicitly creating a "
"``super`` instance (although doing so will still be supported via "
"``__super__``). Every function will have an implicit local named "
"``super``. This name behaves identically to a normal local, including use"
" by inner functions via a cell, with the following exceptions:"
msgstr ""

#: ../../peps/pep-0367.rst:82
msgid ""
"Assigning to the name ``super`` will raise a ``SyntaxError`` at compile "
"time;"
msgstr ""

#: ../../peps/pep-0367.rst:84
msgid ""
"Calling a static method or normal function that accesses the name "
"``super`` will raise a ``TypeError`` at runtime."
msgstr ""

#: ../../peps/pep-0367.rst:87
msgid ""
"Every function that uses the name ``super``, or has an inner function "
"that uses the name ``super``, will include a preamble that performs the "
"equivalent of::"
msgstr ""

#: ../../peps/pep-0367.rst:93
msgid ""
"where ``<class>`` is the class that the method was defined in, and "
"``<instance>`` is the first parameter of the method (normally ``self`` "
"for instance methods, and ``cls`` for class methods). For static methods "
"and normal functions, ``<class>`` will be ``None``, resulting in a "
"``TypeError`` being raised during the preamble."
msgstr ""

#: ../../peps/pep-0367.rst:99
msgid ""
"Note: The relationship between ``super`` and ``__super__`` is similar to "
"that between ``import`` and ``__import__``."
msgstr ""

#: ../../peps/pep-0367.rst:102
msgid ""
"Much of this was discussed in the thread of the python-dev list, \"Fixing"
" super anyone?\" [1]_."
msgstr ""

#: ../../peps/pep-0367.rst:107
msgid "Open Issues"
msgstr ""

#: ../../peps/pep-0367.rst:111
msgid "Determining the class object to use"
msgstr ""

#: ../../peps/pep-0367.rst:113
msgid ""
"The exact mechanism for associating the method with the defining class is"
" not specified in this PEP, and should be chosen for maximum performance."
" For CPython, it is suggested that the class instance be held in a "
"C-level variable on the function object which is bound to one of ``NULL``"
" (not part of a class), ``Py_None`` (static method) or a class object "
"(instance or class method)."
msgstr ""

#: ../../peps/pep-0367.rst:121
msgid "Should ``super`` actually become a keyword?"
msgstr ""

#: ../../peps/pep-0367.rst:123
msgid ""
"With this proposal, ``super`` would become a keyword to the same extent "
"that ``None`` is a keyword. It is possible that further restricting the "
"``super`` name may simplify implementation, however some are against the "
"actual keyword-ization of super. The simplest solution is often the "
"correct solution and the simplest solution may well not be adding "
"additional keywords to the language when they are not needed. Still, it "
"may solve other open issues."
msgstr ""

#: ../../peps/pep-0367.rst:132
msgid "Closed Issues"
msgstr ""

#: ../../peps/pep-0367.rst:135
msgid "super used with __call__ attributes"
msgstr ""

#: ../../peps/pep-0367.rst:137
msgid ""
"It was considered that it might be a problem that instantiating super "
"instances the classic way, because calling it would lookup the __call__ "
"attribute and thus try to perform an automatic super lookup to the next "
"class in the MRO. However, this was found to be false, because calling an"
" object only looks up the __call__ method directly on the object's type. "
"The following example shows this in action."
msgstr ""

#: ../../peps/pep-0367.rst:156
msgid ""
"In any case, with the renaming of ``__builtin__.super`` to "
"``__builtin__.__super__`` this issue goes away entirely."
msgstr ""

#: ../../peps/pep-0367.rst:161
msgid "Reference Implementation"
msgstr ""

#: ../../peps/pep-0367.rst:163
msgid ""
"It is impossible to implement the above specification entirely in Python."
" This reference implementation has the following differences to the "
"specification:"
msgstr ""

#: ../../peps/pep-0367.rst:166
msgid "New ``super`` semantics are implemented using bytecode hacking."
msgstr ""

#: ../../peps/pep-0367.rst:168
msgid "Assignment to ``super`` is not a ``SyntaxError``. Also see point #4."
msgstr ""

#: ../../peps/pep-0367.rst:170
msgid ""
"Classes must either use the metaclass ``autosuper_meta`` or inherit from "
"the base class ``autosuper`` to acquire the new ``super`` semantics."
msgstr ""

#: ../../peps/pep-0367.rst:173
msgid ""
"``super`` is not an implicit local variable. In particular, for inner "
"functions to be able to use the super instance, there must be an "
"assignment of the form ``super = super`` in the method."
msgstr ""

#: ../../peps/pep-0367.rst:177
msgid "The reference implementation assumes that it is being run on Python 2.5+."
msgstr ""

#: ../../peps/pep-0367.rst:417
msgid ""
"Disassembly of B.f and C.f reveals the different preambles used when "
"``super`` is simply a local variable compared to when it is used by an "
"inner function."
msgstr ""

#: ../../peps/pep-0367.rst:461
msgid ""
"Note that in the final implementation, the preamble would not be part of "
"the bytecode of the method, but would occur immediately following "
"unpacking of parameters."
msgstr ""

#: ../../peps/pep-0367.rst:467
msgid "Alternative Proposals"
msgstr ""

#: ../../peps/pep-0367.rst:470
msgid "No Changes"
msgstr ""

#: ../../peps/pep-0367.rst:472
msgid ""
"Although its always attractive to just keep things how they are, people "
"have sought a change in the usage of super calling for some time, and for"
" good reason, all mentioned previously."
msgstr ""

#: ../../peps/pep-0367.rst:476
msgid ""
"Decoupling from the class name (which might not even be bound to the "
"right class anymore!)"
msgstr ""

#: ../../peps/pep-0367.rst:478
msgid "Simpler looking, cleaner super calls would be better"
msgstr ""

#: ../../peps/pep-0367.rst:481
msgid "Dynamic attribute on super type"
msgstr ""

#: ../../peps/pep-0367.rst:483
msgid ""
"The proposal adds a dynamic attribute lookup to the super type, which "
"will automatically determine the proper class and instance parameters. "
"Each super attribute lookup identifies these parameters and performs the "
"super lookup on the instance, as the current super implementation does "
"with the explicit invocation of a super instance upon a class and "
"instance."
msgstr ""

#: ../../peps/pep-0367.rst:489
msgid ""
"This proposal relies on sys._getframe(), which is not appropriate for "
"anything except a prototype implementation."
msgstr ""

#: ../../peps/pep-0367.rst:494
msgid "super(__this_class__, self)"
msgstr ""

#: ../../peps/pep-0367.rst:496
msgid ""
"This is nearly an anti-proposal, as it basically relies on the acceptance"
" of the __this_class__ PEP, which proposes a special name that would "
"always be bound to the class within which it is used. If that is "
"accepted, __this_class__ could simply be used instead of the class' name "
"explicitly, solving the name binding issues [2]_."
msgstr ""

#: ../../peps/pep-0367.rst:503
msgid "self.__super__.foo(\\*args)"
msgstr ""

#: ../../peps/pep-0367.rst:505
msgid ""
"The __super__ attribute is mentioned in this PEP in several places, and "
"could be a candidate for the complete solution, actually using it "
"explicitly instead of any super usage directly. However, double-"
"underscore names are usually an internal detail, and attempted to be kept"
" out of everyday code."
msgstr ""

#: ../../peps/pep-0367.rst:511
msgid "super(self, \\*args) or __super__(self, \\*args)"
msgstr ""

#: ../../peps/pep-0367.rst:513
msgid ""
"This solution only solves the problem of the type indication, does not "
"handle differently named super methods, and is explicit about the name of"
" the instance. It is less flexible without being able to enacted on other"
" method names, in cases where that is needed. One use case this fails is "
"where a base-class has a factory classmethod and a subclass has two "
"factory classmethods, both of which needing to properly make super calls "
"to the one in the base-class."
msgstr ""

#: ../../peps/pep-0367.rst:522
msgid "super.foo(self, \\*args)"
msgstr ""

#: ../../peps/pep-0367.rst:524
msgid ""
"This variation actually eliminates the problems with locating the proper "
"instance, and if any of the alternatives were pushed into the spotlight, "
"I would want it to be this one."
msgstr ""

#: ../../peps/pep-0367.rst:529
msgid "super or super()"
msgstr ""

#: ../../peps/pep-0367.rst:531
msgid ""
"This proposal leaves no room for different names, signatures, or "
"application to other classes, or instances. A way to allow some similar "
"use alongside the normal proposal would be favorable, encouraging good "
"design of multiple inheritance trees and compatible methods."
msgstr ""

#: ../../peps/pep-0367.rst:537
msgid "super(\\*p, \\*\\*kw)"
msgstr ""

#: ../../peps/pep-0367.rst:539
msgid ""
"There has been the proposal that directly calling ``super(*p, **kw)`` "
"would be equivalent to calling the method on the ``super`` object with "
"the same name as the method currently being executed i.e. the following "
"two methods would be equivalent:"
msgstr ""

#: ../../peps/pep-0367.rst:554
msgid ""
"There is strong sentiment for and against this, but implementation and "
"style concerns are obvious. Guido has suggested that this should be "
"excluded from this PEP on the principle of KISS (Keep It Simple Stupid)."
msgstr ""

#: ../../peps/pep-0367.rst:561
msgid "History"
msgstr ""

#: ../../peps/pep-0367.rst:565
msgid "29-Apr-2007 - Changed title from \"Super As A Keyword\" to \"New Super\""
msgstr ""

#: ../../peps/pep-0367.rst:563
msgid ""
"Updated much of the language and added a terminology section for "
"clarification in confusing places."
msgstr ""

#: ../../peps/pep-0367.rst:565
msgid "Added reference implementation and history sections."
msgstr ""

#: ../../peps/pep-0367.rst:568
msgid ""
"06-May-2007 - Updated by Tim Delaney to reflect discussions on the "
"python-3000"
msgstr ""

#: ../../peps/pep-0367.rst:568
msgid "and python-dev mailing lists."
msgstr ""

#: ../../peps/pep-0367.rst:571
msgid "References"
msgstr "Referências"

#: ../../peps/pep-0367.rst:573
msgid ""
"Fixing super anyone? "
"(https://mail.python.org/pipermail/python-3000/2007-April/006667.html)"
msgstr ""

#: ../../peps/pep-0367.rst:576
msgid ""
"PEP 3130: Access to Module/Class/Function Currently Being Defined (this) "
"(https://mail.python.org/pipermail/python-ideas/2007-April/000542.html)"
msgstr ""

#: ../../peps/pep-0367.rst:581
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-0367.rst:583
msgid "This document has been placed in the public domain."
msgstr "Este documento foi colocado em domínio público."

#~ msgid ""
#~ "With this proposal, ``super`` would "
#~ "become a keyword to the same "
#~ "extent that ``None`` is a keyword. "
#~ "It is possible that further restricting"
#~ " the ``super`` name may simplify "
#~ "implementation, however some are against "
#~ "the actual keyword- ization of super."
#~ " The simplest solution is often the"
#~ " correct solution and the simplest "
#~ "solution may well not be adding "
#~ "additional keywords to the language when"
#~ " they are not needed. Still, it "
#~ "may solve other open issues."
#~ msgstr ""

#~ msgid ""
#~ "This solution only solves the problem"
#~ " of the type indication, does not "
#~ "handle differently named super methods, "
#~ "and is explicit about the name of"
#~ " the instance. It is less flexible"
#~ " without being able to enacted on "
#~ "other method names, in cases where "
#~ "that is needed. One use case this"
#~ " fails is where a base- class "
#~ "has a factory classmethod and a "
#~ "subclass has two factory classmethods, "
#~ "both of which needing to properly "
#~ "make super calls to the one in "
#~ "the base- class."
#~ msgstr ""

