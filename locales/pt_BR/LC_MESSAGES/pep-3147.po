# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-3147.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-3147.rst:3
msgid "Barry Warsaw <barry@python.org>"
msgstr ""

#: ../../peps/pep-3147.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-3147.rst:4
msgid "Final"
msgstr ""

#: ../../peps/pep-3147.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-3147.rst:5
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-3147.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-3147.rst:7
msgid "16-Dec-2009"
msgstr ""

#: ../../peps/pep-3147.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-3147.rst:8
msgid "3.2"
msgstr ""

#: ../../peps/pep-3147.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-3147.rst:9
msgid "30-Jan-2010, 25-Feb-2010, 03-Mar-2010, 12-Apr-2010"
msgstr ""

#: ../../peps/pep-3147.rst
msgid "Resolution"
msgstr ""

#: ../../peps/pep-3147.rst:10
msgid "https://mail.python.org/pipermail/python-dev/2010-April/099414.html"
msgstr ""

#: ../../peps/pep-3147.rst:14
msgid "Abstract"
msgstr ""

#: ../../peps/pep-3147.rst:16
msgid ""
"This PEP describes an extension to Python's import mechanism which "
"improves sharing of Python source code files among multiple installed "
"different versions of the Python interpreter.  It does this by allowing "
"more than one byte compilation file (.pyc files) to be co-located with "
"the Python source file (.py file).  The extension described here can also"
" be used to support different Python compilation caches, such as JIT "
"output that may be produced by an Unladen Swallow (:pep:`3146`) enabled C"
" Python."
msgstr ""

#: ../../peps/pep-3147.rst:27
msgid "Background"
msgstr ""

#: ../../peps/pep-3147.rst:29
msgid ""
"CPython compiles its source code into \"byte code\", and for performance "
"reasons, it caches this byte code on the file system whenever the source "
"file has changes.  This makes loading of Python modules much faster "
"because the compilation phase can be bypassed.  When your source file is "
"``foo.py``, CPython caches the byte code in a ``foo.pyc`` file right next"
" to the source."
msgstr ""

#: ../../peps/pep-3147.rst:36
msgid ""
"Byte code files contain two 32-bit big-endian numbers followed by the "
"marshaled [2]_ code object.  The 32-bit numbers represent a magic number "
"and a timestamp.  The magic number changes whenever Python changes the "
"byte code format, e.g. by adding new byte codes to its virtual machine.  "
"This ensures that pyc files built for previous versions of the VM won't "
"cause problems.  The timestamp is used to make sure that the pyc file "
"match the py file that was used to create it.  When either the magic "
"number or timestamp do not match, the py file is recompiled and a new pyc"
" file is written."
msgstr ""

#: ../../peps/pep-3147.rst:46
msgid ""
"In practice, it is well known that pyc files are not compatible across "
"Python major releases.  A reading of import.c [3]_ in the Python source "
"code proves that within recent memory, every new CPython major release "
"has bumped the pyc magic number."
msgstr ""

#: ../../peps/pep-3147.rst:53
msgid "Rationale"
msgstr ""

#: ../../peps/pep-3147.rst:55
msgid ""
"Linux distributions such as Ubuntu [4]_ and Debian [5]_ provide more than"
" one Python version at the same time to their users.  For example, Ubuntu"
" 9.10 Karmic Koala users can install Python 2.5, 2.6, and 3.1, with "
"Python 2.6 being the default."
msgstr ""

#: ../../peps/pep-3147.rst:60
msgid ""
"This causes a conflict for third party Python source files installed by "
"the system, because you cannot compile a single Python source file for "
"more than one Python version at a time.  When Python finds a ``pyc`` file"
" with a non-matching magic number, it falls back to the slower process of"
" recompiling the source.  Thus if your system installed a "
"``/usr/share/python/foo.py``, two different versions of Python would "
"fight over the ``pyc`` file and rewrite it each time the source is "
"compiled.  (The standard library is unaffected by this, since multiple "
"versions of the stdlib *are* installed on such distributions..)"
msgstr ""

#: ../../peps/pep-3147.rst:70
msgid ""
"Furthermore, in order to ease the burden on operating system packagers "
"for these distributions, the distribution packages do not contain Python "
"version numbers [6]_; they are shared across all Python versions "
"installed on the system.  Putting Python version numbers in the packages "
"would be a maintenance nightmare, since all the packages - *and their "
"dependencies* - would have to be updated every time a new Python release "
"was added or removed from the distribution.  Because of the sheer number "
"of packages available, this amount of work is infeasible."
msgstr ""

#: ../../peps/pep-3147.rst:80
msgid ""
"(:pep:`384` has been proposed to address binary compatibility issues of "
"third party extension modules across different versions of Python.)"
msgstr ""

#: ../../peps/pep-3147.rst:83
msgid ""
"Because these distributions cannot share pyc files, elaborate mechanisms "
"have been developed to put the resulting pyc files in non-shared "
"locations while the source code is still shared.  Examples include the "
"symlink-based Debian regimes python-support [8]_ and python-central [9]_."
"  These approaches make for much more complicated, fragile, inscrutable, "
"and fragmented policies for delivering Python applications to a wide "
"range of users.  Arguably more users get Python from their operating "
"system vendor than from upstream tarballs.  Thus, solving this pyc "
"sharing problem for CPython is a high priority for such vendors."
msgstr ""

#: ../../peps/pep-3147.rst:94
msgid "This PEP proposes a solution to this problem."
msgstr ""

#: ../../peps/pep-3147.rst:98
msgid "Proposal"
msgstr ""

#: ../../peps/pep-3147.rst:100
msgid ""
"Python's import machinery is extended to write and search for byte code "
"cache files in a single directory inside every Python package directory."
"  This directory will be called ``__pycache__``."
msgstr ""

#: ../../peps/pep-3147.rst:104
msgid ""
"Further, pyc file names will contain a magic string (called a \"tag\") "
"that differentiates the Python version they were compiled for.  This "
"allows multiple byte compiled cache files to co-exist for a single Python"
" source file."
msgstr ""

#: ../../peps/pep-3147.rst:109
msgid ""
"The magic tag is implementation defined, but should contain the "
"implementation name and a version number shorthand, e.g. ``cpython-32``. "
"It must be unique among all versions of Python, and whenever the magic "
"number is bumped, a new magic tag must be defined.  An example ``pyc`` "
"file for Python 3.2 is thus ``foo.cpython-32.pyc``."
msgstr ""

#: ../../peps/pep-3147.rst:115
msgid ""
"The magic tag is available in the ``imp`` module via the ``get_tag()`` "
"function.  This is parallel to the ``imp.get_magic()`` function."
msgstr ""

#: ../../peps/pep-3147.rst:118
msgid ""
"This scheme has the added benefit of reducing the clutter in a Python "
"package directory."
msgstr ""

#: ../../peps/pep-3147.rst:121
msgid ""
"When a Python source file is imported for the first time, a "
"``__pycache__`` directory will be created in the package directory, if "
"one does not already exist.  The pyc file for the imported source will be"
" written to the ``__pycache__`` directory, using the magic-tag formatted "
"name.  If either the creation of the ``__pycache__`` directory or the pyc"
" file inside that fails, the import will still succeed, just as it does "
"in a pre-:pep:`3147` world."
msgstr ""

#: ../../peps/pep-3147.rst:129
msgid ""
"If the py source file is missing, the pyc file inside ``__pycache__`` "
"will be ignored.  This eliminates the problem of accidental stale pyc "
"file imports."
msgstr ""

#: ../../peps/pep-3147.rst:133
msgid ""
"For backward compatibility, Python will still support pyc-only "
"distributions, however it will only do so when the pyc file lives in the "
"directory where the py file *would* have been, i.e. not in the "
"``__pycache__`` directory.  pyc file outside of ``__pycache__`` will only"
" be imported if the py source file is missing."
msgstr ""

#: ../../peps/pep-3147.rst:139
msgid ""
"Tools such as ``py_compile`` [15]_ and ``compileall`` [16]_ will be "
"extended to create :pep:`3147` formatted layouts automatically, but will "
"have an option to create pyc-only distribution layouts."
msgstr ""

#: ../../peps/pep-3147.rst:145
msgid "Examples"
msgstr ""

#: ../../peps/pep-3147.rst:147
msgid "What would this look like in practice?"
msgstr ""

#: ../../peps/pep-3147.rst:149
msgid ""
"Let's say we have a Python package named ``alpha`` which contains a sub-"
"package name ``beta``.  The source directory layout before byte "
"compilation might look like this::"
msgstr ""

#: ../../peps/pep-3147.rst:162
msgid ""
"After byte compiling this package with Python 3.2, you would see the "
"following layout::"
msgstr ""

#: ../../peps/pep-3147.rst:182
msgid "*Note: listing order may differ depending on the platform.*"
msgstr ""

#: ../../peps/pep-3147.rst:184
msgid ""
"Let's say that two new versions of Python are installed, one is Python "
"3.3 and another is Unladen Swallow.  After byte compilation, the file "
"system would look like this::"
msgstr ""

#: ../../peps/pep-3147.rst:217
msgid ""
"As you can see, as long as the Python version identifier string is "
"unique, any number of pyc files can co-exist.  These identifier strings "
"are described in more detail below."
msgstr ""

#: ../../peps/pep-3147.rst:221
msgid ""
"A nice property of this layout is that the ``__pycache__`` directories "
"can generally be ignored, such that a normal directory listing would show"
" something like this::"
msgstr ""

#: ../../peps/pep-3147.rst:236
msgid "This is much less cluttered than even today's Python."
msgstr ""

#: ../../peps/pep-3147.rst:240
msgid "Python behavior"
msgstr ""

#: ../../peps/pep-3147.rst:242
msgid ""
"When Python searches for a module to import (say ``foo``), it may find "
"one of several situations.  As per current Python rules, the term "
"\"matching pyc\" means that the magic number matches the current "
"interpreter's magic number, and the source file's timestamp matches the "
"timestamp in the ``pyc`` file exactly."
msgstr ""

#: ../../peps/pep-3147.rst:250
msgid "Case 0: The steady state"
msgstr ""

#: ../../peps/pep-3147.rst:252
msgid ""
"When Python is asked to import module ``foo``, it searches for a "
"``foo.py`` file (or ``foo`` package, but that's not important for this "
"discussion) along its ``sys.path``.  If found, Python looks to see if "
"there is a matching ``__pycache__/foo.<magic>.pyc`` file, and if so, that"
" ``pyc`` file is loaded."
msgstr ""

#: ../../peps/pep-3147.rst:260
msgid "Case 1: The first import"
msgstr ""

#: ../../peps/pep-3147.rst:262
msgid ""
"When Python locates the ``foo.py``, if the "
"``__pycache__/foo.<magic>.pyc`` file is missing, Python will create it, "
"also creating the ``__pycache__`` directory if necessary.  Python will "
"parse and byte compile the ``foo.py`` file and save the byte code in "
"``__pycache__/foo.<magic>.pyc``."
msgstr ""

#: ../../peps/pep-3147.rst:270
msgid "Case 2: The second import"
msgstr ""

#: ../../peps/pep-3147.rst:272
msgid ""
"When Python is asked to import module ``foo`` a second time (in a "
"different process of course), it will again search for the ``foo.py`` "
"file along its ``sys.path``.  When Python locates the ``foo.py`` file, it"
" looks for a matching ``__pycache__/foo.<magic>.pyc`` and finding this, "
"it reads the byte code and continues as usual."
msgstr ""

#: ../../peps/pep-3147.rst:280
msgid "Case 3: __pycache__/foo.<magic>.pyc with no source"
msgstr ""

#: ../../peps/pep-3147.rst:282
msgid ""
"It's possible that the ``foo.py`` file somehow got removed, while leaving"
" the cached pyc file still on the file system.  If the "
"``__pycache__/foo.<magic>.pyc`` file exists, but the ``foo.py`` file used"
" to create it does not, Python will raise an ``ImportError`` when asked "
"to import foo.  In other words, Python will not import a pyc file from "
"the cache directory unless the source file exists."
msgstr ""

#: ../../peps/pep-3147.rst:291
msgid "Case 4: legacy pyc files and source-less imports"
msgstr ""

#: ../../peps/pep-3147.rst:293
msgid ""
"Python will ignore all legacy pyc files when a source file exists next to"
" it.  In other words, if a ``foo.pyc`` file exists next to the ``foo.py``"
" file, the pyc file will be ignored in all cases"
msgstr ""

#: ../../peps/pep-3147.rst:297
msgid ""
"In order to continue to support source-less distributions though, if the "
"source file is missing, Python will import a lone pyc file if it lives "
"where the source file would have been."
msgstr ""

#: ../../peps/pep-3147.rst:303
msgid "Case 5: read-only file systems"
msgstr ""

#: ../../peps/pep-3147.rst:305
msgid ""
"When the source lives on a read-only file system, or the ``__pycache__`` "
"directory or pyc file cannot otherwise be written, all the same rules "
"apply.  This is also the case when ``__pycache__`` happens to be written "
"with permissions which do not allow for writing containing pyc files."
msgstr ""

#: ../../peps/pep-3147.rst:313
msgid "Flow chart"
msgstr ""

#: ../../peps/pep-3147.rst:315
msgid "Here is a flow chart describing how modules are loaded:"
msgstr ""

#: ../../peps/pep-3147.rst:323
msgid "Alternative Python implementations"
msgstr ""

#: ../../peps/pep-3147.rst:325
msgid ""
"Alternative Python implementations such as Jython [11]_, IronPython "
"[12]_, PyPy [13]_, Pynie [14]_, and Unladen Swallow can also use the "
"``__pycache__`` directory to store whatever compilation artifacts make "
"sense for their platforms.  For example, Jython could store the class "
"file for the module in ``__pycache__/foo.jython-32.class``."
msgstr ""

#: ../../peps/pep-3147.rst:333
msgid "Implementation strategy"
msgstr ""

#: ../../peps/pep-3147.rst:335
msgid ""
"This feature is targeted for Python 3.2, solving the problem for those "
"and all future versions.  It may be back-ported to Python 2.7. Vendors "
"are free to backport the changes to earlier distributions as they see "
"fit.  For backports of this feature to Python 2, when the ``-U`` flag is "
"used, a file such as ``foo.cpython-27u.pyc`` can be written."
msgstr ""

#: ../../peps/pep-3147.rst:344
msgid "Effects on existing code"
msgstr ""

#: ../../peps/pep-3147.rst:346
msgid ""
"Adoption of this PEP will affect existing code and idioms, both inside "
"Python and outside.  This section enumerates some of these effects."
msgstr ""

#: ../../peps/pep-3147.rst:351
msgid "Detecting PEP 3147 availability"
msgstr ""

#: ../../peps/pep-3147.rst:353
msgid ""
"The easiest way to detect whether your version of Python provides PEP "
"3147 functionality is to do the following check::"
msgstr ""

#: ../../peps/pep-3147.rst:361
msgid "__file__"
msgstr ""

#: ../../peps/pep-3147.rst:363
msgid ""
"In Python 3, when you import a module, its ``__file__`` attribute points "
"to its source ``py`` file (in Python 2, it points to the ``pyc`` file).  "
"A package's ``__file__`` points to the ``py`` file for its "
"``__init__.py``. E.g.::"
msgstr ""

#: ../../peps/pep-3147.rst:376
msgid "Nothing in this PEP would change the semantics of ``__file__``."
msgstr ""

#: ../../peps/pep-3147.rst:378
msgid ""
"This PEP proposes the addition of an ``__cached__`` attribute to modules,"
" which will always point to the actual ``pyc`` file that was read or "
"written.  When the environment variable ``$PYTHONDONTWRITEBYTECODE`` is "
"set, or the ``-B`` option is given, or if the source lives on a read-only"
" filesystem, then the ``__cached__`` attribute will point to the location"
" that the ``pyc`` file *would* have been written to if it didn't exist.  "
"This location of course includes the ``__pycache__`` subdirectory in its "
"path."
msgstr ""

#: ../../peps/pep-3147.rst:387
msgid ""
"For alternative Python implementations which do not support ``pyc`` "
"files, the ``__cached__`` attribute may point to whatever information "
"makes sense.  E.g. on Jython, this might be the ``.class`` file for the "
"module: ``__pycache__/foo.jython-32.class``.  Some implementations may "
"use multiple compiled files to create the module, in which case "
"``__cached__`` may be a tuple.  The exact contents of ``__cached__`` are "
"Python implementation specific."
msgstr ""

#: ../../peps/pep-3147.rst:395
msgid ""
"It is recommended that when nothing sensible can be calculated, "
"implementations should set the ``__cached__`` attribute to ``None``."
msgstr ""

#: ../../peps/pep-3147.rst:400
msgid "py_compile and compileall"
msgstr ""

#: ../../peps/pep-3147.rst:402
msgid ""
"Python comes with two modules, ``py_compile`` [15]_ and ``compileall`` "
"[16]_ which support compiling Python modules external to the built-in "
"import machinery.  ``py_compile`` in particular has intimate knowledge of"
" byte compilation, so these will be updated to understand the new layout."
"  The ``-b`` flag is added to ``compileall`` for writing legacy ``.pyc`` "
"byte-compiled file path names."
msgstr ""

#: ../../peps/pep-3147.rst:411
msgid "bdist_wininst and the Windows installer"
msgstr ""

#: ../../peps/pep-3147.rst:413
msgid ""
"These tools also compile modules explicitly on installation.  If they do "
"not use ``py_compile`` and ``compileall``, then they would also have to "
"be modified to understand the new layout."
msgstr ""

#: ../../peps/pep-3147.rst:419
msgid "File extension checks"
msgstr ""

#: ../../peps/pep-3147.rst:421
msgid ""
"There exists some code which checks for files ending in ``.pyc`` and "
"simply chops off the last character to find the matching ``.py`` file. "
"This code will obviously fail once this PEP is implemented."
msgstr ""

#: ../../peps/pep-3147.rst:425
msgid ""
"To support this use case, we'll add two new methods to the ``imp`` "
"package [17]_:"
msgstr ""

#: ../../peps/pep-3147.rst:428
msgid "``imp.cache_from_source(py_path)`` -> ``pyc_path``"
msgstr ""

#: ../../peps/pep-3147.rst:429
msgid "``imp.source_from_cache(pyc_path)`` -> ``py_path``"
msgstr ""

#: ../../peps/pep-3147.rst:431
msgid ""
"Alternative implementations are free to override these functions to "
"return reasonable values based on their own support for this PEP. These "
"methods are allowed to return ``None`` when the implementation (or "
":pep:`302` loader in effect) for whatever reason cannot calculate the "
"appropriate file name.  They should not raise exceptions."
msgstr ""

#: ../../peps/pep-3147.rst:439
msgid "Backports"
msgstr ""

#: ../../peps/pep-3147.rst:441
msgid ""
"For versions of Python earlier than 3.2 (and possibly 2.7), it is "
"possible to backport this PEP.  However, in Python 3.2 (and possibly "
"2.7), this behavior will be turned on by default, and in fact, it will "
"replace the old behavior.  Backports will need to support the old layout "
"by default.  We suggest supporting :pep:`3147` through the use of an "
"environment variable called ``$PYTHONENABLECACHEDIR`` or the command line"
" switch ``-Xenablecachedir`` to enable the feature."
msgstr ""

#: ../../peps/pep-3147.rst:451
msgid "Makefiles and other dependency tools"
msgstr ""

#: ../../peps/pep-3147.rst:453
msgid ""
"Makefiles and other tools which calculate dependencies on ``.pyc`` files "
"(e.g. to byte-compile the source if the ``.pyc`` is missing) will have to"
" be updated to check the new paths."
msgstr ""

#: ../../peps/pep-3147.rst:459
msgid "Alternatives"
msgstr ""

#: ../../peps/pep-3147.rst:461
msgid ""
"This section describes some alternative approaches or details that were "
"considered and rejected during the PEP's development."
msgstr ""

#: ../../peps/pep-3147.rst:466
msgid "Hexadecimal magic tags"
msgstr ""

#: ../../peps/pep-3147.rst:468
msgid ""
"pyc files inside of the ``__pycache__`` directories contain a magic tag "
"in their file names.  These are mnemonic tags for the actual magic "
"numbers used by the importer.  We could have used the hexadecimal "
"representation [10]_ of the binary magic number as a unique identifier.  "
"For example, in Python 3.2::"
msgstr ""

#: ../../peps/pep-3147.rst:479
msgid ""
"This isn't particularly human friendly though, thus the magic tag "
"proposed in this PEP."
msgstr ""

#: ../../peps/pep-3147.rst:484
msgid "PEP 304"
msgstr ""

#: ../../peps/pep-3147.rst:486
msgid ""
"There is some overlap between the goals of this PEP and :pep:`304`, which"
" has been withdrawn.  However :pep:`304` would allow a user to create a "
"shadow file system hierarchy in which to store ``pyc`` files. This "
"concept of a shadow hierarchy for ``pyc`` files could be used to satisfy "
"the aims of this PEP.  Although the :pep:`304` does not indicate why it "
"was withdrawn, shadow directories have a number of problems. The location"
" of the shadow ``pyc`` files would not be easily discovered and would "
"depend on the proper and consistent use of the ``$PYTHONBYTECODE`` "
"environment variable both by the system and by end users.  There are also"
" global implications, meaning that while the system might want to shadow "
"``pyc`` files, users might not want to, but the PEP defines only an all-"
"or-nothing approach."
msgstr ""

#: ../../peps/pep-3147.rst:499
msgid ""
"As an example of the problem, a common (though fragile) Python idiom for "
"locating data files is to do something like this::"
msgstr ""

#: ../../peps/pep-3147.rst:506
msgid ""
"This would be problematic since ``foo.bar.__file__`` will give the "
"location of the ``pyc`` file in the shadow directory, and it may not be "
"possible to find the ``my.dat`` file relative to the source directory "
"from there."
msgstr ""

#: ../../peps/pep-3147.rst:513
msgid "Fat byte compilation files"
msgstr ""

#: ../../peps/pep-3147.rst:515
msgid ""
"An earlier version of this PEP described \"fat\" Python byte code files. "
"These files would contain the equivalent of multiple ``pyc`` files in a "
"single ``pyf`` file, with a lookup table keyed off the appropriate magic "
"number.  This was an extensible file format so that the first 5 parallel "
"Python implementations could be supported fairly efficiently, but with "
"extension lookup tables available to scale ``pyf`` byte code objects as "
"large as necessary."
msgstr ""

#: ../../peps/pep-3147.rst:523
msgid ""
"The fat byte compilation files were fairly complex, and inherently "
"introduced difficult race conditions, so the current simplification of "
"using directories was suggested.  The same problem applies to using zip "
"files as the fat pyc file format."
msgstr ""

#: ../../peps/pep-3147.rst:530
msgid "Multiple file extensions"
msgstr ""

#: ../../peps/pep-3147.rst:532
msgid ""
"The PEP author also considered an approach where multiple thin byte "
"compiled files lived in the same place, but used different file "
"extensions to designate the Python version.  E.g. foo.pyc25, foo.pyc26, "
"foo.pyc31 etc.  This was rejected because of the clutter involved in "
"writing so many different files.  The multiple extension approach makes "
"it more difficult (and an ongoing task) to update any tools that are "
"dependent on the file extension."
msgstr ""

#: ../../peps/pep-3147.rst:542
msgid ".pyc"
msgstr ""

#: ../../peps/pep-3147.rst:544
msgid ""
"A proposal was floated to call the ``__pycache__`` directory ``.pyc`` or "
"some other dot-file name.  This would have the effect on \\*nix systems "
"of hiding the directory.  There are many reasons why this was rejected by"
" the BDFL [20]_ including the fact that dot-files are only special on "
"some platforms, and we actually do *not* want to hide these completely "
"from users."
msgstr ""

#: ../../peps/pep-3147.rst:553
msgid "Reference implementation"
msgstr ""

#: ../../peps/pep-3147.rst:555
msgid ""
"Work on this code is tracked in a Bazaar branch on Launchpad [22]_ until "
"it's ready for merge into Python 3.2.  The work-in-progress diff can also"
" be viewed [23]_ and is updated automatically as new changes are "
"uploaded."
msgstr ""

#: ../../peps/pep-3147.rst:560
msgid ""
"A Rietveld code review issue [24]_ has been opened as of 2010-04-01 (no, "
"this is not an April Fools joke :)."
msgstr ""

#: ../../peps/pep-3147.rst:565
msgid "References"
msgstr "Referências"

#: ../../peps/pep-3147.rst:567
msgid "The marshal module: https://docs.python.org/3.1/library/marshal.html"
msgstr ""

#: ../../peps/pep-3147.rst:570
msgid "import.c: https://github.com/python/cpython/blob/v3.2a1/Python/import.c"
msgstr ""

#: ../../peps/pep-3147.rst:573
msgid "Ubuntu: https://www.ubuntu.com"
msgstr ""

#: ../../peps/pep-3147.rst:575
msgid "Debian: https://www.debian.org"
msgstr ""

#: ../../peps/pep-3147.rst:577
msgid ""
"Debian Python Policy: https://www.debian.org/doc/packaging-manuals"
"/python-policy/"
msgstr ""

#: ../../peps/pep-3147.rst:580
msgid ""
"python-support: "
"https://web.archive.org/web/20100110123824/http://wiki.debian.org/DebianPythonFAQ"
"#Whatispython-support.3F"
msgstr ""

#: ../../peps/pep-3147.rst:583
msgid ""
"python-central: "
"https://web.archive.org/web/20100110123824/http://wiki.debian.org/DebianPythonFAQ"
"#Whatispython-central.3F"
msgstr ""

#: ../../peps/pep-3147.rst:586
msgid ""
"binascii.hexlify(): "
"https://docs.python.org/3.1/library/binascii.html#binascii.hexlify"
msgstr ""

#: ../../peps/pep-3147.rst:589
msgid "Jython: http://www.jython.org/"
msgstr ""

#: ../../peps/pep-3147.rst:591
msgid "IronPython: http://ironpython.net/"
msgstr ""

#: ../../peps/pep-3147.rst:593
msgid ""
"PyPy: "
"https://web.archive.org/web/20100310130136/http://codespeak.net/pypy/dist/pypy/doc/"
msgstr ""

#: ../../peps/pep-3147.rst:595
msgid "Pynie: https://code.google.com/archive/p/pynie/"
msgstr ""

#: ../../peps/pep-3147.rst:597
msgid "py_compile: https://docs.python.org/3.1/library/py_compile.html"
msgstr ""

#: ../../peps/pep-3147.rst:599
msgid "compileall: https://docs.python.org/3.1/library/compileall.html"
msgstr ""

#: ../../peps/pep-3147.rst:601
msgid "imp: https://docs.python.org/3.1/library/imp.html"
msgstr ""

#: ../../peps/pep-3147.rst:603
msgid "https://www.mail-archive.com/python-dev@python.org/msg45203.html"
msgstr ""

#: ../../peps/pep-3147.rst:605
msgid "[21] importlib: https://docs.python.org/3.1/library/importlib.html"
msgstr ""

#: ../../peps/pep-3147.rst:607
msgid "https://code.launchpad.net/~barry/python/pep3147"
msgstr ""

#: ../../peps/pep-3147.rst:609
msgid "https://code.launchpad.net/~barry/python/pep3147/+merge/22648"
msgstr ""

#: ../../peps/pep-3147.rst:611
msgid "http://codereview.appspot.com/842043/show"
msgstr ""

#: ../../peps/pep-3147.rst:615
msgid "ACKNOWLEDGMENTS"
msgstr ""

#: ../../peps/pep-3147.rst:617
msgid ""
"Barry Warsaw's original idea was for fat Python byte code files. Martin "
"von Loewis reviewed an early draft of the PEP and suggested the "
"simplification to store traditional ``pyc`` and ``pyo`` files in a "
"directory.  Many other people reviewed early versions of this PEP and "
"provided useful feedback including but not limited to:"
msgstr ""

#: ../../peps/pep-3147.rst:623
msgid "David Malcolm"
msgstr ""

#: ../../peps/pep-3147.rst:624
msgid "Josselin Mouette"
msgstr ""

#: ../../peps/pep-3147.rst:625
msgid "Matthias Klose"
msgstr ""

#: ../../peps/pep-3147.rst:626
msgid "Michael Hudson"
msgstr ""

#: ../../peps/pep-3147.rst:627
msgid "Michael Vogt"
msgstr ""

#: ../../peps/pep-3147.rst:628
msgid "Piotr Ożarowski"
msgstr ""

#: ../../peps/pep-3147.rst:629
msgid "Scott Kitterman"
msgstr ""

#: ../../peps/pep-3147.rst:630
msgid "Toshio Kuratomi"
msgstr ""

#: ../../peps/pep-3147.rst:634
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-3147.rst:636
msgid "This document has been placed in the public domain."
msgstr "Este documento foi colocado em domínio público."

#~ msgid ""
#~ "CPython compiles its source code into"
#~ " \"byte code\", and for performance "
#~ "reasons, it caches this byte code "
#~ "on the file system whenever the "
#~ "source file has changes.  This makes "
#~ "loading of Python modules much faster"
#~ " because the compilation phase can be"
#~ " bypassed.  When your source file is"
#~ " `foo.py`, CPython caches the byte "
#~ "code in a `foo.pyc` file right "
#~ "next to the source."
#~ msgstr ""

#~ msgid ""
#~ "This causes a conflict for third "
#~ "party Python source files installed by"
#~ " the system, because you cannot "
#~ "compile a single Python source file "
#~ "for more than one Python version "
#~ "at a time.  When Python finds a"
#~ " `pyc` file with a non-matching "
#~ "magic number, it falls back to the"
#~ " slower process of recompiling the "
#~ "source.  Thus if your system installed"
#~ " a `/usr/share/python/foo.py`, two different "
#~ "versions of Python would fight over "
#~ "the `pyc` file and rewrite it each"
#~ " time the source is compiled.  (The"
#~ " standard library is unaffected by "
#~ "this, since multiple versions of the "
#~ "stdlib *are* installed on such "
#~ "distributions..)"
#~ msgstr ""

#~ msgid ""
#~ "Python's import machinery is extended to"
#~ " write and search for byte code "
#~ "cache files in a single directory "
#~ "inside every Python package directory.  "
#~ "This directory will be called "
#~ "`__pycache__`."
#~ msgstr ""

#~ msgid ""
#~ "The magic tag is implementation defined,"
#~ " but should contain the implementation "
#~ "name and a version number shorthand, "
#~ "e.g. `cpython-32`. It must be unique "
#~ "among all versions of Python, and "
#~ "whenever the magic number is bumped, "
#~ "a new magic tag must be defined."
#~ "  An example `pyc` file for Python"
#~ " 3.2 is thus `foo.cpython-32.pyc`."
#~ msgstr ""

#~ msgid ""
#~ "The magic tag is available in the"
#~ " `imp` module via the `get_tag()` "
#~ "function.  This is parallel to the "
#~ "`imp.get_magic()` function."
#~ msgstr ""

#~ msgid ""
#~ "When a Python source file is "
#~ "imported for the first time, a "
#~ "`__pycache__` directory will be created "
#~ "in the package directory, if one "
#~ "does not already exist.  The pyc "
#~ "file for the imported source will "
#~ "be written to the `__pycache__` "
#~ "directory, using the magic-tag formatted"
#~ " name.  If either the creation of "
#~ "the `__pycache__` directory or the pyc"
#~ " file inside that fails, the import"
#~ " will still succeed, just as it "
#~ "does in a pre-:pep:`3147` world."
#~ msgstr ""

#~ msgid ""
#~ "If the py source file is missing,"
#~ " the pyc file inside `__pycache__` "
#~ "will be ignored.  This eliminates the"
#~ " problem of accidental stale pyc file"
#~ " imports."
#~ msgstr ""

#~ msgid ""
#~ "For backward compatibility, Python will "
#~ "still support pyc-only distributions, "
#~ "however it will only do so when"
#~ " the pyc file lives in the "
#~ "directory where the py file *would* "
#~ "have been, i.e. not in the "
#~ "`__pycache__` directory.  pyc file outside "
#~ "of `__pycache__` will only be imported"
#~ " if the py source file is "
#~ "missing."
#~ msgstr ""

#~ msgid ""
#~ "Tools such as `py_compile` [15]_ and "
#~ "`compileall` [16]_ will be extended to"
#~ " create :pep:`3147` formatted layouts "
#~ "automatically, but will have an option"
#~ " to create pyc-only distribution "
#~ "layouts."
#~ msgstr ""

#~ msgid ""
#~ "Let's say we have a Python package"
#~ " named `alpha` which contains a "
#~ "sub-package name `beta`.  The source "
#~ "directory layout before byte compilation "
#~ "might look like this::"
#~ msgstr ""

#~ msgid ""
#~ "A nice property of this layout is"
#~ " that the `__pycache__` directories can "
#~ "generally be ignored, such that a "
#~ "normal directory listing would show "
#~ "something like this::"
#~ msgstr ""

#~ msgid ""
#~ "When Python searches for a module "
#~ "to import (say `foo`), it may find"
#~ " one of several situations.  As per"
#~ " current Python rules, the term "
#~ "\"matching pyc\" means that the magic"
#~ " number matches the current interpreter's"
#~ " magic number, and the source file's"
#~ " timestamp matches the timestamp in "
#~ "the `pyc` file exactly."
#~ msgstr ""

#~ msgid ""
#~ "When Python is asked to import "
#~ "module `foo`, it searches for a "
#~ "`foo.py` file (or `foo` package, but "
#~ "that's not important for this "
#~ "discussion) along its `sys.path`.  If "
#~ "found, Python looks to see if "
#~ "there is a matching "
#~ "`__pycache__/foo.<magic>.pyc` file, and if so,"
#~ " that `pyc` file is loaded."
#~ msgstr ""

#~ msgid ""
#~ "When Python locates the `foo.py`, if "
#~ "the `__pycache__/foo.<magic>.pyc` file is "
#~ "missing, Python will create it, also "
#~ "creating the `__pycache__` directory if "
#~ "necessary.  Python will parse and byte"
#~ " compile the `foo.py` file and save"
#~ " the byte code in "
#~ "`__pycache__/foo.<magic>.pyc`."
#~ msgstr ""

#~ msgid ""
#~ "When Python is asked to import "
#~ "module `foo` a second time (in a"
#~ " different process of course), it "
#~ "will again search for the `foo.py` "
#~ "file along its `sys.path`.  When Python"
#~ " locates the `foo.py` file, it looks"
#~ " for a matching `__pycache__/foo.<magic>.pyc` "
#~ "and finding this, it reads the "
#~ "byte code and continues as usual."
#~ msgstr ""

#~ msgid ""
#~ "It's possible that the `foo.py` file "
#~ "somehow got removed, while leaving the"
#~ " cached pyc file still on the "
#~ "file system.  If the "
#~ "`__pycache__/foo.<magic>.pyc` file exists, but "
#~ "the `foo.py` file used to create "
#~ "it does not, Python will raise an"
#~ " `ImportError` when asked to import "
#~ "foo.  In other words, Python will "
#~ "not import a pyc file from the "
#~ "cache directory unless the source file"
#~ " exists."
#~ msgstr ""

#~ msgid ""
#~ "Python will ignore all legacy pyc "
#~ "files when a source file exists "
#~ "next to it.  In other words, if"
#~ " a `foo.pyc` file exists next to "
#~ "the `foo.py` file, the pyc file "
#~ "will be ignored in all cases"
#~ msgstr ""

#~ msgid ""
#~ "When the source lives on a "
#~ "read-only file system, or the "
#~ "`__pycache__` directory or pyc file "
#~ "cannot otherwise be written, all the "
#~ "same rules apply.  This is also "
#~ "the case when `__pycache__` happens to"
#~ " be written with permissions which do"
#~ " not allow for writing containing pyc"
#~ " files."
#~ msgstr ""

#~ msgid ""
#~ "Alternative Python implementations such as "
#~ "Jython [11]_, IronPython [12]_, PyPy "
#~ "[13]_, Pynie [14]_, and Unladen Swallow"
#~ " can also use the `__pycache__` "
#~ "directory to store whatever compilation "
#~ "artifacts make sense for their "
#~ "platforms.  For example, Jython could "
#~ "store the class file for the "
#~ "module in `__pycache__/foo.jython-32.class`."
#~ msgstr ""

#~ msgid ""
#~ "This feature is targeted for Python "
#~ "3.2, solving the problem for those "
#~ "and all future versions.  It may "
#~ "be back-ported to Python 2.7. "
#~ "Vendors are free to backport the "
#~ "changes to earlier distributions as they"
#~ " see fit.  For backports of this "
#~ "feature to Python 2, when the `-U`"
#~ " flag is used, a file such as"
#~ " `foo.cpython-27u.pyc` can be written."
#~ msgstr ""

#~ msgid ""
#~ "In Python 3, when you import a "
#~ "module, its `__file__` attribute points "
#~ "to its source `py` file (in Python"
#~ " 2, it points to the `pyc` "
#~ "file).  A package's `__file__` points to"
#~ " the `py` file for its `__init__.py`."
#~ " E.g.::"
#~ msgstr ""

#~ msgid "Nothing in this PEP would change the semantics of `__file__`."
#~ msgstr ""

#~ msgid ""
#~ "This PEP proposes the addition of "
#~ "an `__cached__` attribute to modules, "
#~ "which will always point to the "
#~ "actual `pyc` file that was read or"
#~ " written.  When the environment variable"
#~ " `$PYTHONDONTWRITEBYTECODE` is set, or the"
#~ " `-B` option is given, or if "
#~ "the source lives on a read-only"
#~ " filesystem, then the `__cached__` "
#~ "attribute will point to the location "
#~ "that the `pyc` file *would* have "
#~ "been written to if it didn't "
#~ "exist.  This location of course includes"
#~ " the `__pycache__` subdirectory in its "
#~ "path."
#~ msgstr ""

#~ msgid ""
#~ "For alternative Python implementations which"
#~ " do not support `pyc` files, the "
#~ "`__cached__` attribute may point to "
#~ "whatever information makes sense.  E.g. "
#~ "on Jython, this might be the "
#~ "`.class` file for the module: "
#~ "`__pycache__/foo.jython-32.class`.  Some implementations"
#~ " may use multiple compiled files to"
#~ " create the module, in which case "
#~ "`__cached__` may be a tuple.  The "
#~ "exact contents of `__cached__` are "
#~ "Python implementation specific."
#~ msgstr ""

#~ msgid ""
#~ "It is recommended that when nothing "
#~ "sensible can be calculated, implementations"
#~ " should set the `__cached__` attribute "
#~ "to `None`."
#~ msgstr ""

#~ msgid ""
#~ "Python comes with two modules, "
#~ "`py_compile` [15]_ and `compileall` [16]_ "
#~ "which support compiling Python modules "
#~ "external to the built-in import "
#~ "machinery.  `py_compile` in particular has "
#~ "intimate knowledge of byte compilation, "
#~ "so these will be updated to "
#~ "understand the new layout.  The `-b` "
#~ "flag is added to `compileall` for "
#~ "writing legacy `.pyc` byte-compiled file"
#~ " path names."
#~ msgstr ""

#~ msgid ""
#~ "These tools also compile modules "
#~ "explicitly on installation.  If they do"
#~ " not use `py_compile` and `compileall`, "
#~ "then they would also have to be"
#~ " modified to understand the new "
#~ "layout."
#~ msgstr ""

#~ msgid ""
#~ "There exists some code which checks "
#~ "for files ending in `.pyc` and "
#~ "simply chops off the last character "
#~ "to find the matching `.py` file. "
#~ "This code will obviously fail once "
#~ "this PEP is implemented."
#~ msgstr ""

#~ msgid ""
#~ "To support this use case, we'll "
#~ "add two new methods to the `imp`"
#~ " package [17]_:"
#~ msgstr ""

#~ msgid "`imp.cache_from_source(py_path)` -> `pyc_path`"
#~ msgstr ""

#~ msgid "`imp.source_from_cache(pyc_path)` -> `py_path`"
#~ msgstr ""

#~ msgid ""
#~ "Alternative implementations are free to "
#~ "override these functions to return "
#~ "reasonable values based on their own "
#~ "support for this PEP. These methods "
#~ "are allowed to return `None` when "
#~ "the implementation (or :pep:`302` loader "
#~ "in effect) for whatever reason cannot"
#~ " calculate the appropriate file name.  "
#~ "They should not raise exceptions."
#~ msgstr ""

#~ msgid ""
#~ "For versions of Python earlier than "
#~ "3.2 (and possibly 2.7), it is "
#~ "possible to backport this PEP.  However,"
#~ " in Python 3.2 (and possibly 2.7),"
#~ " this behavior will be turned on "
#~ "by default, and in fact, it will"
#~ " replace the old behavior.  Backports "
#~ "will need to support the old "
#~ "layout by default.  We suggest "
#~ "supporting :pep:`3147` through the use "
#~ "of an environment variable called "
#~ "`$PYTHONENABLECACHEDIR` or the command line"
#~ " switch `-Xenablecachedir` to enable the"
#~ " feature."
#~ msgstr ""

#~ msgid ""
#~ "Makefiles and other tools which "
#~ "calculate dependencies on `.pyc` files "
#~ "(e.g. to byte-compile the source "
#~ "if the `.pyc` is missing) will "
#~ "have to be updated to check the"
#~ " new paths."
#~ msgstr ""

#~ msgid ""
#~ "pyc files inside of the `__pycache__`"
#~ " directories contain a magic tag in"
#~ " their file names.  These are "
#~ "mnemonic tags for the actual magic "
#~ "numbers used by the importer.  We "
#~ "could have used the hexadecimal "
#~ "representation [10]_ of the binary magic"
#~ " number as a unique identifier.  For"
#~ " example, in Python 3.2::"
#~ msgstr ""

#~ msgid ""
#~ "There is some overlap between the "
#~ "goals of this PEP and :pep:`304`, "
#~ "which has been withdrawn.  However "
#~ ":pep:`304` would allow a user to "
#~ "create a shadow file system hierarchy"
#~ " in which to store `pyc` files. "
#~ "This concept of a shadow hierarchy "
#~ "for `pyc` files could be used to"
#~ " satisfy the aims of this PEP.  "
#~ "Although the :pep:`304` does not "
#~ "indicate why it was withdrawn, shadow"
#~ " directories have a number of "
#~ "problems. The location of the shadow "
#~ "`pyc` files would not be easily "
#~ "discovered and would depend on the "
#~ "proper and consistent use of the "
#~ "`$PYTHONBYTECODE` environment variable both by"
#~ " the system and by end users.  "
#~ "There are also global implications, "
#~ "meaning that while the system might "
#~ "want to shadow `pyc` files, users "
#~ "might not want to, but the PEP "
#~ "defines only an all-or-nothing "
#~ "approach."
#~ msgstr ""

#~ msgid ""
#~ "This would be problematic since "
#~ "`foo.bar.__file__` will give the location "
#~ "of the `pyc` file in the shadow"
#~ " directory, and it may not be "
#~ "possible to find the `my.dat` file "
#~ "relative to the source directory from"
#~ " there."
#~ msgstr ""

#~ msgid ""
#~ "An earlier version of this PEP "
#~ "described \"fat\" Python byte code "
#~ "files. These files would contain the "
#~ "equivalent of multiple `pyc` files in"
#~ " a single `pyf` file, with a "
#~ "lookup table keyed off the appropriate"
#~ " magic number.  This was an "
#~ "extensible file format so that the "
#~ "first 5 parallel Python implementations "
#~ "could be supported fairly efficiently, "
#~ "but with extension lookup tables "
#~ "available to scale `pyf` byte code "
#~ "objects as large as necessary."
#~ msgstr ""

#~ msgid ""
#~ "A proposal was floated to call the"
#~ " `__pycache__` directory `.pyc` or some "
#~ "other dot-file name.  This would "
#~ "have the effect on \\*nix systems "
#~ "of hiding the directory.  There are "
#~ "many reasons why this was rejected "
#~ "by the BDFL [20]_ including the "
#~ "fact that dot-files are only "
#~ "special on some platforms, and we "
#~ "actually do *not* want to hide "
#~ "these completely from users."
#~ msgstr ""

#~ msgid "The marshal module: https://docs.python.org/dev/library/marshal.html"
#~ msgstr ""

#~ msgid ""
#~ "import.c: "
#~ "http://svn.python.org/view/python/branches/py3k/Python/import.c?view=markup"
#~ msgstr ""

#~ msgid "Ubuntu: <http://www.ubuntu.com>"
#~ msgstr ""

#~ msgid "Debian: <http://www.debian.org>"
#~ msgstr ""

#~ msgid ""
#~ "Debian Python Policy: http://www.debian.org/doc"
#~ "/packaging-manuals/python-policy/"
#~ msgstr ""

#~ msgid ""
#~ "python-support: http://wiki.debian.org/DebianPythonFAQ"
#~ "#Whatispython-support.3F"
#~ msgstr ""

#~ msgid ""
#~ "python-central: http://wiki.debian.org/DebianPythonFAQ"
#~ "#Whatispython-central.3F"
#~ msgstr ""

#~ msgid ""
#~ "binascii.hexlify(): "
#~ "http://www.python.org/doc/current/library/binascii.html#binascii.hexlify"
#~ msgstr ""

#~ msgid "PyPy: http://codespeak.net/pypy/dist/pypy/doc/"
#~ msgstr ""

#~ msgid "Pynie: http://code.google.com/p/pynie/"
#~ msgstr ""

#~ msgid "py_compile: http://docs.python.org/library/py_compile.html"
#~ msgstr ""

#~ msgid "compileall: http://docs.python.org/library/compileall.html"
#~ msgstr ""

#~ msgid "imp: http://www.python.org/doc/current/library/imp.html"
#~ msgstr ""

#~ msgid "http://www.mail-archive.com/python-dev@python.org/msg45203.html"
#~ msgstr ""

#~ msgid "importlib: http://docs.python.org/3.1/library/importlib.html"
#~ msgstr ""

#~ msgid ""
#~ "Barry Warsaw's original idea was for "
#~ "fat Python byte code files. Martin "
#~ "von Loewis reviewed an early draft "
#~ "of the PEP and suggested the "
#~ "simplification to store traditional `pyc` "
#~ "and `pyo` files in a directory.  "
#~ "Many other people reviewed early "
#~ "versions of this PEP and provided "
#~ "useful feedback including but not "
#~ "limited to:"
#~ msgstr ""

