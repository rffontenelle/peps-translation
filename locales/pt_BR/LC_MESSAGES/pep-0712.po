# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: pt_BR\n"
"Language-Team: pt_BR <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0712.rst
msgid "Author"
msgstr ""

#: ../../peps/pep-0712.rst:3
msgid "Joshua Cannon <joshdcannon@gmail.com>"
msgstr ""

#: ../../peps/pep-0712.rst
msgid "Sponsor"
msgstr ""

#: ../../peps/pep-0712.rst:4
msgid "Eric V. Smith <eric at trueblade.com>"
msgstr ""

#: ../../peps/pep-0712.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/pep-0712.rst:5
msgid ""
"https://discuss.python.org/t/pep-712-adding-a-converter-parameter-to-"
"dataclasses-field/26126"
msgstr ""

#: ../../peps/pep-0712.rst
msgid "Status"
msgstr ""

#: ../../peps/pep-0712.rst:6
msgid "Draft"
msgstr ""

#: ../../peps/pep-0712.rst
msgid "Type"
msgstr ""

#: ../../peps/pep-0712.rst:7
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0712.rst
msgid "Created"
msgstr ""

#: ../../peps/pep-0712.rst:9
msgid "01-Jan-2023"
msgstr ""

#: ../../peps/pep-0712.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0712.rst:10
msgid "3.13"
msgstr ""

#: ../../peps/pep-0712.rst
msgid "Post-History"
msgstr ""

#: ../../peps/pep-0712.rst:11
msgid ""
"`27-Dec-2022 <https://mail.python.org/archives/list/typing-"
"sig@python.org/thread/NWZQIINJQZDOCZGO6TGCUP2PNW4PEKNY/>`__, `19-Jan-2023"
" <https://discuss.python.org/t/add-converter-to-dataclass-"
"field/22956>`__, `23-Apr-2023 "
"<https://discuss.python.org/t/pep-712-adding-a-converter-parameter-to-"
"dataclasses-field/26126>`__,"
msgstr ""

#: ../../peps/pep-0712.rst:16
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0712.rst:18
msgid ""
":pep:`557` added :mod:`dataclasses` to the Python stdlib. :pep:`681` "
"added :func:`~py3.11:typing.dataclass_transform` to help type checkers "
"understand several common dataclass-like libraries, such as attrs, "
"Pydantic, and object relational mapper (ORM) packages such as SQLAlchemy "
"and Django."
msgstr ""

#: ../../peps/pep-0712.rst:23
msgid ""
"A common feature other libraries provide over the standard library "
"implementation is the ability for the library to convert arguments given "
"at initialization time into the types expected for each field using a "
"user-provided conversion function."
msgstr ""

#: ../../peps/pep-0712.rst:28
msgid ""
"Therefore, this PEP adds a ``converter`` parameter to "
":func:`dataclasses.field` (along with the requisite changes to "
":class:`dataclasses.Field` and "
":func:`~py3.11:typing.dataclass_transform`) to specify the function to "
"use to convert the input value for each field to the representation to be"
" stored in the dataclass."
msgstr ""

#: ../../peps/pep-0712.rst:35
msgid "Motivation"
msgstr ""

#: ../../peps/pep-0712.rst:37
msgid ""
"There is no existing, standard way for :mod:`dataclasses` or third-party "
"dataclass-like libraries to support argument conversion in a type-"
"checkable way. To work around this limitation, library authors/users are "
"forced to choose to:"
msgstr ""

#: ../../peps/pep-0712.rst:42
msgid ""
"Opt-in to a custom Mypy plugin. These plugins help Mypy understand the "
"conversion semantics, but not other tools."
msgstr ""

#: ../../peps/pep-0712.rst:44
msgid ""
"Shift conversion responsibility onto the caller of the dataclass "
"constructor. This can make constructing certain dataclasses unnecessarily"
" verbose and repetitive."
msgstr ""

#: ../../peps/pep-0712.rst:47
msgid ""
"Provide a custom ``__init__`` which declares \"wider\" parameter types "
"and converts them when setting the appropriate attribute. This not only "
"duplicates the typing annotations between the converter and ``__init__``,"
" but also opts the user out of many of the features :mod:`dataclasses` "
"provides."
msgstr ""

#: ../../peps/pep-0712.rst:51
msgid ""
"Provide a custom ``__init__`` but without meaningful type annotations for"
" the parameter types requiring conversion."
msgstr ""

#: ../../peps/pep-0712.rst:54
msgid "None of these choices are ideal."
msgstr ""

#: ../../peps/pep-0712.rst:57
msgid "Rationale"
msgstr ""

#: ../../peps/pep-0712.rst:59
msgid ""
"Adding argument conversion semantics is useful and beneficial enough that"
" most dataclass-like libraries provide support. Adding this feature to "
"the standard library means more users are able to opt-in to these "
"benefits without requiring third-party libraries. Additionally third-"
"party libraries are able to clue type-checkers into their own conversion "
"semantics through added support in "
":func:`~py3.11:typing.dataclass_transform`, meaning users of those "
"libraries benefit as well."
msgstr ""

#: ../../peps/pep-0712.rst:68
msgid "Specification"
msgstr ""

#: ../../peps/pep-0712.rst:71
msgid "New ``converter`` parameter"
msgstr ""

#: ../../peps/pep-0712.rst:73
msgid ""
"This specification introduces a new parameter named ``converter`` to the "
":func:`dataclasses.field` function. If provided, it represents a single-"
"argument callable used to convert all values when assigning to the "
"associated attribute."
msgstr ""

#: ../../peps/pep-0712.rst:77
msgid ""
"For frozen dataclasses, the converter is only used inside a "
"``dataclass``-synthesized ``__init__`` when setting the attribute. For "
"non-frozen dataclasses, the converter is used for all attribute "
"assignment (E.g. ``obj.attr = value``), which includes assignment of "
"default values."
msgstr ""

#: ../../peps/pep-0712.rst:82
msgid ""
"The converter is not used when reading attributes, as the attributes "
"should already have been converted."
msgstr ""

#: ../../peps/pep-0712.rst:85
msgid "Adding this parameter also implies the following changes:"
msgstr ""

#: ../../peps/pep-0712.rst:87
msgid "A ``converter`` attribute will be added to :class:`dataclasses.Field`."
msgstr ""

#: ../../peps/pep-0712.rst:88
msgid ""
"``converter`` will be added to "
":func:`~py3.11:typing.dataclass_transform`'s list of supported field "
"specifier parameters."
msgstr ""

#: ../../peps/pep-0712.rst:92
msgid "Example"
msgstr ""

#: ../../peps/pep-0712.rst:144
msgid "Impact on typing"
msgstr ""

#: ../../peps/pep-0712.rst:146
msgid ""
"A ``converter`` must be a callable that accepts a single positional "
"argument, and the parameter type corresponding to this positional "
"argument provides the type of the the synthesized ``__init__`` parameter "
"associated with the field."
msgstr ""

#: ../../peps/pep-0712.rst:150
msgid ""
"In other words, the argument provided for the converter parameter must be"
" compatible with ``Callable[[T], X]`` where ``T`` is the input type for "
"the converter and ``X`` is the output type of the converter."
msgstr ""

#: ../../peps/pep-0712.rst:155
msgid "Type-checking ``default`` and ``default_factory``"
msgstr ""

#: ../../peps/pep-0712.rst:157
msgid ""
"Because default values are unconditionally converted using ``converter``,"
" if an argument for ``converter`` is provided alongside either "
"``default`` or ``default_factory``, the type of the default (the "
"``default`` argument if provided, otherwise the return value of "
"``default_factory``) should be checked using the type of the single "
"argument to the ``converter`` callable."
msgstr ""

#: ../../peps/pep-0712.rst:164
msgid "Converter return type"
msgstr ""

#: ../../peps/pep-0712.rst:166
msgid ""
"The return type of the callable must be a type that's compatible with the"
" field's declared type. This includes the field's type exactly, but can "
"also be a type that's more specialized (such as a converter returning a "
"``list[int]`` for a field annotated as ``list``, or a converter returning"
" an ``int`` for a field annotated as ``int | str``)."
msgstr ""

#: ../../peps/pep-0712.rst:173
msgid "Indirection of allowable argument types"
msgstr ""

#: ../../peps/pep-0712.rst:175
msgid ""
"One downside introduced by this PEP is that knowing what argument types "
"are allowed in the dataclass' ``__init__`` and during attribute "
"assignment is not immediately obvious from reading the dataclass. The "
"allowable types are defined by the converter."
msgstr ""

#: ../../peps/pep-0712.rst:180
msgid ""
"This is true when reading code from source, however typing-related aides "
"such as ``typing.reveal_type`` and \"IntelliSense\" in an IDE should make"
" it easy to know exactly what types are allowed without having to read "
"any source code."
msgstr ""

#: ../../peps/pep-0712.rst:186
msgid "Backward Compatibility"
msgstr ""

#: ../../peps/pep-0712.rst:188
msgid ""
"These changes don't introduce any compatibility problems since they only "
"introduce opt-in new features."
msgstr ""

#: ../../peps/pep-0712.rst:192
msgid "Security Implications"
msgstr ""

#: ../../peps/pep-0712.rst:194
msgid "There are no direct security concerns with these changes."
msgstr ""

#: ../../peps/pep-0712.rst:197
msgid "How to Teach This"
msgstr ""

#: ../../peps/pep-0712.rst:199
msgid ""
"Documentation and examples explaining the new parameter and behavior will"
" be added to the relevant sections of the docs site (primarily on "
":mod:`dataclasses`) and linked from the *What's New* document."
msgstr ""

#: ../../peps/pep-0712.rst:203
msgid ""
"The added documentation/examples will also cover the \"common pitfalls\" "
"that users of converters are likely to encounter. Such pitfalls include:"
msgstr ""

#: ../../peps/pep-0712.rst:206
msgid "Needing to handle ``None``/sentinel values."
msgstr ""

#: ../../peps/pep-0712.rst:207
msgid "Needing to handle values that are already of the correct type."
msgstr ""

#: ../../peps/pep-0712.rst:208
msgid ""
"Avoiding lambdas for converters, as the synthesized ``__init__`` "
"parameter's type will become ``Any``."
msgstr ""

#: ../../peps/pep-0712.rst:210
msgid ""
"Forgetting to convert values in the bodies of user-defined ``__init__`` "
"in frozen dataclasses."
msgstr ""

#: ../../peps/pep-0712.rst:212
msgid ""
"Forgetting to convert values in the bodies of user-defined "
"``__setattr__`` in non-frozen dataclasses."
msgstr ""

#: ../../peps/pep-0712.rst:216
msgid ""
"Additionally, potentially confusing pattern matching semantics should be "
"covered:"
msgstr ""

#: ../../peps/pep-0712.rst:233
msgid ""
"However it's worth noting this behavior is true of any type that does "
"conversion in its initializer, and type-checkers should be able to catch "
"this pitfall:"
msgstr ""

#: ../../peps/pep-0712.rst:245
msgid "Reference Implementation"
msgstr ""

#: ../../peps/pep-0712.rst:247
msgid ""
"The attrs library `already includes <attrs-converters_>`__ a "
"``converter`` parameter exhibiting the same converter semantics "
"(converting in the initializer and on attribute setting) when using the "
"``@define`` class decorator."
msgstr ""

#: ../../peps/pep-0712.rst:252
msgid ""
"CPython support is implemented on `a branch in the author's fork "
"<cpython-branch_>`__."
msgstr ""

#: ../../peps/pep-0712.rst:255
msgid "Rejected Ideas"
msgstr ""

#: ../../peps/pep-0712.rst:258
msgid ""
"Just adding \"converter\" to ``typing.dataclass_transform``'s "
"``field_specifiers``"
msgstr ""

#: ../../peps/pep-0712.rst:260
msgid ""
"The idea of isolating this addition to "
":func:`~py3.11:typing.dataclass_transform` was briefly `discussed on "
"Typing-SIG <only-dataclass-transform_>`__ where it was suggested to "
"broaden this to :mod:`dataclasses` more generally."
msgstr ""

#: ../../peps/pep-0712.rst:265
msgid ""
"Additionally, adding this to :mod:`dataclasses` ensures anyone can reap "
"the benefits without requiring additional libraries."
msgstr ""

#: ../../peps/pep-0712.rst:269
msgid "Not converting default values"
msgstr ""

#: ../../peps/pep-0712.rst:271
msgid ""
"There are pros and cons with both converting and not converting default "
"values. Leaving default values as-is allows type-checkers and dataclass "
"authors to expect that the type of the default matches the type of the "
"field. However, converting default values has three large advantages:"
msgstr ""

#: ../../peps/pep-0712.rst:276
msgid ""
"Consistency. Unconditionally converting all values that are assigned to "
"the attribute, involves fewer \"special rules\" that users must remember."
msgstr ""

#: ../../peps/pep-0712.rst:279
msgid ""
"Simpler defaults. Allowing the default value to have the same type as "
"user-provided values means dataclass authors get the same conveniences as"
" their callers."
msgstr ""

#: ../../peps/pep-0712.rst:283
msgid ""
"Compatibility with attrs. Attrs unconditionally uses the converter to "
"convert default values."
msgstr ""

#: ../../peps/pep-0712.rst:287
msgid "Automatic conversion using the field's type"
msgstr ""

#: ../../peps/pep-0712.rst:289
msgid ""
"One idea could be to allow the type of the field specified (e.g. ``str`` "
"or ``int``) to be used as a converter for each argument provided. "
"`Pydantic's data conversion <pydantic-data-conversion_>`__ has semantics "
"which appear to be similar to this approach."
msgstr ""

#: ../../peps/pep-0712.rst:294
msgid ""
"This works well for fairly simple types, but leads to ambiguity in "
"expected behavior for complex types such as generics. E.g. For "
"``tuple[int, ...]`` it is ambiguous if the converter is supposed to "
"simply convert an iterable to a tuple, or if it is additionally supposed "
"to convert each element type to ``int``. Or for ``int | None``, which "
"isn't callable."
msgstr ""

#: ../../peps/pep-0712.rst:301
msgid "Deducing the attribute type from the return type of the converter"
msgstr ""

#: ../../peps/pep-0712.rst:303
msgid ""
"Another idea would be to allow the user to omit the attribute's type "
"annotation if providing a ``field`` with a ``converter`` argument. "
"Although this would reduce the common repetition this PEP introduces "
"(e.g. ``x: str = field(converter=str)``), it isn't clear how to best "
"support this while maintaining the current dataclass semantics (namely, "
"that the attribute order is preserved for things like the synthesized "
"``__init__``, or ``dataclasses.fields``). This is because there isn't an "
"easy way in Python (today) to get the annotation-only attributes "
"interspersed with un-annotated attributes in the order they were defined."
msgstr ""

#: ../../peps/pep-0712.rst:312
msgid ""
"A sentinel annotation could be applied (e.g. ``x: FromConverter = ...``),"
" however this breaks a fundamental assumption of type annotations."
msgstr ""

#: ../../peps/pep-0712.rst:315
msgid ""
"Lastly, this is feasible if *all* fields (including those without a "
"converter) were assigned to ``dataclasses.field``, which means the class'"
" own namespace holds the order, however this trades repetition of "
"type+converter with repetition of field assignment. The end result is no "
"gain or loss of repetition, but with the added complexity of dataclasses "
"semantics."
msgstr ""

#: ../../peps/pep-0712.rst:321
msgid ""
"This PEP doesn't suggest it can't or shouldn't be done. Just that it "
"isn't included in this PEP."
msgstr ""

#: ../../peps/pep-0712.rst:335
msgid "Copyright"
msgstr ""

#: ../../peps/pep-0712.rst:337
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

