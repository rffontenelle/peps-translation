# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-14 02:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: pt_BR\n"
"Language-Team: pt_BR <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../peps/peps/pep-0789.rst
msgid "Author"
msgstr ""

#: ../../peps/peps/pep-0789.rst:3
msgid "Zac Hatfield-Dodds <zac@zhd.dev>, Nathaniel J. Smith <njs@pobox.com>"
msgstr ""

#: ../../peps/peps/pep-0789.rst
msgid "PEP-Delegate"
msgstr ""

#: ../../peps/peps/pep-0789.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/peps/pep-0789.rst:6
msgid ""
"https://discuss.python.org/t/preventing-yield-inside-certain-context-"
"managers/1091"
msgstr ""

#: ../../peps/peps/pep-0789.rst
msgid "Status"
msgstr ""

#: ../../peps/peps/pep-0789.rst:7
msgid "Draft"
msgstr ""

#: ../../peps/peps/pep-0789.rst
msgid "Type"
msgstr ""

#: ../../peps/peps/pep-0789.rst:8
msgid "Standards Track"
msgstr ""

#: ../../peps/peps/pep-0789.rst
msgid "Created"
msgstr ""

#: ../../peps/peps/pep-0789.rst:9
msgid "14-May-2024"
msgstr ""

#: ../../peps/peps/pep-0789.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/peps/pep-0789.rst:10
msgid "3.14"
msgstr ""

#: ../../peps/peps/pep-0789.rst:14
msgid "Abstract"
msgstr ""

#: ../../peps/peps/pep-0789.rst:16
msgid ""
"`Structured concurrency`_ is increasingly popular in Python.  Interfaces "
"such as the ``asyncio.TaskGroup`` and ``asyncio.timeout`` context managers "
"support compositional reasoning, and allow developers to clearly scope the "
"lifetimes of concurrent tasks. However, using ``yield`` to suspend a frame "
"inside such a context leads to situations where the wrong task is canceled, "
"timeouts are ignored, and exceptions are mishandled. More fundamentally, "
"suspending a frame inside a ``TaskGroup`` violates the structured "
"concurrency design principle that child tasks are encapsulated within their "
"parent frame."
msgstr ""

#: ../../peps/peps/pep-0789.rst:25
msgid ""
"To address these issues, this PEP proposes a new ``sys.prevent_yields()`` "
"context manager. When syntactically inside this context, attempting to "
"``yield`` will raise a RuntimeError, preventing the task from yielding. "
"Additionally, a mechanism will be provided for decorators such as "
"``@contextmanager`` to allow yields inside the decorated function.  ``sys."
"prevent_yields()`` will be used by asyncio and downstream libraries to "
"implement task groups, timeouts, and cancellation; and a related mechanism "
"by ``contextlib`` etc. to convert generators into context managers which "
"allow safe yields."
msgstr ""

#: ../../peps/peps/pep-0789.rst:36
msgid "Background"
msgstr ""

#: ../../peps/peps/pep-0789.rst:38
msgid ""
"Structured concurrency is increasingly popular in Python, in the form of "
"newer :py:mod:`asyncio` interfaces and third-party libraries such as Trio "
"and anyio. These interfaces support compositional reasoning, *so long as* "
"users never write a ``yield`` which suspends a frame while inside a cancel "
"scope."
msgstr ""

#: ../../peps/peps/pep-0789.rst:43
msgid ""
"A cancel scope is a context manager which can... cancel... whatever work "
"occurs within that context (...scope).  In asyncio, this is implicit in the "
"design of ``with asyncio.timeout():`` or ``async with asyncio.TaskGroup() as "
"tg:``, which respectively cancel the contained work after the specified "
"duration, or cancel sibling tasks when one of them raises an exception.  The "
"core functionality of a cancel scope is synchronous, but the user-facing "
"context managers may be either sync or async. [#trio-cancel-scope]_ [#tg-cs]_"
msgstr ""

#: ../../peps/peps/pep-0789.rst:51
msgid ""
"This structured approach works beautifully, unless you hit one specific "
"sharp edge: breaking the nesting structure by ``yield``\\ ing inside a "
"cancel scope. This has much the same effect on structured control flow as "
"adding just a few cross-function ``goto``\\ s, and the effects are truly "
"dire:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:56
msgid ""
"The wrong task can be canceled, whether due to a timeout, an error in a "
"sibling task, or an explicit request to cancel some other task"
msgstr ""

#: ../../peps/peps/pep-0789.rst:58
msgid ""
"Exceptions, including ``CancelledError``, can be delivered to the wrong task"
msgstr ""

#: ../../peps/peps/pep-0789.rst:59
msgid ""
"Exceptions can go missing entirely, being dropped instead of added to an "
"``ExceptionGroup``"
msgstr ""

#: ../../peps/peps/pep-0789.rst:64
msgid "Problem statement"
msgstr ""

#: ../../peps/peps/pep-0789.rst:66
msgid ""
"Here's the fundamental issue: yield suspends a call frame. It only makes "
"sense to yield in a leaf frame -- i.e., if your call stack goes like A -> B -"
"> C, then you can suspend C, but you can't suspend B while leaving C running."
msgstr ""

#: ../../peps/peps/pep-0789.rst:70
msgid ""
"But, TaskGroup is a kind of \"concurrent call\" primitive, where a single "
"frame can have multiple child frames that run concurrently. This means that "
"if we allow people to mix yield and TaskGroup, then we can end up in exactly "
"this situation, where B gets suspended but C is actively running. This is "
"nonsensical, and causes serious practical problems (e.g., if C raises an "
"exception and A has returned, we have no way to propagate it)."
msgstr ""

#: ../../peps/peps/pep-0789.rst:77
msgid ""
"This is a fundamental incompatibility between generator control flow and "
"structured concurrency control flow, not something we can fix by tweaking "
"our APIs. The only solution seems to be to forbid yield inside a TaskGroup."
msgstr ""

#: ../../peps/peps/pep-0789.rst:81
msgid ""
"Although timeouts don't leave a child task running, the close analogy and "
"related problems lead us to conclude that yield should be forbidden inside "
"all cancel scopes, not only TaskGroups.  See :ref:`just-deliver` for "
"discussion."
msgstr ""

#: ../../peps/peps/pep-0789.rst:87
msgid "Motivating examples"
msgstr ""

#: ../../peps/peps/pep-0789.rst:89
msgid ""
"Let's consider three examples, to see what this might look like in practice."
msgstr ""

#: ../../peps/peps/pep-0789.rst:93
msgid "Leaking a timeout to the outer scope"
msgstr ""

#: ../../peps/peps/pep-0789.rst:95
msgid ""
"Suppose that we want to iterate over an async iterator, but wait for at most "
"``max_time`` seconds for each element.  We might naturally encapsulate the "
"logic for doing so in an async generator, so that the call site can continue "
"to use a straightforward ``async for`` loop:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:114
msgid ""
"Unfortunately, there's a bug in this version: the timeout might expire after "
"the generator yields but before it is resumed!  In this case, we'll see a "
"``CancelledError`` raised in the outer task, where it cannot be caught by "
"the ``with timeout(max_time):`` statement."
msgstr ""

#: ../../peps/peps/pep-0789.rst:119
msgid ""
"The fix is fairly simple: get the next element inside the timeout context, "
"and then yield *outside* that context."
msgstr ""

#: ../../peps/peps/pep-0789.rst:134
msgid "Leaking background tasks (breaks cancellation and exception handling)"
msgstr ""

#: ../../peps/peps/pep-0789.rst:136
msgid ""
"Timeouts are not the only interface which wrap a cancel scope - and if you "
"need some background worker tasks, you can't simply close the ``TaskGroup`` "
"before yielding."
msgstr ""

#: ../../peps/peps/pep-0789.rst:140
msgid ""
"As an example, let's look at a fan-in generator, which we'll use to merge "
"the feeds from several \"sensors\".  We'll also set up our mock sensors with "
"a small buffer, so that we'll raise an error in the background task while "
"control flow is outside the ``combined_iterators`` generator."
msgstr ""

#: ../../peps/peps/pep-0789.rst:185
msgid ""
"When we run this code, we see the expected sequence of observations, then a "
"'detection', and then while the main task is sleeping we trigger that "
"``RuntimeError`` in the background.  But... we don't actually observe the "
"``RuntimeError``, not even as the ``__context__`` of another exception!"
msgstr ""

#: ../../peps/peps/pep-0789.rst:210
msgid ""
"Here, again, the problem is that we've ``yield``\\ ed inside a cancel scope; "
"this time the scope which a ``TaskGroup`` uses to cancel sibling tasks when "
"one of the child tasks raises an exception.  However, the ``CancelledError`` "
"which was intended for the sibling task was instead injected into the "
"*outer* task, and so we never got a chance to create and raise an "
"``ExceptionGroup(..., [RuntimeError()])``."
msgstr ""

#: ../../peps/peps/pep-0789.rst:217
msgid ""
"To fix this, we need to turn our async generator into an async context "
"manager, which yields an async iterable - in this case a generator wrapping "
"the queue; in future `perhaps the queue itself <https://github.com/python/"
"cpython/issues/119154>`__:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:248
msgid "In a user-defined context manager"
msgstr ""

#: ../../peps/peps/pep-0789.rst:250
msgid ""
"Yielding inside a cancel scope can be safe, if and only if you're using the "
"generator to implement a context manager [#redirected]_ - in this case any "
"propagating exceptions will be redirected to the expected task."
msgstr ""

#: ../../peps/peps/pep-0789.rst:254
msgid ""
"We've also implemented the ``ASYNC101`` linter rule in `flake8-async "
"<https://pypi.org/project/flake8-async/>`__, which warns against yielding in "
"known cancel scopes.  Could user education be sufficient to avoid these "
"problems?  Unfortunately not: user-defined context managers can also wrap a "
"cancel scope, and it's infeasible to recognize or lint for all such cases."
msgstr ""

#: ../../peps/peps/pep-0789.rst:260
msgid ""
"This regularly arises in practice, because 'run some background tasks for "
"the duration of this context' is a very common pattern in structured "
"concurrency. We saw that in ``combined_iterators()`` above; and have seen "
"this bug in multiple implementations of the websocket protocol:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:279
msgid "Specification"
msgstr ""

#: ../../peps/peps/pep-0789.rst:281
msgid "To prevent these problems, we propose:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:283
msgid ""
"a new context manager, ``with sys.prevent_yields(reason): ...`` which will "
"raise a RuntimeError if you attempt to yield while inside it. [#also-sync]_ "
"Cancel-scope-like context managers in asyncio and downstream code can then "
"wrap this to prevent yielding inside *their* with-block."
msgstr ""

#: ../../peps/peps/pep-0789.rst:288
msgid ""
"a mechanism by which generator-to-context-manager decorators can allow "
"yields across one call.  We're not yet sure what this should look like; the "
"leading candidates are:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:292
msgid "a code-object attribute, ``fn.__code__.co_allow_yields = True``, or"
msgstr ""

#: ../../peps/peps/pep-0789.rst:294
msgid ""
"some sort of invocation flag, e.g. ``fn.__invoke_with_yields__``, to avoid "
"mutating a code object that might be shared between decorated and "
"undecorated functions"
msgstr ""

#: ../../peps/peps/pep-0789.rst:300
msgid "Implementation - tracking frames"
msgstr ""

#: ../../peps/peps/pep-0789.rst:302
msgid ""
"The new ``sys.prevent_yields`` context manager will require interpreter "
"support. For each frame, we track the entries and exits of this context "
"manager."
msgstr ""

#: ../../peps/peps/pep-0789.rst:305
msgid ""
"We're not particularly attached to the exact representation; we'll discuss "
"it as a stack (which would support clear error messages), but more compact "
"representations such as pair-of-integers would also work."
msgstr ""

#: ../../peps/peps/pep-0789.rst:309
msgid ""
"When entering a newly-created or resumed frame, initialize empty stacks of "
"entries and exits."
msgstr ""

#: ../../peps/peps/pep-0789.rst:311
msgid ""
"When returning from a frame, merge these stacks into that of the parent "
"frame."
msgstr ""

#: ../../peps/peps/pep-0789.rst:312
msgid "When yielding:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:314
msgid ""
"if ``entries != [] and not frame.allow_yield_flag``, raise a "
"``RuntimeError`` instead of yielding (the new behavior this PEP proposes)"
msgstr ""

#: ../../peps/peps/pep-0789.rst:316
msgid "otherwise, merge stacks into the parent frame as for a return."
msgstr ""

#: ../../peps/peps/pep-0789.rst:318
msgid ""
"Because this is about yielding frames *within* a task, not switching between "
"tasks, syntactic ``yield`` and ``yield from`` should be affected, but "
"``await`` expressions should not."
msgstr ""

#: ../../peps/peps/pep-0789.rst:322
msgid ""
"We can reduce the overhead by storing this metadata in a single stack per "
"thread for all stack frames which are not generators."
msgstr ""

#: ../../peps/peps/pep-0789.rst:326
msgid "Worked examples"
msgstr ""

#: ../../peps/peps/pep-0789.rst:329
msgid "No-yield example"
msgstr ""

#: ../../peps/peps/pep-0789.rst:331
msgid ""
"In this example, we see multiple rounds of the stack merging as we unwind "
"from ``sys.prevent_yields``, through the user-defined ContextManager, back "
"to the original Frame.  For brevity, the reason for preventing yields is not "
"shown; it is part of the \"1 enter\" state."
msgstr ""

#: ../../peps/peps/pep-0789.rst:366
msgid ""
"With no ``yield`` we don't raise any errors, and because the number of "
"enters and exits balance the frame returns as usual with no further tracking."
msgstr ""

#: ../../peps/peps/pep-0789.rst:371
msgid "Attempts-to-yield example"
msgstr ""

#: ../../peps/peps/pep-0789.rst:373
msgid ""
"In this example, the Frame attempts to ``yield`` while inside the ``sys."
"prevent_yields`` context. This is detected by the interpreter, which raises "
"a ``RuntimeError`` instead of suspending the frame."
msgstr ""

#: ../../peps/peps/pep-0789.rst:404
msgid "Allowed-to-yield example"
msgstr ""

#: ../../peps/peps/pep-0789.rst:406
msgid ""
"In this example, a decorator has marked the Frame as allowing yields. This "
"could be ``@contextlib.contextmanager`` or a related decorator."
msgstr ""

#: ../../peps/peps/pep-0789.rst:444
msgid ""
"When the Frame is allowed to yield, the entry/exit stack is merged into the "
"parent frame's stack before suspending. When the Frame resumes, its stack is "
"empty. Finally, when the Frame exits, the exit is merged into the parent "
"frame's stack, rebalancing it."
msgstr ""

#: ../../peps/peps/pep-0789.rst:449
msgid ""
"This ensures that the parent frame correctly inherits any remaining ``sys."
"prevent_yields`` state, while allowing the Frame to safely suspend and "
"resume."
msgstr ""

#: ../../peps/peps/pep-0789.rst:455
msgid "Allowing yield for context managers"
msgstr ""

#: ../../peps/peps/pep-0789.rst:457
msgid ""
"*TODO: this section is a placeholder, pending a decision on the mechanism "
"for ``@contextmanager`` to re-enable yields in the wrapped function.*"
msgstr ""

#: ../../peps/peps/pep-0789.rst:460
msgid ""
"Explain and show a code sample of how ``@asynccontextmanager`` sets the flag"
msgstr ""

#: ../../peps/peps/pep-0789.rst:462
msgid ""
"Note that third-party decorators such as ``@pytest.fixture`` demonstrate "
"that we can't just have the interpreter special-case contextlib."
msgstr ""

#: ../../peps/peps/pep-0789.rst:467
msgid "Behavior if ``sys.prevent_yields`` is misused"
msgstr ""

#: ../../peps/peps/pep-0789.rst:469
msgid ""
"While unwise, it's possible to call ``sys.prevent_yields.__enter__`` and ``."
"__exit__`` in an order that does not correspond to any valid nesting, or get "
"an invalid frame state in some other way."
msgstr ""

#: ../../peps/peps/pep-0789.rst:473
msgid ""
"There are two ways ``sys.prevent_yields.__exit__`` could detect an invalid "
"state. First, if yields are not prevented, we can simply raise an exception "
"without changing the state.  Second, if an unexpected entry is at the top of "
"the stack, we suggest popping that entry and raising an exception -- this "
"ensures that out-of-order calls will still clear the stack, while still "
"making it clear that something is wrong."
msgstr ""

#: ../../peps/peps/pep-0789.rst:480
msgid ""
"(and if we choose e.g. an integer- rather than stack-based representation, "
"such states may not be distinguishable from correct nesting at all, in which "
"case the question will not arise)"
msgstr ""

#: ../../peps/peps/pep-0789.rst:486
msgid "Anticipated uses"
msgstr ""

#: ../../peps/peps/pep-0789.rst:488
msgid ""
"In the standard library, ``sys.prevent_yields`` could be used by ``asyncio."
"TaskGroup``, ``asyncio.timeout``, and ``asyncio.timeout_at``. Downstream, we "
"expect to use it in ``trio.CancelScope``, async fixtures (in pytest-trio, "
"anyio, etc.), and perhaps other places."
msgstr ""

#: ../../peps/peps/pep-0789.rst:493
msgid ""
"We consider use-cases unrelated to async correctness, such as preventing "
"``decimal.localcontext`` from leaking out of a generator, out of scope for "
"this PEP."
msgstr ""

#: ../../peps/peps/pep-0789.rst:497
msgid ""
"The generator-to-context-manager support would be used by ``@contextlib."
"(async)contextmanager``, and if necessary in ``(Async)ExitStack``."
msgstr ""

#: ../../peps/peps/pep-0789.rst:502
msgid "Backwards Compatibility"
msgstr ""

#: ../../peps/peps/pep-0789.rst:504
msgid ""
"The addition of the ``sys.prevent_yields`` context manager, changes to "
"``@contextlib.(async)contextmanager``, and corresponding interpreter support "
"are all fully backwards-compatible."
msgstr ""

#: ../../peps/peps/pep-0789.rst:508
msgid ""
"Preventing yields inside ``asyncio.TaskGroup``, ``asycio.timeout``, and "
"``asyncio.timeout_at`` would be a breaking change to at least some code in "
"the wild, which (however unsafe and prone to the motivating problems above) "
"may work often enough to make it into production."
msgstr ""

#: ../../peps/peps/pep-0789.rst:513
msgid ""
"We will seek community feedback on appropriate deprecation pathways for "
"standard-library code, including the suggested length of any deprecation "
"period. As an initial suggestion, we could make suspending stdlib contexts "
"emit a DeprecationWarning only under asyncio debug mode in 3.14; then "
"transition to warn-by-default and error under debug mode in 3.15; and "
"finally a hard error in 3.16."
msgstr ""

#: ../../peps/peps/pep-0789.rst:520
msgid ""
"Irrespective of stdlib usage, downstream frameworks would adopt this "
"functionality immediately."
msgstr ""

#: ../../peps/peps/pep-0789.rst:525
msgid "How widespread is this bug?"
msgstr ""

#: ../../peps/peps/pep-0789.rst:527
msgid ""
"We don't have solid numbers here, but believe that many projects are "
"affected in the wild.  Since hitting a moderate and a critical bug "
"attributed to suspending a cancel scope in the same week at work, we've "
"`used static analysis <https://flake8-async.readthedocs.io/en/latest/>`__ "
"with some success. Three people Zac spoke to at PyCon recognized the "
"symptoms and concluded that they had likely been affected."
msgstr ""

#: ../../peps/peps/pep-0789.rst:534
msgid ""
"*TODO: run the ASYNC101 lint rule across ecosystem projects, e.g. the aio-"
"libs packages, and get some sense of frequency in widely-used PyPI packages? "
"This would help inform the break/deprecation pathways for stdlib code.*"
msgstr ""

#: ../../peps/peps/pep-0789.rst:540
msgid "How to Teach This"
msgstr ""

#: ../../peps/peps/pep-0789.rst:542
msgid "Async generators are very rarely taught to novice programmers."
msgstr ""

#: ../../peps/peps/pep-0789.rst:544
msgid ""
"Most intermediate and advanced Python programmers will only interact with "
"this PEP as users of ``TaskGroup``, ``timeout``, and ``@contextmanager``.  "
"For this group, we expect a clear exception message and documentation to be "
"sufficient."
msgstr ""

#: ../../peps/peps/pep-0789.rst:548
msgid ""
"A new section will be added to the `developing with asyncio <https://docs."
"python.org/3/library/asyncio-dev.html>`__ page, which briefly states that "
"async generators are not permitted to ``yield`` when inside a \"cancel "
"scope\" context, i.e. ``TaskGroup`` or ``timeout`` context manager.  We "
"anticipate that the problem-restatement and some parts of the motivation "
"section will provide a basis for these docs."
msgstr ""

#: ../../peps/peps/pep-0789.rst:555
msgid ""
"When working in codebases which avoid async generators entirely [#exp-"
"report]_, we've found that an async context manager yielding an async "
"iterable is a safe and ergonomic replacement for async generators -- and "
"avoids the delayed-cleanup problems described in :pep:`533`, which this "
"proposal does not address."
msgstr ""

#: ../../peps/peps/pep-0789.rst:560
msgid ""
"In the docs for each context manager which wraps a cancel scope, and thus "
"now ``sys.prevent_yields``, include a standard sentence such as \"If used "
"within an async generator, [it is an error to ``yield`` inside this context "
"manager].\" with a hyperlink to the explanation above."
msgstr ""

#: ../../peps/peps/pep-0789.rst:565
msgid ""
"For asyncio, Trio, curio, or other-framework maintainers who implement "
"cancel scope semantics, we will ensure that the documentation of ``sys."
"prevent_yields`` gives a full explanation distilled from the solution and "
"implementation sections of this PEP.  We anticipate consulting most such "
"maintainers for their feedback on the draft PEP."
msgstr ""

#: ../../peps/peps/pep-0789.rst:573
msgid "Rejected alternatives"
msgstr ""

#: ../../peps/peps/pep-0789.rst:576
msgid "PEP 533, deterministic cleanup for iterators"
msgstr ""

#: ../../peps/peps/pep-0789.rst:577
msgid ""
":pep:`533` proposes adding ``__[a]iterclose__`` to the iterator protocol, "
"essentially wrapping a ``with [a]closing(ait)`` around each (async) for "
"loop. While this would be useful for ensuring timely and deterministic "
"cleanup of resources held by iterators, the problem it aims to solve, it "
"does not fully address the issues that motivate this PEP."
msgstr ""

#: ../../peps/peps/pep-0789.rst:583
msgid ""
"Even with PEP 533, misfired cancellations would still be delivered to the "
"wrong task and could wreak havoc before the iterator is closed. Moreover, it "
"does not address the fundamental structured concurrency problem with "
"``TaskGroup``, where suspending a frame that owns a TaskGroup is "
"incompatible with the model of child tasks being fully encapsulated within "
"their parent frame."
msgstr ""

#: ../../peps/peps/pep-0789.rst:591
msgid "Deprecate async generators entirely"
msgstr ""

#: ../../peps/peps/pep-0789.rst:593
msgid ""
"At the 2024 language summit, several attendees suggested instead deprecating "
"async generators *in toto.*  Unfortunately, while the common-in-practice "
"cases all use async generators, Trio code can trigger the same problem with "
"standard generators:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:614
msgid ""
"If it wasn't for the bug in question, this code would look pretty idiomatic "
"- but after about a second, instead of moving on to the next iteration it "
"raises:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:633
msgid ""
"Furthermore, there are some non-cancel-scope synchronous context managers "
"which exhibit related problems, such as the abovementioned ``decimal."
"localcontext``. While fixing the example below is not a goal of this PEP, it "
"demonstrates that yield-within-with problems are not exclusive to async "
"generators:"
msgstr ""

#: ../../peps/peps/pep-0789.rst:652
msgid ""
"While I've had good experiences in async Python without async generators "
"[#exp-report]_, I'd prefer to fix the problem than remove them from the "
"language."
msgstr ""

#: ../../peps/peps/pep-0789.rst:660
msgid "Can't we just deliver exceptions to the right place?"
msgstr ""

#: ../../peps/peps/pep-0789.rst:662
msgid ""
"If we implemented :pep:`568` (Generator-sensitivity for Context Variables; "
"see also :pep:`550`), it would be possible to handle exceptions from "
"timeouts: the event loop could avoid firing a ``CancelledError`` until the "
"generator frame which contains the context manager is on the stack - either "
"when the generator is resumed, or when it is finalized."
msgstr ""

#: ../../peps/peps/pep-0789.rst:668
msgid ""
"This can take arbitrarily long; even if we implemented :pep:`533` to ensure "
"timely cleanup on exiting (async) for-loops it's still possible to drive a "
"generator manually with next/send."
msgstr ""

#: ../../peps/peps/pep-0789.rst:672
msgid ""
"However, this doesn't address the other problem with ``TaskGroup``. The "
"model for generators is that you put a stack frame in suspended animation "
"and can then treat it as an inert value which can be stored, moved around, "
"and maybe discarded or revived in some arbitrary place. The model for "
"structured concurrency is that your stack becomes a tree, with child tasks "
"encapsulated within some parent frame.  They're extending the basic "
"structured programming model in different, and unfortunately incompatible, "
"directions."
msgstr ""

#: ../../peps/peps/pep-0789.rst:680
msgid ""
"Suppose for example that suspending a frame containing an open ``TaskGroup`` "
"also suspended all child tasks.  This would preserve the 'downward' "
"structured concurrency, in that children remain encapsulated - albeit at the "
"cost of deadlocking both of our motivating examples, and much real-world "
"code. However, it would still be possible to resume the generator in a "
"different task, violating the 'upwards' invariant of structured concurrency."
msgstr ""

#: ../../peps/peps/pep-0789.rst:687
msgid ""
"We don't think it's worth adding this much machinery to handle cancel "
"scopes, while still leaving task groups broken."
msgstr ""

#: ../../peps/peps/pep-0789.rst:692
msgid "Alternative implementation - inspecting bytecode"
msgstr ""

#: ../../peps/peps/pep-0789.rst:694
msgid ""
"Jelle Zijlstra has `sketched an alternative`_, where ``sys.prevent_yields`` "
"inspects the bytecode of callers until satisfied that there is no yield "
"between the calling instruction pointer and the next context exit. We expect "
"that support for syntatically-nested context managers could be added fairly "
"easily."
msgstr ""

#: ../../peps/peps/pep-0789.rst:699
msgid ""
"However, it's not yet clear how this would work when user-defined context "
"managers wrap ``sys.prevent_yields``.  Worse, this approach ignores explicit "
"calls to ``__enter__()`` and ``__exit__()``, meaning that the context "
"management protocol would vary depending on whether the ``with`` statement "
"was used."
msgstr ""

#: ../../peps/peps/pep-0789.rst:704
msgid ""
"The 'only pay if you use it' performance cost is very attractive.  However, "
"inspecting frame objects is prohibitively expensive for core control-flow "
"constructs, and causes whole-program slowdowns via de-optimization. On the "
"other hand, adding interpreter support for better performance leads back to "
"the same pay-regardless semantics as our preferred solution above."
msgstr ""

#: ../../peps/peps/pep-0789.rst:712
msgid "Footnotes"
msgstr ""

#: ../../peps/peps/pep-0789.rst:718
msgid ""
"While cancel scopes are implicit in asyncio, the analogous :py:func:`trio:"
"trio.fail_after` (sync) and :py:func:`trio:trio.open_nursery` (async) "
"context managers literally wrap an instance of :py:class:`trio:trio."
"CancelScope`. We'll stick with asyncio for examples here, but say \"cancel "
"scope\" when referring to the framework-independent concept."
msgstr ""

#: ../../peps/peps/pep-0789.rst:726
msgid ""
"A ``TaskGroup`` is not _only_ a cancel scope, but preventing yields would "
"resolve their further problem too.  See :ref:`just-deliver`."
msgstr ""

#: ../../peps/peps/pep-0789.rst:729
msgid ""
"via e.g. ``contextlib.[async]contextmanager``, or moral equivalents such as "
"``@pytest.fixture``"
msgstr ""

#: ../../peps/peps/pep-0789.rst:733
msgid ""
"Note that this prevents yields in both sync and async generators, so that "
"downstream frameworks can safely define sync cancel scope countexts such as :"
"py:func:`trio:trio.fail_after`."
msgstr ""

#: ../../peps/peps/pep-0789.rst:737
msgid ""
"see `Zac's experience report here <https://discuss.python.org/t/using-"
"exceptiongroup-at-anthropic-experience-report/20888>`__"
msgstr ""

#: ../../peps/peps/pep-0789.rst:742
msgid "Copyright"
msgstr ""

#: ../../peps/peps/pep-0789.rst:744
msgid ""
"This document is placed in the public domain or under the CC0-1.0-Universal "
"license, whichever is more permissive."
msgstr ""
