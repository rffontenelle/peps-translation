# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: pt_BR\n"
"Language-Team: pt_BR <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0711.rst
msgid "Author"
msgstr ""

#: ../../peps/pep-0711.rst:3
msgid "Nathaniel J. Smith <njs@pobox.com>"
msgstr ""

#: ../../peps/pep-0711.rst
msgid "PEP-Delegate"
msgstr ""

#: ../../peps/pep-0711.rst:4
msgid "TODO"
msgstr ""

#: ../../peps/pep-0711.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/pep-0711.rst:5
msgid ""
"https://discuss.python.org/t/pep-711-pybi-a-standard-format-for-"
"distributing-python-binaries/25547"
msgstr ""

#: ../../peps/pep-0711.rst
msgid "Status"
msgstr ""

#: ../../peps/pep-0711.rst:6
msgid "Draft"
msgstr ""

#: ../../peps/pep-0711.rst
msgid "Type"
msgstr ""

#: ../../peps/pep-0711.rst:7
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0711.rst
msgid "Topic"
msgstr ""

#: ../../peps/pep-0711.rst:8
msgid "Packaging"
msgstr ""

#: ../../peps/pep-0711.rst
msgid "Created"
msgstr ""

#: ../../peps/pep-0711.rst:10
msgid "06-Apr-2023"
msgstr ""

#: ../../peps/pep-0711.rst
msgid "Post-History"
msgstr ""

#: ../../peps/pep-0711.rst:11
msgid ""
"`06-Apr-2023 <https://discuss.python.org/t/pep-711-pybi-a-standard-"
"format-for-distributing-python-binaries/25547>`__"
msgstr ""

#: ../../peps/pep-0711.rst:15
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0711.rst:17
msgid ""
"“Like wheels, but instead of a pre-built python package, it’s a pre-built"
" python interpreter”"
msgstr ""

#: ../../peps/pep-0711.rst:22
msgid "Motivation"
msgstr ""

#: ../../peps/pep-0711.rst:24
msgid ""
"End goal: Pypi.org has pre-built packages for all Python versions on all "
"popular platforms, so automated tools can easily grab any of them and set"
" it up. It becomes quick and easy to try Python prereleases, pin Python "
"versions in CI, make a temporary environment to reproduce a bug report "
"that only happens on a specific Python point release, etc."
msgstr ""

#: ../../peps/pep-0711.rst:30
msgid ""
"First step (this PEP): define a standard packaging file format to hold "
"pre-built Python interpreters, that reuses existing Python packaging "
"standards as much as possible."
msgstr ""

#: ../../peps/pep-0711.rst:36
msgid "Examples"
msgstr ""

#: ../../peps/pep-0711.rst:38
msgid ""
"Example pybi builds are available at `pybi.vorpus.org "
"<https://pybi.vorpus.org>`__. They're zip files, so you can unpack them "
"and poke around inside if you want to get a feel for how they're laid "
"out."
msgstr ""

#: ../../peps/pep-0711.rst:42
msgid ""
"You can also look at the `tooling I used to create them "
"<https://github.com/njsmith/pybi-tools>`__."
msgstr ""

#: ../../peps/pep-0711.rst:47
msgid "Specification"
msgstr ""

#: ../../peps/pep-0711.rst:50
msgid "Filename"
msgstr ""

#: ../../peps/pep-0711.rst:52
msgid "Filename: ``{distribution}-{version}[-{build tag}]-{platform tag}.pybi``"
msgstr ""

#: ../../peps/pep-0711.rst:54
msgid ""
"This matches the wheel file format defined in :pep:`427`, except dropping"
" the ``{python tag}`` and ``{abi tag}`` and changing the extension from "
"``.whl`` → ``.pybi``."
msgstr ""

#: ../../peps/pep-0711.rst:58
msgid "For example:"
msgstr ""

#: ../../peps/pep-0711.rst:60
msgid "``cpython-3.9.3-manylinux_2014.pybi``"
msgstr ""

#: ../../peps/pep-0711.rst:61
msgid "``cpython-3.10b2-win_amd64.pybi``"
msgstr ""

#: ../../peps/pep-0711.rst:63
msgid ""
"Just like for wheels, if a pybi supports multiple platforms, you can "
"separate them by dots to make a “compressed tag set”:"
msgstr ""

#: ../../peps/pep-0711.rst:66
msgid "``cpython-3.9.5-macosx_11_0_x86_64.macosx_11_0_arm64.pybi``"
msgstr ""

#: ../../peps/pep-0711.rst:68
msgid ""
"(Though in practice this probably won’t be used much, e.g. the above "
"filename is more idiomatically written as "
"``cpython-3.9.5-macosx_11_0_universal2.pybi``.)"
msgstr ""

#: ../../peps/pep-0711.rst:74
msgid "File contents"
msgstr ""

#: ../../peps/pep-0711.rst:76
msgid ""
"A ``.pybi`` file is a zip file, that can be unpacked directly into an "
"arbitrary location and then used as a self-contained Python environment. "
"There’s no ``.data`` directory or install scheme keys, because the Python"
" environment knows which install scheme it’s using, so it can just put "
"things in the right places to start with."
msgstr ""

#: ../../peps/pep-0711.rst:82
msgid ""
"The “arbitrary location” part is important: the pybi can’t contain any "
"hardcoded absolute paths. In particular, any preinstalled scripts MUST "
"NOT embed absolute paths in their shebang lines."
msgstr ""

#: ../../peps/pep-0711.rst:86
msgid ""
"Similar to wheels’ ``<package>-<version>.dist-info`` directory, the pybi "
"archive must contain a top-level directory named ``pybi-info/``. "
"(Rationale: calling it ``pybi-info`` instead ``dist-info`` makes sure "
"that tools don’t get confused about which kind of metadata they’re "
"looking at; leaving off the ``{name}-{version}`` part is fine because "
"only one pybi can be installed into a given directory.) The ``pybi-"
"info/`` directory contains at least the following files:"
msgstr ""

#: ../../peps/pep-0711.rst:94
msgid ""
"``.../PYBI``: metadata about the archive itself, in the same RFC822-ish "
"format as ``METADATA`` and ``WHEEL`` files:"
msgstr ""

#: ../../peps/pep-0711.rst:106
msgid ""
"``.../RECORD``: same as in wheels, except see the note about symlinks, "
"below."
msgstr ""

#: ../../peps/pep-0711.rst:109
msgid ""
"``.../METADATA``: In the same format as described in the current core "
"metadata spec, except that the following keys are forbidden because they "
"don’t make sense:"
msgstr ""

#: ../../peps/pep-0711.rst:113
msgid "``Requires-Dist``"
msgstr ""

#: ../../peps/pep-0711.rst:114
msgid "``Provides-Extra``"
msgstr ""

#: ../../peps/pep-0711.rst:115
msgid "``Requires-Python``"
msgstr ""

#: ../../peps/pep-0711.rst:117
msgid "And also there are some new, required keys described below."
msgstr ""

#: ../../peps/pep-0711.rst:120
msgid "Pybi-specific core metadata"
msgstr ""

#: ../../peps/pep-0711.rst:122
msgid ""
"Here's an example of the new ``METADATA`` fields, before we give the full"
" details::"
msgstr ""

#: ../../peps/pep-0711.rst:162
msgid "Specification:"
msgstr ""

#: ../../peps/pep-0711.rst:164
msgid ""
"``Pybi-Environment-Marker-Variables``: The value of all PEP 508 "
"environment marker variables that are static across installs of this "
"Pybi, as a JSON dict. So for example:"
msgstr ""

#: ../../peps/pep-0711.rst:168
msgid ""
"``python_version`` will always be present, because a Python 3.10 package "
"always has ``python_version == \"3.10\"``."
msgstr ""

#: ../../peps/pep-0711.rst:171
msgid ""
"``platform_version`` will generally not be present, because it gives "
"detailed information about the OS where Python is running, for example::"
msgstr ""

#: ../../peps/pep-0711.rst:176
msgid "``platform_release`` has similar issues."
msgstr ""

#: ../../peps/pep-0711.rst:178
msgid ""
"``platform_machine`` will *usually* be present, except for macOS "
"universal2 pybis: these can potentially be run in either x86-64 or arm64 "
"mode, and we don't know which until the interpreter is actually invoked, "
"so we can't record it in static metadata."
msgstr ""

#: ../../peps/pep-0711.rst:183
msgid ""
"**Rationale:** In many cases, this should allow a resolver running on "
"Linux to compute package pins for a Python environment on Windows, or "
"vice-versa, so long as the resolver has access to the target platform’s "
".pybi file. (Note that ``Requires-Python`` constraints can be checked by "
"using the ``python_full_version`` value.) While we have to leave out a "
"few keys sometimes, they're either fairly useless (``platform_version``, "
"``platform_release``) or can be reconstructed by the resolver "
"(``platform_machine``)."
msgstr ""

#: ../../peps/pep-0711.rst:192
msgid ""
"The markers are also just generally useful information to have "
"accessible. For example, if you have a ``pypy3-7.3.2`` pybi, and you want"
" to know what version of the Python language that supports, then that’s "
"recorded in the ``python_version`` marker."
msgstr ""

#: ../../peps/pep-0711.rst:197
msgid ""
"(Note: we may want to deprecate/remove ``platform_version`` and "
"``platform_release``? They're problematic and I can't figure out any "
"cases where they're useful. But that's out of scope of this particular "
"PEP.)"
msgstr ""

#: ../../peps/pep-0711.rst:201
msgid ""
"``Pybi-Paths``: The install paths needed to install wheels (same keys as "
"``sysconfig.get_paths()``), as relative paths starting at the root of the"
" zip file, as a JSON dict."
msgstr ""

#: ../../peps/pep-0711.rst:205
msgid ""
"These paths MUST be written in Unix format, using forward slashes as a "
"separator, not backslashes."
msgstr ""

#: ../../peps/pep-0711.rst:208
msgid ""
"It must be possible to invoke the Python interpreter by running "
"``{paths[\"scripts\"]}/python``. If there are alternative interpreter "
"entry points (e.g. ``pythonw`` for Windows GUI apps), then they should "
"also be in that directory under their conventional names, with no version"
" number attached. (You can *also* have a ``python3.11`` symlink if you "
"want; there’s no rule against that. It’s just that ``python`` has to "
"exist and work.)"
msgstr ""

#: ../../peps/pep-0711.rst:216
msgid ""
"**Rationale:** ``Pybi-Paths`` and ``Pybi-Wheel-Tag``\\ s (see below) are "
"together enough to let an installer choose wheels and install them into "
"an unpacked pybi environment, without invoking Python. Besides, we need "
"to write down the interpreter location somewhere, so it’s two birds with "
"one stone."
msgstr ""

#: ../../peps/pep-0711.rst:221
msgid ""
"``Pybi-Wheel-Tag``: The wheel tags supported by this interpreter, in "
"preference order (most-preferred first, least-preferred last), except "
"that the special platform tag ``PLATFORM`` should replace any platform "
"tags that depend on the final installation system."
msgstr ""

#: ../../peps/pep-0711.rst:226
msgid ""
"**Discussion:** It would be nice™ if installers could compute a pybi’s "
"corresponding wheel tags ahead of time, so that they could install wheels"
" into the unpacked pybi without needing to actually invoke the python "
"interpreter to query its tags – both for efficiency and to allow for more"
" exotic use cases like setting up a Windows environment from a Linux "
"host."
msgstr ""

#: ../../peps/pep-0711.rst:233
msgid ""
"But unfortunately, it’s impossible to compute the full set of platform "
"tags supported by a Python installation ahead of time, because they can "
"depend on the final system:"
msgstr ""

#: ../../peps/pep-0711.rst:237
msgid ""
"A pybi tagged ``manylinux_2_12_x86_64`` can always use wheels tagged as "
"``manylinux_2_12_x86_64``. It also *might* be able to use wheels tagged "
"``manylinux_2_17_x86_64``, but only if the final installation system has "
"glibc 2.17+."
msgstr ""

#: ../../peps/pep-0711.rst:242
msgid ""
"A pybi tagged ``macosx_11_0_universal2`` (= x86-64 + arm64 support in the"
" same binary) might be able to use wheels tagged as "
"``macosx_11_0_arm64``, but only if it’s installed on an “Apple Silicon” "
"machine and running in arm64 mode."
msgstr ""

#: ../../peps/pep-0711.rst:247
msgid ""
"In these two cases, an installation tool can still work out the "
"appropriate set of wheel tags by computing the local platform tags, "
"taking the wheel tag templates from ``Pybi-Wheel-Tag``, and swapping in "
"the actual supported platforms in place of the magic ``PLATFORM`` string."
msgstr ""

#: ../../peps/pep-0711.rst:253
msgid "However, there are other cases that are even more complicated:"
msgstr ""

#: ../../peps/pep-0711.rst:274
msgid ""
"You can (usually) run both 32- and 64-bit apps on 64-bit Windows. So a "
"pybi"
msgstr ""

#: ../../peps/pep-0711.rst:256
msgid ""
"installer might compute the set of allowable pybi tags on the current "
"platform as [``win32``, ``win_amd64``]. But you can’t then just take that"
" set and swap it into the pybi’s wheel tag template or you get nonsense:"
msgstr ""

#: ../../peps/pep-0711.rst:270
msgid ""
"To handle this, the installer needs to somehow understand that a "
"``manylinux_2_12_x86_64`` pybi can use a ``manylinux_2_17_x86_64`` wheel "
"as long as those are both valid tags on the current machine, but a "
"``win32`` pybi *can’t* use a ``win_amd64`` wheel, even if those are both "
"valid tags on the current machine."
msgstr ""

#: ../../peps/pep-0711.rst:276
msgid ""
"A pybi tagged ``macosx_11_0_universal2`` might be able to use wheels "
"tagged as ``macosx_11_0_x86_64``, but only if it’s installed on an x86-64"
" machine *or* it’s installed on an ARM machine *and* the interpreter is "
"invoked with the magic incantation that tells macOS to run a binary in "
"x86-64 mode. So how the installer plans to invoke the pybi matters too!"
msgstr ""

#: ../../peps/pep-0711.rst:283
msgid ""
"So actually using ``Pybi-Wheel-Tag`` values is less trivial than it might"
" seem, and they’re probably only useful with fairly sophisticated "
"tooling. But, smart pybi installers will already have to understand a lot"
" of these platform compatibility issues in order to select a working "
"pybi, and for the cross-platform pinning/environment building case, users"
" can potentially provide whatever information is needed to disambiguate "
"exactly what platform they’re targeting. So, it’s still useful enough to "
"include in the PyBI metadata -- tools that don't find it useful can "
"simply ignore it."
msgstr ""

#: ../../peps/pep-0711.rst:293
msgid ""
"You can probably generate these metadata values by running this script on"
" the built interpreter:"
msgstr ""

#: ../../peps/pep-0711.rst:339
msgid ""
"This emits a JSON dict on stdout with separate entries for each set of "
"pybi-specific tags."
msgstr ""

#: ../../peps/pep-0711.rst:344
msgid "Symlinks"
msgstr ""

#: ../../peps/pep-0711.rst:346
msgid ""
"Currently, symlinks are used by default in all Unix Python installs "
"(e.g., ``bin/python3 -> bin/python3.9``). And furthermore, symlinks are "
"*required* to store macOS framework builds in ``.pybi`` files. So, unlike"
" wheel files, we absolutely have to support symlinks in ``.pybi`` files "
"for them to be useful at all."
msgstr ""

#: ../../peps/pep-0711.rst:354
msgid "Representing symlinks in zip files"
msgstr ""

#: ../../peps/pep-0711.rst:356
msgid ""
"The de-facto standard for representing symlinks in zip files is the Info-"
"Zip symlink extension, which works as follows:"
msgstr ""

#: ../../peps/pep-0711.rst:359
msgid "The symlink’s target path is stored as if it were the file contents"
msgstr ""

#: ../../peps/pep-0711.rst:360
msgid ""
"The top 4 bits of the Unix permissions field are set to ``0xa``, i.e.: "
"``permissions & 0xf000 == 0xa000``"
msgstr ""

#: ../../peps/pep-0711.rst:362
msgid ""
"The Unix permissions field, in turn, is stored as the top 16 bits of the "
"“external attributes” field."
msgstr ""

#: ../../peps/pep-0711.rst:365
msgid ""
"So if using Python’s ``zipfile`` module, you can check whether a "
"``ZipInfo`` represents a symlink by doing:"
msgstr ""

#: ../../peps/pep-0711.rst:372
msgid "Or if using Rust’s ``zip`` crate, the equivalent check is:"
msgstr ""

#: ../../peps/pep-0711.rst:383
msgid ""
"If you’re on Unix, your ``zip`` and ``unzip`` commands probably "
"understands this format already."
msgstr ""

#: ../../peps/pep-0711.rst:388
msgid "Representing symlinks in RECORD files"
msgstr ""

#: ../../peps/pep-0711.rst:390
msgid "Normally, a ``RECORD`` file lists each file + its hash + its length:"
msgstr ""

#: ../../peps/pep-0711.rst:396
msgid "For symlinks, we instead write:"
msgstr ""

#: ../../peps/pep-0711.rst:402
msgid ""
"That is: we use a special “hash function” called ``symlink``, and then "
"store the actual symlink target as the “hash value”. And the length is "
"left empty."
msgstr ""

#: ../../peps/pep-0711.rst:406
msgid ""
"**Rationale:** we’re already committed to the ``RECORD`` file containing "
"a redundant check on everything in the main archive, so for symlinks we "
"at least need to store some kind of hash, plus some kind of flag to "
"indicate that this is a symlink. Given that symlink target strings are "
"roughly the same size as a hash, we might as well store them directly. "
"This also makes the symlink information easier to access for tools that "
"don’t understand the Info-Zip symlink extension, and makes it possible to"
" losslessly unpack and repack a Unix pybi on a Windows system, which "
"someone might find handy at some point."
msgstr ""

#: ../../peps/pep-0711.rst:417
msgid "Storing symlinks in ``pybi`` files"
msgstr ""

#: ../../peps/pep-0711.rst:419
msgid ""
"When a pybi creator stores a symlink, they MUST use both of the "
"mechanisms defined above: storing it in the zip archive directly using "
"the Info-Zip representation, and also recording it in the ``RECORD`` "
"file."
msgstr ""

#: ../../peps/pep-0711.rst:424
msgid ""
"Pybi consumers SHOULD validate that the symlinks in the archive and "
"``RECORD`` file are consistent with each other."
msgstr ""

#: ../../peps/pep-0711.rst:427
msgid ""
"We also considered using *only* the ``RECORD`` file to store symlinks, "
"but then the vanilla ``unzip`` tool wouldn’t be able to unpack them, and "
"that would make it hard to install a pybi from a shell script."
msgstr ""

#: ../../peps/pep-0711.rst:433
msgid "Limitations"
msgstr ""

#: ../../peps/pep-0711.rst:435
msgid ""
"Symlinks enable a lot of potential messiness. To keep things under "
"control, we impose the following restrictions:"
msgstr ""

#: ../../peps/pep-0711.rst:438
msgid ""
"Symlinks MUST NOT be used in ``.pybi``\\ s targeting Windows, or other "
"platforms that are missing first-class symlink support."
msgstr ""

#: ../../peps/pep-0711.rst:441
msgid ""
"Symlinks MUST NOT be used inside the ``pybi-info`` directory. (Rationale:"
" there’s no need, and it makes things simpler for resolvers that need to "
"extract info from ``pybi-info`` without unpacking the whole archive.)"
msgstr ""

#: ../../peps/pep-0711.rst:446
msgid ""
"Symlink targets MUST be relative paths, and MUST be inside the pybi "
"directory."
msgstr ""

#: ../../peps/pep-0711.rst:449
msgid ""
"If ``A/B/...`` is recorded as a symlink in the archive, then there MUST "
"NOT be any other entries in the archive named like ``A/B/.../C``."
msgstr ""

#: ../../peps/pep-0711.rst:453
msgid ""
"For example, if an archive has a symlink ``foo -> bar``, and then later "
"in the archive there’s a regular file named ``foo/blah.py``, then a naive"
" unpacker could potentially end up writing a file called ``bar/blah.py``."
" Don’t be naive."
msgstr ""

#: ../../peps/pep-0711.rst:458
msgid ""
"Unpackers MUST verify that these rules are followed, because without them"
" attackers could create evil symlinks like ``foo -> /etc/passwd`` or "
"``foo -> ../../../../../etc`` + ``foo/passwd -> ...`` and cause havoc."
msgstr ""

#: ../../peps/pep-0711.rst:464
msgid "Non-normative comments"
msgstr ""

#: ../../peps/pep-0711.rst:467
msgid "Why not just use conda?"
msgstr ""

#: ../../peps/pep-0711.rst:469
msgid ""
"This isn't really in the scope of this PEP, but since conda is a popular "
"way to distribute binary Python interpreters, it's a natural question."
msgstr ""

#: ../../peps/pep-0711.rst:472
msgid ""
"The simple answer is: conda is great! But, there are lots of python users"
" who aren't conda users, and they deserve nice things too. This PEP just "
"gives them another option."
msgstr ""

#: ../../peps/pep-0711.rst:476
msgid ""
"The deeper answer is: the maintainers who upload packages to PyPI are the"
" backbone of the Python ecosystem. They're the first audience for Python "
"packaging tools. And one thing they want is to upload a package once, and"
" have it be accessible across all the different ways Python is deployed: "
"in Debian and Fedora and Homebrew and FreeBSD, in Conda environments, in "
"big companies' monorepos, in Nix, in Blender plugins, in RenPy games, "
"..... you get the idea."
msgstr ""

#: ../../peps/pep-0711.rst:483
msgid ""
"All of these environments have their own tooling and strategies for "
"managing packages and dependencies. So what's special about PyPI and "
"wheels is that they're designed to describe dependencies in a *standard, "
"abstract way*, that all these downstream systems can consume and convert "
"into their local conventions. That's why package maintainers use Python-"
"specific metadata and upload to PyPI: because it lets them address all of"
" those systems simultaneously. Every time you build a Python package for "
"conda, there's an intermediate wheel that's generated, because wheels are"
" the common language that Python package build systems and conda can use "
"to talk to each other."
msgstr ""

#: ../../peps/pep-0711.rst:493
msgid ""
"But then, if you're a maintainer releasing an sdist+wheels, then you "
"naturally want to test what you're releasing, which may depend on "
"arbitrary PyPI packages and versions. So you need tools that build Python"
" environments directly from PyPI, and conda is fundamentally not designed"
" to do that. So conda and pip are both necessary for different cases, and"
" this proposal happens to be targeting the pip side of that equation."
msgstr ""

#: ../../peps/pep-0711.rst:502
msgid "Sdists (or not)"
msgstr ""

#: ../../peps/pep-0711.rst:504
msgid ""
"It might be cool to have an “sdist” equivalent for pybis, i.e., some kind"
" of format for a Python source release that’s structured-enough to let "
"tools automatically fetch and build it into a pybi, for platforms where "
"prebuilt pybis aren’t available. But, this isn’t necessary for the MVP "
"and opens a can of worms, so let’s worry about it later."
msgstr ""

#: ../../peps/pep-0711.rst:512
msgid "What packages should be bundled inside a pybi?"
msgstr ""

#: ../../peps/pep-0711.rst:514
msgid ""
"Pybi builders have the power to pick and choose what exactly goes inside."
" For example, you could include some preinstalled packages in the pybi’s "
"``site-packages`` directory, or prune out bits of the stdlib that you "
"don’t want. We can’t stop you! Though if you do preinstall packages, then"
" it's strongly recommended to also include the correct metadata (``.dist-"
"info`` etc.), so that it’s possible for Pip or other tools to understand "
"out what’s going on."
msgstr ""

#: ../../peps/pep-0711.rst:521
msgid "For my prototype “general purpose” pybi’s, what I chose is:"
msgstr ""

#: ../../peps/pep-0711.rst:523
msgid "Make sure ``site-packages`` is *empty*."
msgstr ""

#: ../../peps/pep-0711.rst:525
msgid ""
"**Rationale:** for traditional standalone python installers that are "
"targeted at end-users, you probably want to include at least ``pip``, to "
"avoid bootstrapping issues (:pep:`453`). But pybis are different: they’re"
" designed to be installed by “smart” tooling, that consume the pybi as "
"part of some kind of larger automated deployment process. It’s easier for"
" these installers to start from a blank slate and then add whatever they "
"need, than for them to start with some preinstalled packages that they "
"may or may not want. (And besides, you can still run ``python -m "
"ensurepip``.)"
msgstr ""

#: ../../peps/pep-0711.rst:534
msgid "Include the full stdlib, *except* for ``test``."
msgstr ""

#: ../../peps/pep-0711.rst:536
msgid ""
"**Rationale:** the top-level ``test`` module contains CPython’s own test "
"suite. It’s huge (CPython without ``test`` is ~37 MB, then ``test`` adds "
"another ~25 MB on top of that!), and essentially never used by regular "
"user code. Also, as precedent, the official nuget packages, the official "
"manylinux images, and multiple Linux distributions all leave it out, and "
"this hasn’t caused any major problems."
msgstr ""

#: ../../peps/pep-0711.rst:543
msgid ""
"So this seems like the best way to balance broad compatibility with "
"reasonable download/install sizes."
msgstr ""

#: ../../peps/pep-0711.rst:546
msgid ""
"I’m not shipping any ``.pyc`` files. They take up space in the download, "
"can be generated on the final system at minimal cost, and dropping them "
"removes a source of location-dependence. (``.pyc`` files store the "
"absolute path of the corresponding ``.py`` file and include it in "
"tracebacks; but, pybis are relocatable, so the correct path isn’t known "
"until after install.)"
msgstr ""

#: ../../peps/pep-0711.rst:555
msgid "Backwards Compatibility"
msgstr ""

#: ../../peps/pep-0711.rst:557
msgid "No backwards compatibility considerations."
msgstr ""

#: ../../peps/pep-0711.rst:561
msgid "Security Implications"
msgstr ""

#: ../../peps/pep-0711.rst:563
msgid ""
"No security implications, beyond the fact that anyone who takes it upon "
"themselves to distribute binaries has to come up with a plan to manage "
"their security (e.g., whether they roll a new build after an OpenSSL CVE "
"drops). But collectively, we core Python folks are already maintaining "
"binary builds for all major platforms (macOS + Windows through "
"python.org, and Linux builds through the official manylinux image), so "
"even if we do start releasing official CPython builds on PyPI it doesn't "
"really raise any new security issues."
msgstr ""

#: ../../peps/pep-0711.rst:573
msgid "How to Teach This"
msgstr ""

#: ../../peps/pep-0711.rst:575
msgid ""
"This isn't targeted at end-users; their experience will simply be that "
"e.g. their pyenv or tox invocation magically gets faster and more "
"reliable (if those projects' maintainers decide to take advantage of this"
" PEP)."
msgstr ""

#: ../../peps/pep-0711.rst:581
msgid "Copyright"
msgstr ""

#: ../../peps/pep-0711.rst:583
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

