# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-28 20:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../pep-0691.rst
msgid "Author"
msgstr ""

#: ../pep-0691.rst:3
msgid ""
"Donald Stufft <donald@stufft.io>, Pradyun Gedam <pradyunsg@gmail.com>, "
"Cooper Lees <me@cooperlees.com>, Dustin Ingram <di@python.org>"
msgstr ""

#: ../pep-0691.rst
msgid "PEP-Delegate"
msgstr ""

#: ../pep-0691.rst:7
msgid "Brett Cannon <brett@python.org>"
msgstr ""

#: ../pep-0691.rst
msgid "Discussions-To"
msgstr ""

#: ../pep-0691.rst:8
msgid ""
"https://discuss.python.org/t/pep-691-json-based-simple-api-for-python-"
"package-indexes/15553"
msgstr ""

#: ../pep-0691.rst
msgid "Status"
msgstr ""

#: ../pep-0691.rst:9
msgid "Accepted"
msgstr ""

#: ../pep-0691.rst
msgid "Type"
msgstr ""

#: ../pep-0691.rst:10
msgid "Standards Track"
msgstr ""

#: ../pep-0691.rst
msgid "Topic"
msgstr ""

#: ../pep-0691.rst:11
msgid "Packaging"
msgstr ""

#: ../pep-0691.rst
msgid "Created"
msgstr ""

#: ../pep-0691.rst:13
msgid "04-May-2022"
msgstr ""

#: ../pep-0691.rst
msgid "Post-History"
msgstr ""

#: ../pep-0691.rst:14
msgid ""
"`05-May-2022 <https://discuss.python.org/t/pep-691-json-based-simple-api-for-"
"python-package-indexes/15553>`__"
msgstr ""

#: ../pep-0691.rst
msgid "Resolution"
msgstr ""

#: ../pep-0691.rst:15
msgid ""
"https://discuss.python.org/t/pep-691-json-based-simple-api-for-python-"
"package-indexes/15553/70"
msgstr ""

#: ../pep-0691.rst:19
msgid "Abstract"
msgstr ""

#: ../pep-0691.rst:21
msgid ""
"The \"Simple Repository API\" that was defined in :pep:`503` (and was in use "
"much longer than that) has served us reasonably well for a very long time. "
"However, the reliance on using HTML as the data exchange mechanism has "
"several shortcomings."
msgstr ""

#: ../pep-0691.rst:26
msgid "There are two major issues with an HTML-based API:"
msgstr ""

#: ../pep-0691.rst:28
msgid ""
"While HTML5 is a standard, it's an incredibly complex standard and ensuring "
"completely correct parsing of it involves complex logic that does not "
"currently exist within the Python standard library (nor the standard library "
"of many other languages)."
msgstr ""

#: ../pep-0691.rst:33
msgid ""
"This means that to actually accept everything that is technically valid, "
"tools have to pull in large dependencies or they have to rely on the "
"standard library's ``html.parser`` library, which is lighter weight but "
"potentially doesn't fully support HTML5."
msgstr ""

#: ../pep-0691.rst:38
msgid ""
"HTML5 is primarily designed as a markup language to present documents for "
"human consumption. Our use of it is driven largely for historical and "
"accidental reasons, and it's unlikely anyone would design an API that relied "
"on it if they were starting from scratch."
msgstr ""

#: ../pep-0691.rst:43
msgid ""
"The primary issue with using a markup format designed for human consumption "
"is that there's not a great way to actually encode data within HTML. We've "
"gotten around this by limiting the data we put in this API and being "
"creative with how we can cram data into the API (for instance, hashes are "
"embedded as URL fragments, adding the ``data-yanked`` attribute in :pep:"
"`592`)."
msgstr ""

#: ../pep-0691.rst:49
msgid ""
":pep:`503` was largely an attempt to standardize what was already in use, so "
"it did not propose any large changes to the API."
msgstr ""

#: ../pep-0691.rst:52
msgid ""
"In the intervening years, we've regularly talked about an \"API V2\" that "
"would re-envision the entire API of PyPI. However, due to limited time "
"constraints, that effort has not gained much, if any, traction beyond people "
"thinking that it would be nice to do."
msgstr ""

#: ../pep-0691.rst:57
msgid ""
"This PEP attempts to take a different route. It doesn't fundamentally change "
"the overall API structure, but instead specifies a new serialization of the "
"existing data contained in existing :pep:`503` responses in a format that is "
"easier for software to parse rather than using a human centric document "
"format."
msgstr ""

#: ../pep-0691.rst:64
msgid "Goals"
msgstr ""

#: ../pep-0691.rst:66
msgid ""
"**Enable zero configuration discovery.** Clients of the simple API **MUST** "
"be able to gracefully determine whether a target repository supports this "
"PEP without relying on any form of out of band communication (configuration, "
"prior knowledge, etc). Individual clients **MAY** choose to require "
"configuration to enable the use of this API, however."
msgstr ""

#: ../pep-0691.rst:71
msgid ""
"**Enable clients to drop support for \"legacy\" HTML parsing.** While it is "
"expected that most clients will keep supporting HTML-only repositories for a "
"while, if not forever, it should be possible for a client to choose to "
"support only the new API formats and no longer invoke an HTML parser."
msgstr ""

#: ../pep-0691.rst:75
msgid ""
"**Enable repositories to drop support for \"legacy\" HTML formats.** Similar "
"to clients, it is expected that most repositories will continue to support "
"HTML responses for a long time, or forever. It should be possible for a "
"repository to choose to only support the new formats."
msgstr ""

#: ../pep-0691.rst:79
msgid ""
"**Maintain full support for existing HTML-only clients.** We **MUST** not "
"break existing clients that are accessing the API as a strictly :pep:`503` "
"API. The only exception to this, is if the repository itself has chosen to "
"no longer support the HTML format."
msgstr ""

#: ../pep-0691.rst:83
msgid ""
"**Minimal additional HTTP requests.** Using this API **MUST** not "
"drastically increase the amount of HTTP requests an installer must do in "
"order to function. Ideally it will require 0 additional requests, but if "
"needed it may require one or two additional requests (total, not per "
"dependency)."
msgstr ""

#: ../pep-0691.rst:87
msgid ""
"**Minimal additional unique reponses.** Due to the nature of how large "
"repositories like PyPI cache responses, this PEP should not introduce a "
"significantly or combinatorially large number of additional unique responses "
"that the repository may produce."
msgstr ""

#: ../pep-0691.rst:91
msgid ""
"**Supports TUF.** This PEP **MUST** be able to function within the bounds of "
"what TUF can support (:pep:`458`), and must be able to be secured using it."
msgstr ""

#: ../pep-0691.rst:93
msgid ""
"**Require only the standard library, or small external dependencies for "
"clients.** Parsing an API response should ideally require nothing but the "
"standard library, however it would be acceptable to require a small, pure "
"Python dependency."
msgstr ""

#: ../pep-0691.rst:100
msgid "Specification"
msgstr ""

#: ../pep-0691.rst:102
msgid ""
"To enable response parsing with only the standard library, this PEP "
"specifies that all responses (besides the files themselves, and the HTML "
"responses from :pep:`503`) should be serialized using `JSON <https://www."
"json.org/>`_."
msgstr ""

#: ../pep-0691.rst:106
msgid ""
"To enable zero configuration discovery and to minimize the amount of "
"additional HTTP requests, this PEP extends :pep:`503` such that all of the "
"API endpoints (other than the files themselves) will utilize HTTP content "
"negotiation to allow client and server to select the correct serialization "
"format to serve, i.e. either HTML or JSON."
msgstr ""

#: ../pep-0691.rst:113
msgid "Versioning"
msgstr ""

#: ../pep-0691.rst:115
msgid ""
"Versioning will adhere to :pep:`629` format (``Major.Minor``), which has "
"defined the existing HTML responses to be ``1.0``. Since this PEP does not "
"introduce new features into the API, rather it describes a different "
"serialization format for the existing features, this PEP does not change the "
"existing ``1.0`` version, and instead just describes how to serialize that "
"into JSON."
msgstr ""

#: ../pep-0691.rst:121
msgid ""
"Similar to :pep:`629`, the major version number **MUST** be incremented if "
"any changes to the new format would result in no longer being able to expect "
"existing clients to meaningfully understand the format."
msgstr ""

#: ../pep-0691.rst:125
msgid ""
"Likewise, the minor version **MUST** be incremented if features are added or "
"removed from the format, but existing clients would be expected to continue "
"to meaningfully understand the format."
msgstr ""

#: ../pep-0691.rst:129
msgid ""
"Changes that would not result in existing clients being unable to "
"meaningfully understand the format and which do not represent features being "
"added or removed may occur without changing the version number."
msgstr ""

#: ../pep-0691.rst:133
msgid ""
"This is intentionally vague, as this PEP believes it is best left up to "
"future PEPs that make any changes to the API to investigate and decide "
"whether or not that change should increment the major or minor version."
msgstr ""

#: ../pep-0691.rst:137
msgid ""
"Future versions of the API may add things that can only be represented in a "
"subset of the available serializations of that version. All serializations "
"version numbers, within a major version, **SHOULD** be kept in sync, but the "
"specifics of how a feature serializes into each format may differ, including "
"whether or not that feature is present at all."
msgstr ""

#: ../pep-0691.rst:143
msgid ""
"It is the intent of this PEP that the API should be thought of as URL "
"endpoints that return data, whose interpretation is defined by the version "
"of that data, and then serialized into the target serialization format."
msgstr ""

#: ../pep-0691.rst:151
msgid "JSON Serialization"
msgstr ""

#: ../pep-0691.rst:153
msgid ""
"The URL structure from :pep:`503` still applies, as this PEP only adds an "
"additional serialization format for the already existing API."
msgstr ""

#: ../pep-0691.rst:156
msgid ""
"The following constraints apply to all JSON serialized responses described "
"in this PEP:"
msgstr ""

#: ../pep-0691.rst:159
msgid ""
"All JSON responses will *always* be a JSON object rather than an array or "
"other type."
msgstr ""

#: ../pep-0691.rst:162
msgid ""
"While JSON doesn't natively support an URL type, any value that represents "
"an URL in this API may be either absolute or relative as long as they point "
"to the correct location. If relative, they are relative to the current URL "
"as if it were HTML."
msgstr ""

#: ../pep-0691.rst:167
msgid ""
"Additional keys may be added to any dictionary objects in the API responses "
"and clients **MUST** ignore keys that they don't understand."
msgstr ""

#: ../pep-0691.rst:170
msgid ""
"All JSON responses will have a ``meta`` key, which contains information "
"related to the response itself, rather than the content of the response."
msgstr ""

#: ../pep-0691.rst:173
msgid ""
"All JSON responses will have a ``meta.api-version`` key, which will be a "
"string that contains the :pep:`629` ``Major.Minor`` version number, with the "
"same fail/warn semantics as defined in :pep:`629`."
msgstr ""

#: ../pep-0691.rst:177
msgid "All requirements of :pep:`503` that are not HTML specific still apply."
msgstr ""

#: ../pep-0691.rst:181
msgid "Project List"
msgstr ""

#: ../pep-0691.rst:183
msgid ""
"The root URL ``/`` for this PEP (which represents the base URL) will be a "
"JSON encoded dictionary which has a two keys:"
msgstr ""

#: ../pep-0691.rst:186
msgid ""
"``projects``: An array where each entry is a dictionary with a single key, "
"``name``, which represents string of the project name."
msgstr ""

#: ../pep-0691.rst:187 ../pep-0691.rst:233
msgid ""
"``meta``: The general response metadata as `described earlier <json-"
"serialization_>`__."
msgstr ""

#: ../pep-0691.rst:189 ../pep-0691.rst:287
msgid "As an example:"
msgstr ""

#: ../pep-0691.rst:206
msgid ""
"The ``name`` field is the same as the one from :pep:`503`, which does not "
"specify whether it is the non-normalized display name or the normalized "
"name. In practice different implementations of these PEPs are choosing "
"differently here, so relying on it being either non-normalized or normalized "
"is relying on an implementation detail of the repository in question."
msgstr ""

#: ../pep-0691.rst:215
msgid ""
"While the ``projects`` key is an array, and thus is required to be in some "
"kind of an order, neither :pep:`503` nor this PEP requires any specific "
"ordering nor that the ordering is consistent from one request to the next. "
"Mentally this is best thought of as a set, but both JSON and HTML lack the "
"functionality to have sets."
msgstr ""

#: ../pep-0691.rst:223
msgid "Project Detail"
msgstr ""

#: ../pep-0691.rst:225
msgid ""
"The format of this URL is ``/<project>/`` where the ``<project>`` is "
"replaced by the :pep:`503` normalized name for that project, so a project "
"named \"Silly_Walk\" would have a URL like ``/silly-walk/``."
msgstr ""

#: ../pep-0691.rst:229
msgid ""
"This URL must respond with a JSON encoded dictionary that has three keys:"
msgstr ""

#: ../pep-0691.rst:231
msgid "``name``: The normalized name of the project."
msgstr ""

#: ../pep-0691.rst:232
msgid ""
"``files``: A list of dictionaries, each one representing an individual file."
msgstr ""

#: ../pep-0691.rst:235
msgid "Each individual file dictionary has the following keys:"
msgstr ""

#: ../pep-0691.rst:237
msgid "``filename``: The filename that is being represented."
msgstr ""

#: ../pep-0691.rst:238
msgid "``url``: The URL that the file can be fetched from."
msgstr ""

#: ../pep-0691.rst:239
msgid ""
"``hashes``: A dictionary mapping a hash name to a hex encoded digest of the "
"file. Multiple hashes can be included, and it is up to the client to decide "
"what to do with multiple hashes (it may validate all of them or a subset of "
"them, or nothing at all). These hash names **SHOULD** always be normalized "
"to be lowercase."
msgstr ""

#: ../pep-0691.rst:244
msgid ""
"The ``hashes`` dictionary **MUST** be present, even if no hashes are "
"available for the file, however it is **HIGHLY** recommended that at least "
"one secure, guaranteed-to-be-available hash is always included."
msgstr ""

#: ../pep-0691.rst:248
msgid ""
"By default, any hash algorithm available via `hashlib <https://docs.python."
"org/3/library/hashlib.html>`_ (specifically any that can be passed to "
"``hashlib.new()`` and do not require additional parameters) can be used as a "
"key for the hashes dictionary. At least one secure algorithm from ``hashlib."
"algorithms_guaranteed`` **SHOULD** always be included. At the time of this "
"PEP, ``sha256`` specifically is recommended."
msgstr ""

#: ../pep-0691.rst:254
msgid ""
"``requires-python``: An **optional** key that exposes the *Requires-Python* "
"metadata field, specified in :pep:`345`. Where this is present, installer "
"tools **SHOULD** ignore the download when installing to a Python version "
"that doesn't satisfy the requirement."
msgstr ""

#: ../pep-0691.rst:259
msgid ""
"Unlike ``data-requires-python`` in :pep:`503`, the ``requires-python`` key "
"does not require any special escaping other than anything JSON does "
"naturally."
msgstr ""

#: ../pep-0691.rst:261
msgid ""
"``dist-info-metadata``: An **optional** key that indicates that metadata for "
"this file is available, via the same location as specified in :pep:`658` "
"(``{file_url}.metadata``). Where this is present, it **MUST** be either a "
"boolean to indicate if the file has an associated metadata file, or a "
"dictionary mapping hash names to a hex encoded digest of the metadata's hash."
msgstr ""

#: ../pep-0691.rst:267
msgid ""
"When this is a dictionary of hashes instead of a boolean, then all the same "
"requirements and recommendations as the ``hashes`` key hold true for this "
"key as well."
msgstr ""

#: ../pep-0691.rst:271
msgid ""
"If this key is missing then the metadata file may or may not exist. If the "
"key value is truthy, then the metadata file is present, and if it is falsey "
"then it is not."
msgstr ""

#: ../pep-0691.rst:275
msgid ""
"It is recommended that servers make the hashes of the metadata file "
"available if possible."
msgstr ""

#: ../pep-0691.rst:277
msgid ""
"``gpg-sig``: An **optional** key that acts a boolean to indicate if the file "
"has an associated GPG signature or not. The URL for the signature file "
"follows what is specified in :pep:`503` (``{file_url}.asc``). If this key "
"does not exist, then the signature may or may not exist."
msgstr ""

#: ../pep-0691.rst:281
msgid ""
"``yanked``: An **optional** key which may be either a boolean to indicate if "
"the file has been yanked, or a non empty, but otherwise arbitrary, string to "
"indicate that a file has been yanked with a specific reason. If the "
"``yanked`` key is present and is a truthy value, then it **SHOULD** be "
"interpreted as indicating that the file pointed to by the ``url`` field has "
"been \"Yanked\" as per :pep:`592`."
msgstr ""

#: ../pep-0691.rst:317
msgid ""
"While the ``files`` key is an array, and thus is required to be in some kind "
"of an order, neither :pep:`503` nor this PEP requires any specific ordering "
"nor that the ordering is consistent from one request to the next. Mentally "
"this is best thought of as a set, but both JSON and HTML lack the "
"functionality to have sets."
msgstr ""

#: ../pep-0691.rst:325
msgid "Content-Types"
msgstr ""

#: ../pep-0691.rst:327
msgid ""
"This PEP proposes that all responses from the Simple API will have a "
"standard content type that describes what the response is (a Simple API "
"response), what version of the API it represents, and what serialization "
"format has been used."
msgstr ""

#: ../pep-0691.rst:331
msgid "The structure of this content type will be:"
msgstr ""

#: ../pep-0691.rst:337
msgid ""
"Since only major versions should be disruptive to clients attempting to "
"understand one of these API responses, only the major version will be "
"included in the content type, and will be prefixed with a ``v`` to clarify "
"that it is a version number."
msgstr ""

#: ../pep-0691.rst:342
msgid "Which means that for the existing 1.0 API, the content types would be:"
msgstr ""

#: ../pep-0691.rst:344
msgid "**JSON:** ``application/vnd.pypi.simple.v1+json``"
msgstr ""

#: ../pep-0691.rst:345
msgid "**HTML:** ``application/vnd.pypi.simple.v1+html``"
msgstr ""

#: ../pep-0691.rst:347
msgid ""
"In addition to the above, a special \"meta\" version is supported named "
"``latest``, whose purpose is to allow clients to request the absolute latest "
"version, without having to know ahead of time what that version is. It is "
"recommended however, that clients be explicit about what versions they "
"support."
msgstr ""

#: ../pep-0691.rst:352
msgid ""
"To support existing clients which expect the existing :pep:`503` API "
"responses to use the ``text/html`` content type, this PEP further defines "
"``text/html`` as an alias for the ``application/vnd.pypi.simple.v1+html`` "
"content type."
msgstr ""

#: ../pep-0691.rst:358
msgid "Version + Format Selection"
msgstr ""

#: ../pep-0691.rst:360
msgid ""
"Now that there is multiple possible serializations, we need a mechanism to "
"allow clients to indicate what serialization formats they're able to "
"understand. In addition, it would be beneficial if any possible new major "
"version to the API can be added without disrupting existing clients "
"expecting the previous API version."
msgstr ""

#: ../pep-0691.rst:365
msgid ""
"To enable this, this PEP standardizes on the use of HTTP's `Server-Driven "
"Content Negotiation <https://developer.mozilla.org/en-US/docs/Web/HTTP/"
"Content_negotiation>`_."
msgstr ""

#: ../pep-0691.rst:368
msgid ""
"While this PEP won't fully describe the entirety of server-driven content "
"negotiation, the flow is roughly:"
msgstr ""

#: ../pep-0691.rst:371
msgid ""
"The client makes an HTTP request containing an ``Accept`` header listing all "
"of the version+format content types that they are able to understand."
msgstr ""

#: ../pep-0691.rst:373
msgid ""
"The server inspects that header, selects one of the listed content types, "
"then returns a response using that content type (treating the absence of an "
"``Accept`` header as ``Accept: */*``)."
msgstr ""

#: ../pep-0691.rst:376
msgid ""
"If the server does not support any of the content types in the ``Accept`` "
"header then they are able to choose between 3 different options for how to "
"respond:"
msgstr ""

#: ../pep-0691.rst:380
msgid ""
"Select a default content type other than what the client has requested and "
"return a response with that."
msgstr ""

#: ../pep-0691.rst:382
msgid ""
"Return a HTTP ``406 Not Acceptable`` response to indicate that none of the "
"requested content types were available, and the server was unable or "
"unwilling to select a default content type to respond with."
msgstr ""

#: ../pep-0691.rst:385
msgid ""
"Return a HTTP ``300 Multiple Choices`` response that contains a list of all "
"of the possible responses that could have been chosen."
msgstr ""

#: ../pep-0691.rst:387
msgid ""
"The client interprets the response, handling the different types of "
"responses that the server may have responded with."
msgstr ""

#: ../pep-0691.rst:390
msgid ""
"This PEP does not specify which choices the server makes in regards to "
"handling a content type that it isn't able to return, and clients **SHOULD** "
"be prepared to handle all of the possible responses in whatever way makes "
"the most sense for that client."
msgstr ""

#: ../pep-0691.rst:395
msgid ""
"However, as there is no standard format for how a ``300 Multiple Choices`` "
"response can be interpreted, this PEP highly discourages servers from "
"utilizing that option, as clients will have no way to understand and select "
"a different content-type to request. In addition, it's unlikely that the "
"client *could* understand a different content type anyways, so at best this "
"response would likely just be treated the same as a ``406 Not Acceptable`` "
"error."
msgstr ""

#: ../pep-0691.rst:402
msgid ""
"This PEP **does** require that if the meta version ``latest`` is being used, "
"the server **MUST** respond with the content type for the actual version "
"that is contained in the response (i.e. A ``Accept: application/vnd.pypi."
"simple.latest+json`` request that returns a ``v1.x`` response should have a "
"``Content-Type`` of ``application/vnd.pypi.simple.v1+json``)."
msgstr ""

#: ../pep-0691.rst:409
msgid ""
"The ``Accept`` header is a comma separated list of content types that the "
"client understands and is able to process. It supports three different "
"formats for each content type that is being requested:"
msgstr ""

#: ../pep-0691.rst:413
msgid "``$type/$subtype``"
msgstr ""

#: ../pep-0691.rst:414
msgid "``$type/*``"
msgstr ""

#: ../pep-0691.rst:415
msgid "``*/*``"
msgstr ""

#: ../pep-0691.rst:417
msgid ""
"For the use of selecting a version+format, the most useful of these is "
"``$type/$subtype``, as that is the only way to actually specify the version "
"and format you want."
msgstr ""

#: ../pep-0691.rst:421
msgid ""
"The order of the content types listed in the ``Accept`` header does not have "
"any specific meaning, and the server **SHOULD** consider all of them to be "
"equally valid to respond with. If a client wishes to specify that they "
"prefer a specific content type over another, they may use the ``Accept`` "
"header's `quality value <https://developer.mozilla.org/en-US/docs/Glossary/"
"Quality_values>`_ syntax."
msgstr ""

#: ../pep-0691.rst:428
msgid ""
"This allows a client to specify a priority for a specific entry in their "
"``Accept`` header, by appending a ``;q=`` followed by a value between ``0`` "
"and ``1`` inclusive, with up to 3 decimal digits. When interpreting this "
"value, an entry with a higher quality has priority over an entry with a "
"lower quality, and any entry without a quality present will default to a "
"quality of ``1``."
msgstr ""

#: ../pep-0691.rst:434
msgid ""
"However, clients should keep in mind that a server is free to select **any** "
"of the content types they've asked for, regardless of their requested "
"priority, and it may even return a content type that they did **not** ask "
"for."
msgstr ""

#: ../pep-0691.rst:438
msgid ""
"To aid clients in determining the content type of the response that they "
"have received from an API request, this PEP requires that servers always "
"include a ``Content-Type`` header indicating the content type of the "
"response. This is technically a backwards incompatible change, however in "
"practice `pip has been enforcing this requirement <https://github.com/pypa/"
"pip/blob/cf3696a81b341925f82f20cb527e656176987565/src/pip/_internal/index/"
"collector.py#L123-L150>`_ so the risks for actual breakages is low."
msgstr ""

#: ../pep-0691.rst:445
msgid "An example of how a client can operate would look like:"
msgstr ""

#: ../pep-0691.rst:496
msgid ""
"If a client wishes to only support HTML or only support JSON, then they "
"would just remove the content types that they do not want from the "
"``Accept`` header, and turn receiving them into an error."
msgstr ""

#: ../pep-0691.rst:502
msgid "Alternative Negotiation Mechanisms"
msgstr ""

#: ../pep-0691.rst:504
msgid ""
"While using HTTP's Content negotiation is considered the standard way for a "
"client and server to coordinate to ensure that the client is getting an HTTP "
"response that it is able to understand, there are situations where that "
"mechanism may not be sufficient. For those cases this PEP has alternative "
"negotiation mechanisms that may *optionally* be used instead."
msgstr ""

#: ../pep-0691.rst:512
msgid "URL Parameter"
msgstr ""

#: ../pep-0691.rst:514
msgid ""
"Servers that implement the Simple API may choose to support an URL parameter "
"named ``format`` to allow the clients to request a specific version of the "
"URL."
msgstr ""

#: ../pep-0691.rst:517
msgid ""
"The value of the ``format`` parameter should be **one** of the valid content "
"types. Passing multiple content types, wild cards, quality values, etc... is "
"**not** supported."
msgstr ""

#: ../pep-0691.rst:521
msgid ""
"Supporting this parameter is optional, and clients **SHOULD NOT** rely on it "
"for interacting with the API. This negotiation mechanism is intended to "
"allow for easier human based exploration of the API within a browser, or to "
"allow documentation or notes to link to a specific version+format."
msgstr ""

#: ../pep-0691.rst:526
msgid ""
"Servers that do not support this parameter may choose to return an error "
"when it is present, or they may simple ignore its presence."
msgstr ""

#: ../pep-0691.rst:529
msgid ""
"When a server does implement this parameter, it **SHOULD** take precedence "
"over any values in the client's ``Accept`` header, and if the server does "
"not support the requested format, it may choose to fall back to the "
"``Accept`` header, or choose any of the error conditions that standard "
"server-driven content negotiation typically has (e.g. ``406 Not Available``, "
"``303 Multiple Choices``, or selecting a default type to return)."
msgstr ""

#: ../pep-0691.rst:538
msgid "Endpoint Configuration"
msgstr ""

#: ../pep-0691.rst:540
msgid ""
"This option technically is not a special option at all, it is just a natural "
"consequence of using content negotiation and allowing servers to select "
"which of the available content types is their default."
msgstr ""

#: ../pep-0691.rst:544
msgid ""
"If a server is unwilling or unable to implement the server-driven content "
"negotiation, and would instead rather require users to explicitly configure "
"their client to select the version they want, then that is a supported "
"configuration."
msgstr ""

#: ../pep-0691.rst:548
msgid ""
"To enable this, a server should make multiple endpoints (for instance, ``/"
"simple/v1+html/`` and/or ``/simple/v1+json/``) for each version+format that "
"they wish to support. Under that endpoint, they can host a copy of their "
"repository that only supports one (or a subset) of the content-types. When a "
"client makes a request using the ``Accept`` header, the server can ignore it "
"and return the content type that corresponds to that endpoint."
msgstr ""

#: ../pep-0691.rst:555
msgid ""
"For clients that wish to require specific configuration, they can keep track "
"of which version+format a specific repository URL was configured for, and "
"when making a request to that server, emit an ``Accept`` header that *only* "
"includes the correct content type."
msgstr ""

#: ../pep-0691.rst:562
msgid "TUF Support - PEP 458"
msgstr ""

#: ../pep-0691.rst:564
msgid ""
":pep:`458` requires that all API responses are hashable and that they can be "
"uniquely identified by a path relative to the repository root. For a Simple "
"API repository, the target path is the Root of our API (e.g. ``/simple/`` on "
"PyPI). This creates challenges when accessing the API using a TUF client "
"instead of directly using a standard HTTP client, as the TUF client cannot "
"handle the fact that a target could have multiple different representations "
"that all hash differently."
msgstr ""

#: ../pep-0691.rst:571
msgid ""
":pep:`458` does not specify what the target path should be for the Simple "
"API, but TUF requires that the target paths be \"file-like\", in other "
"words, a path like ``simple/PROJECT/`` is not acceptable, because it "
"technically points to a directory."
msgstr ""

#: ../pep-0691.rst:576
msgid ""
"The saving grace is that the target path does not *have* to actually match "
"the URL being fetched from the Simple API, and it can just be a sigil that "
"the fetching code knows how to transform into the actual URL that needs to "
"be fetched. This same thing can hold true for other aspects of the actual "
"HTTP request, such as the ``Accept`` header."
msgstr ""

#: ../pep-0691.rst:582
msgid ""
"Ultimately figuring out how to map a directory to a filename is out of scope "
"for this PEP (but it would be in scope for :pep:`458`), and this PEP defers "
"making a decision about how exactly to represent this inside of :pep:`458` "
"metadata."
msgstr ""

#: ../pep-0691.rst:586
msgid ""
"However, it appears that the current WIP branch against pip that attempts to "
"implement :pep:`458` is using a target path like ``simple/PROJECT/index."
"html``. This could be modified to include the API version and serialization "
"format using something like ``simple/PROJECT/vnd.pypi.simple.vN.FORMAT``. So "
"the v1 HTML format would be ``simple/PROJECT/vnd.pypi.simple.v1.html`` and "
"the v1 JSON format would be ``simple/PROJECT/vnd.pypi.simple.v1.json``."
msgstr ""

#: ../pep-0691.rst:593
msgid ""
"In this case, since ``text/html`` is an alias to ``application/vnd.pypi."
"simple.v1+html`` when interacting through TUF, it likely will make the most "
"sense to normalize to the more explicit name."
msgstr ""

#: ../pep-0691.rst:597
msgid ""
"Likewise the ``latest`` metaversion should not be included in the targets, "
"only explicitly declared versions should be supported."
msgstr ""

#: ../pep-0691.rst:602
msgid "Recommendations"
msgstr ""

#: ../pep-0691.rst:604
msgid ""
"This section is non-normative, and represents what the PEP authors believe "
"to be the best default implementation decisions for something implementing "
"this PEP, but it does **not** represent any sort of requirement to match "
"these decisions."
msgstr ""

#: ../pep-0691.rst:608
msgid ""
"These decisions have been chosen to maximize the number of requests that can "
"be moved onto the newest version of an API, while maintaining the greatest "
"amount of compatibility. In addition, they've also tried to make using the "
"API provide guardrails that attempt to push clients into making the best "
"choices it can."
msgstr ""

#: ../pep-0691.rst:613
msgid "It is recommended that servers:"
msgstr ""

#: ../pep-0691.rst:615
msgid ""
"Support all 3 content types described in this PEP, using server-driven "
"content negotiation, for as long as they reasonably can, or at least as long "
"as they're receiving non trivial traffic that uses the HTML responses."
msgstr ""

#: ../pep-0691.rst:619
msgid ""
"When encountering an ``Accept`` header that does not contain any content "
"types that it knows how to work with, the server should not ever return a "
"``300 Multiple Choice`` response, and instead return a ``406 Not "
"Acceptable`` response."
msgstr ""

#: ../pep-0691.rst:624
msgid ""
"However, if choosing to use the endpoint configuration, you should prefer to "
"return a ``200 OK`` response in the expected content type for that endpoint."
msgstr ""

#: ../pep-0691.rst:627
msgid ""
"When selecting an acceptable version, the server should choose the highest "
"version that the client supports, with the most expressive/featureful "
"serialization format, taking into account the specificity of the client "
"requests as well as any quality priority values they have expressed, and it "
"should only use the ``text/html`` content type as a last resort."
msgstr ""

#: ../pep-0691.rst:633
msgid "It is recommended that clients:"
msgstr ""

#: ../pep-0691.rst:635
msgid ""
"Support all 3 content types described in this PEP, using server-driven "
"content negotiation, for as long as they reasonably can."
msgstr ""

#: ../pep-0691.rst:638
msgid ""
"When constructing an ``Accept`` header, include all of the content types "
"that you support."
msgstr ""

#: ../pep-0691.rst:641
msgid ""
"You should generally *not* include a quality priority value for your content "
"types, unless you have implementation specific reasons that you want the "
"server to take into account (for example, if you're using the standard "
"library HTML parser and you're worried that there may be some kinds of HTML "
"responses that you're unable to parse in some edge cases)."
msgstr ""

#: ../pep-0691.rst:647
msgid ""
"The one exception to this recommendation is that it is recommended that you "
"*should* include a ``;q=0.01`` value on the legacy ``text/html`` content "
"type, unless it is the only content type that you are requesting."
msgstr ""

#: ../pep-0691.rst:651
msgid ""
"Explicitly select what versions they are looking for, rather than using the "
"``latest`` meta version during normal operation."
msgstr ""

#: ../pep-0691.rst:654
msgid ""
"Check the ``Content-Type`` of the response and ensure it matches something "
"that you were expecting."
msgstr ""

#: ../pep-0691.rst:659
msgid "FAQ"
msgstr ""

#: ../pep-0691.rst:662
msgid "Does this mean PyPI is planning to drop support for HTML/PEP 503?"
msgstr ""

#: ../pep-0691.rst:664
msgid ""
"No, PyPI has no plans at this time to drop support for :pep:`503` or HTML "
"responses."
msgstr ""

#: ../pep-0691.rst:667
msgid ""
"While this PEP does give repositories the flexibility to do that, that "
"largely exists to ensure that things like using the Endpoint Configuration "
"mechanism is able to work, and to ensure that clients do not make any "
"assumptions that would prevent, at some point in the future, gracefully "
"dropping support for HTML."
msgstr ""

#: ../pep-0691.rst:672
msgid ""
"The existing HTML responses incur almost no maintenance burden on PyPI and "
"there is no pressing need to remove them. The only real benefit to dropping "
"them would be to reduce the number of items cached in our CDN."
msgstr ""

#: ../pep-0691.rst:676
msgid ""
"If in the future PyPI *does* wish to drop support for them, doing so would "
"almost certainly be the topic of a PEP, or at a minimum a public, open, "
"discussion and would be informed by metrics showing any impact to end users."
msgstr ""

#: ../pep-0691.rst:682
msgid "Why JSON instead of X format?"
msgstr ""

#: ../pep-0691.rst:684
msgid ""
"JSON parsers are widely available in most, if not every, language. A JSON "
"parser is also available in the Python standard library. It's not the "
"perfect format, but it's good enough."
msgstr ""

#: ../pep-0691.rst:690
msgid "Why not add X feature?"
msgstr ""

#: ../pep-0691.rst:692
msgid ""
"The general goal of this PEP is to change or add very little. We will "
"instead focus largely on translating the existing information contained "
"within our HTML responses into a sensible JSON representation. This will "
"include :pep:`658` metadata required for packaging tooling."
msgstr ""

#: ../pep-0691.rst:697
msgid ""
"The only real new capability that is added in this PEP is the ability to "
"have multiple hashes for a single file. That was done because the current "
"mechanism being limited to a single hash has made it painful in the past to "
"migrate hashes (md5 to sha256) and the cost of making the hashes a "
"dictionary and allowing multiple is pretty low."
msgstr ""

#: ../pep-0691.rst:703
msgid ""
"The API was generally designed to allow further extension through adding new "
"keys, so if there's some new piece of data that an installer might need, "
"future PEPs can easily make that available."
msgstr ""

#: ../pep-0691.rst:709
msgid "Why include the filename when the URL has it already?"
msgstr ""

#: ../pep-0691.rst:711
msgid ""
"We could reduce the size of our responses by removing the ``filename`` key "
"and expecting clients to pull that information out of the URL."
msgstr ""

#: ../pep-0691.rst:714
msgid ""
"Currently this PEP chooses not to do that, largely because :pep:`503` "
"explicitly required that the filename be available via the anchor tag of the "
"links, though that was largely because *something* had to be there. It's not "
"clear if repositories in the wild always have a filename as the last part of "
"the URL or if they're relying on the filename in the anchor tag."
msgstr ""

#: ../pep-0691.rst:720
msgid ""
"It also makes the responses slightly nicer to read for a human, as you get a "
"nice short unique identifier."
msgstr ""

#: ../pep-0691.rst:723
msgid ""
"If we got reasonable confidence that mandating the filename is in the URL, "
"then we could drop this data and reduce the size of the JSON response."
msgstr ""

#: ../pep-0691.rst:728
msgid "Why not break out other pieces of information from the filename?"
msgstr ""

#: ../pep-0691.rst:730
msgid ""
"Currently clients are expected to parse a number of pieces of information "
"from the filename such as project name, version, ABI tags, etc. We could "
"break these out and add them as keys to the file object."
msgstr ""

#: ../pep-0691.rst:734
msgid ""
"This PEP has chosen not to do that because doing so would increase the size "
"of the API responses, and most clients are going to require the ability to "
"parse that information out of file names anyways regardless of what the API "
"does. Thus it makes sense to keep that functionality inside of the clients."
msgstr ""

#: ../pep-0691.rst:741
msgid "Why Content Negotiation instead of multiple URLs?"
msgstr ""

#: ../pep-0691.rst:743
msgid ""
"Another reasonable way to implement this would be to duplicate the API "
"routes and include some marker in the URL itself for JSON. Such as making "
"the URLs be something like ``/simple/foo.json``, ``/simple/_index.json``, "
"etc."
msgstr ""

#: ../pep-0691.rst:747
msgid ""
"This makes some things simpler like TUF integration and fully static serving "
"of a repository (since ``.json`` files can just be written out)."
msgstr ""

#: ../pep-0691.rst:750
msgid "However, this is two pretty major issues:"
msgstr ""

#: ../pep-0691.rst:752
msgid ""
"Our current URL structure relies on the fact that there is an URL that "
"represents the \"root\", ``/`` to serve the list of projects. If we want to "
"have separate URLs for JSON and HTML, we would need to come up with some way "
"to have two root URLs."
msgstr ""

#: ../pep-0691.rst:756
msgid ""
"Something like ``/`` being HTML and ``/_index.json`` being JSON, since "
"``_index`` isn't a valid project name could work. But ``/`` being HTML "
"doesn't work great if a repository wants to remove support for HTML."
msgstr ""

#: ../pep-0691.rst:760
msgid ""
"Another option could be moving all of the existing HTML URLs under a "
"namespace while making a new namespace for JSON. Since ``/<project>/`` was "
"defined, we would have to make these namespaces not valid project names, so "
"something like ``/_html/`` and ``/_json/`` could work, then just redirect "
"the non namespaced URLs to whatever the \"default\" for that repository is "
"(likely HTML, unless they've disabled HTML then JSON)."
msgstr ""

#: ../pep-0691.rst:765
msgid ""
"With separate URLs, there's no good way to support zero configuration "
"discovery that a repository supports the JSON URLs without making additional "
"HTTP requests to determine if the JSON URL exists or not."
msgstr ""

#: ../pep-0691.rst:769
msgid ""
"The most naive implementation of this would be to request the JSON URL and "
"fall back to the HTML URL for *every* single request, but that would be "
"horribly performant and violate the goal of minimal additional HTTP requests."
msgstr ""

#: ../pep-0691.rst:773
msgid ""
"The most likely implementation of this would be to make some sort of "
"repository level configuration file that somehow indicates what is "
"supported. We would have the same namespace problem as above, with the same "
"solution, something like ``/_config.json`` or so could hold that data, and a "
"client could first make an HTTP request to that, and if it exists pull it "
"down and parse it to learn about the capabilities of this particular "
"repository."
msgstr ""

#: ../pep-0691.rst:779
msgid "The use of ``Accept`` also allows us to add versioning into this field"
msgstr ""

#: ../pep-0691.rst:781
msgid ""
"All being said, it is the opinion of this PEP that those three issues "
"combined make using separate API routes a less desirable solution than "
"relying on content negotiation to select the most ideal representation of "
"the data."
msgstr ""

#: ../pep-0691.rst:787
msgid "Does this mean that static servers are no longer supported?"
msgstr ""

#: ../pep-0691.rst:789
msgid ""
"In short, no, static servers are still (almost) fully supported by this PEP."
msgstr ""

#: ../pep-0691.rst:791
msgid ""
"The specifics of how they are supported will depend on the static server in "
"question. For example:"
msgstr ""

#: ../pep-0691.rst:794
msgid ""
"**S3:** S3 fully supports custom content types, however it does not support "
"any form of content negotiation. In order to have a server hosted on S3, you "
"would have to use the \"Endpoint configuration\" style of negotiation, and "
"users would have to configure their clients explicitly."
msgstr ""

#: ../pep-0691.rst:798
msgid ""
"**GitHub Pages:** GitHub pages does not support custom content types, so the "
"S3 solution is not currently workable, which means that only ``text/html`` "
"repositories would function."
msgstr ""

#: ../pep-0691.rst:801
msgid ""
"**Apache:** Apache fully supports server-driven content negotiation, and "
"would just need to be configured to map the custom content types to specific "
"extension."
msgstr ""

#: ../pep-0691.rst:806
msgid "Why not add an ``application/json`` alias like ``text/html``?"
msgstr ""

#: ../pep-0691.rst:808
msgid ""
"This PEP believes that it is best for both clients and servers to be "
"explicit about the types of the API responses that are being used, and a "
"content type like ``application/json`` is the exact opposite of explicit."
msgstr ""

#: ../pep-0691.rst:812
msgid ""
"The existence of the ``text/html`` alias exists as a compromise primarily to "
"ensure that existing consumers of the API continue to function as they "
"already do. There is no such expectation of existing clients using the "
"Simple API with a ``application/json`` content type."
msgstr ""

#: ../pep-0691.rst:817
msgid ""
"In addition, ``application/json`` has no versioning in it, which means that "
"if there is ever a ``2.x`` version of the Simple API, we will be forced to "
"make a decision. Should ``application/json`` preserve backwards "
"compatibility and continue to be an alias for ``application/vnd.pypi.simple."
"v1+json``, or should it be updated to be an alias for ``application/vnd.pypi."
"simple.v2+json``?"
msgstr ""

#: ../pep-0691.rst:823
msgid ""
"This problem doesn't exist for ``text/html``, because the assumption is that "
"HTML will remain a legacy format, and will likely not gain *any* new "
"features, much less features that require breaking compatibility. So having "
"it be an alias for ``application/vnd.pypi.simple.v1+html`` is effectively "
"the same as having it be an alias for ``application/vnd.pypi.simple."
"latest+html``, since ``1.x`` will likely be the only HTML version to exist."
msgstr ""

#: ../pep-0691.rst:830
msgid ""
"The largest benefit to adding the ``application/json`` content type is that "
"there do things that do not allow you to have custom content types, and "
"require you to select one of their preset content types. The main example of "
"this being GitHub Pages, which the lack of ``application/json`` support in "
"this PEP means that static repositories will no longer be able to be hosted "
"on GitHub Pages unless GitHub adds the ``application/vnd.pypi.simple."
"v1+json`` content type."
msgstr ""

#: ../pep-0691.rst:837
msgid ""
"This PEP believes that the benefits are not large enough to add that content "
"type alias at this time, and that its inclusion would likely be a footgun "
"waiting for unsuspecting people to accidentally pick it up. Especially given "
"that we can always add it in the future, but removing things is a lot harder "
"to do."
msgstr ""

#: ../pep-0691.rst:845
msgid "Why add a ``application/vnd.pypi.simple.v1+html``?"
msgstr ""

#: ../pep-0691.rst:847
msgid ""
"The PEP expects the HTML version of the API to become legacy, so one option "
"it could take is not add the ``application/vnd.pypi.simple.v1+html`` content "
"type, and just use ``text/html`` for that."
msgstr ""

#: ../pep-0691.rst:851
msgid ""
"This PEP has decided that adding the new content type is better overall, "
"since it makes even the legacy format more self describing and makes them "
"both more consistent with each other. Overall I think it's more confusing if "
"the ``+html`` version doesn't exist."
msgstr ""

#: ../pep-0691.rst:858
msgid "Why v1.0 and not v1.1 or v2.0?"
msgstr ""

#: ../pep-0691.rst:860
msgid ""
"This PEP is still wholly backwards compatible with clients that could read "
"the existing v1.0 API, can still continue to read the API after these "
"changes have been made. In :pep:`629`, the qualification for a major version "
"bump is:"
msgstr ""

#: ../pep-0691.rst:864
msgid ""
"Incrementing the major version is used to signal a backwards incompatible "
"change such that existing clients would no longer be expected to be able to "
"meaningfully use the API."
msgstr ""

#: ../pep-0691.rst:868
msgid ""
"The changes in this PEP do not meet that bar, nothing has changed in a way "
"that existing clients would no longer be expected to be able to meaningfully "
"use the API."
msgstr ""

#: ../pep-0691.rst:872
msgid "That means we should still be within the v1.x version line."
msgstr ""

#: ../pep-0691.rst:874
msgid ""
"The question of whether we should be v1.1 or v1.0 is a more interesting one, "
"and there are a few ways of looking at it:"
msgstr ""

#: ../pep-0691.rst:877
msgid ""
"We've exposed new features to the API (the project name on the project page, "
"multiple hashes), which is a sign that we should increment the minor version."
msgstr ""

#: ../pep-0691.rst:880
msgid ""
"The new features exist wholly within the JSON serialization, which means "
"that no client that currently is requesting the HTML 1.0 page, would ever "
"see any of the new features anyways, so for them it is effectively still "
"v1.0."
msgstr ""

#: ../pep-0691.rst:883
msgid ""
"No major client has implemented support for PEP 629 yet, which means that "
"the minor version numbering is largely academic at this point anyways, since "
"it exists to let clients provide feedback to end users."
msgstr ""

#: ../pep-0691.rst:887
msgid ""
"The second and third points above end up making the first point kind of "
"meaningless, and with that, it makes more sense to just call everything v1.0 "
"and be stricter about updating versions into the future."
msgstr ""

#: ../pep-0691.rst:893
msgid "Appendix 1: Survey of use cases to cover"
msgstr ""

#: ../pep-0691.rst:895
msgid ""
"This was done through a discussion between ``pip``, ``PyPI``, and "
"``bandersnarch`` maintainers, who are the two first potential users for the "
"new API. This is how they use the Simple + JSON APIs today or how they "
"currently plan to use it:"
msgstr ""

#: ../pep-0691.rst:899
msgid "``pip``:"
msgstr ""

#: ../pep-0691.rst:901
msgid "List of all files for a particular release"
msgstr ""

#: ../pep-0691.rst:902
msgid "Metadata of each individual artifact:"
msgstr ""

#: ../pep-0691.rst:904
msgid "was it yanked? (``data-yanked``)"
msgstr ""

#: ../pep-0691.rst:905
msgid "what's the python-requires? (``data-python-requires``)"
msgstr ""

#: ../pep-0691.rst:906
msgid "what's the hash of this file? (currently, hash in URL)"
msgstr ""

#: ../pep-0691.rst:907
msgid "Full metadata (``data-dist-info-metadata``)"
msgstr ""

#: ../pep-0691.rst:908
msgid ""
"[Bonus] what are the declared dependencies, if available (list-of-strings, "
"null if unavailable)?"
msgstr ""

#: ../pep-0691.rst:910
msgid "``bandersnatch`` - Only uses legacy JSON API + XMLRPC today:"
msgstr ""

#: ../pep-0691.rst:912
msgid "Generates Simple HTML rather than copying from PyPI"
msgstr ""

#: ../pep-0691.rst:914
msgid ""
"Maybe this changes with the new API and we verbatim pull these API assets "
"from PyPI"
msgstr ""

#: ../pep-0691.rst:916
msgid "List of all files for a particular release."
msgstr ""

#: ../pep-0691.rst:918
msgid "Workout URL for release files to download"
msgstr ""

#: ../pep-0691.rst:920
msgid "Metadata of each individual artifact."
msgstr ""

#: ../pep-0691.rst:922
msgid "Write out the JSON to mirror storage today (disk/S3)"
msgstr ""

#: ../pep-0691.rst:924
msgid ""
"Required metadata used (via `Package class <https://github.com/pypa/"
"bandersnatch/blob/main/src/bandersnatch/package.py>`__):"
msgstr ""

#: ../pep-0691.rst:927
msgid "``metadata[\"info\"]``"
msgstr ""

#: ../pep-0691.rst:928
msgid "``metadata[\"last_serial\"]``"
msgstr ""

#: ../pep-0691.rst:929
msgid "``metadata[\"releases\"]``"
msgstr ""

#: ../pep-0691.rst:931
msgid "digests"
msgstr ""

#: ../pep-0691.rst:932
msgid "URL"
msgstr ""

#: ../pep-0691.rst:934
msgid ""
"XML-RPC calls (we'd love to deprecate - but we don't think should go in the "
"Simple API)"
msgstr ""

#: ../pep-0691.rst:936
msgid "[Bonus] Get packages since serial X (or all)"
msgstr ""

#: ../pep-0691.rst:938
msgid "XML-RPC Call: ``changelog_since_serial``"
msgstr ""

#: ../pep-0691.rst:940
msgid "[Bonus] Get all packages with serial"
msgstr ""

#: ../pep-0691.rst:942
msgid "XML-RPC Call: ``list_packages_with_serial``"
msgstr ""

#: ../pep-0691.rst:946
msgid "Appendix 2: Rough Underlying Data Models"
msgstr ""

#: ../pep-0691.rst:948
msgid ""
"These are not intended to perfectly match the server, client, or wire "
"formats. Rather, these are conceptual models, put to code to make them more "
"explicit as to the abstract models underlining the repository API as it "
"evolved through :pep:`503`, :pep:`529`, :pep:`629`, :pep:`658`, and now this "
"PEP, :pep:`691`."
msgstr ""

#: ../pep-0691.rst:954
msgid ""
"The existing HTML, and the new JSON serialization of these models then "
"represent how these underlying conceptual models get mapped onto the actual "
"wire formats."
msgstr ""

#: ../pep-0691.rst:958
msgid ""
"How servers or clients choose to model this data is out of scope for this "
"PEP."
msgstr ""

#: ../pep-0691.rst:1044
msgid "Copyright"
msgstr ""

#: ../pep-0691.rst:1046
msgid ""
"This document is placed in the public domain or under the CC0-1.0-Universal "
"license, whichever is more permissive."
msgstr ""
