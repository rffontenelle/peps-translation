# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-20 10:43-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../peps/pep-0451.rst
msgid "Author"
msgstr "Autor"

#: ../../peps/pep-0451.rst:5
msgid "Eric Snow <ericsnowcurrently@gmail.com>"
msgstr ""

#: ../../peps/pep-0451.rst
msgid "BDFL-Delegate"
msgstr ""

#: ../../peps/pep-0451.rst:6
msgid "Brett Cannon <brett@python.org>, Alyssa Coghlan <ncoghlan@gmail.com>"
msgstr ""

#: ../../peps/pep-0451.rst
msgid "Discussions-To"
msgstr ""

#: ../../peps/pep-0451.rst:7
msgid "import-sig@python.org"
msgstr ""

#: ../../peps/pep-0451.rst
msgid "Status"
msgstr "Status"

#: ../../peps/pep-0451.rst:8
msgid "Final"
msgstr ""

#: ../../peps/pep-0451.rst
msgid "Type"
msgstr "Tipo"

#: ../../peps/pep-0451.rst:9
msgid "Standards Track"
msgstr ""

#: ../../peps/pep-0451.rst
msgid "Created"
msgstr "Criada em"

#: ../../peps/pep-0451.rst:11
msgid "08-Aug-2013"
msgstr ""

#: ../../peps/pep-0451.rst
msgid "Python-Version"
msgstr ""

#: ../../peps/pep-0451.rst:12
msgid "3.4"
msgstr ""

#: ../../peps/pep-0451.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../../peps/pep-0451.rst:13
msgid "08-Aug-2013, 28-Aug-2013, 18-Sep-2013, 24-Sep-2013, 04-Oct-2013"
msgstr ""

#: ../../peps/pep-0451.rst
msgid "Resolution"
msgstr ""

#: ../../peps/pep-0451.rst:14
msgid "https://mail.python.org/pipermail/python-dev/2013-November/130104.html"
msgstr ""

#: ../../peps/pep-0451.rst:18
msgid "Abstract"
msgstr ""

#: ../../peps/pep-0451.rst:20
msgid ""
"This PEP proposes to add a new class to importlib.machinery called "
"\"ModuleSpec\".  It will provide all the import-related information used "
"to load a module and will be available without needing to load the module"
" first.  Finders will directly provide a module's spec instead of a "
"loader (which they will continue to provide indirectly).  The import "
"machinery will be adjusted to take advantage of module specs, including "
"using them to load modules."
msgstr ""

#: ../../peps/pep-0451.rst:30
msgid "Terms and Concepts"
msgstr ""

#: ../../peps/pep-0451.rst:32
msgid ""
"The changes in this proposal are an opportunity to make several existing "
"terms and concepts more clear, whereas currently they are (unfortunately)"
" ambiguous.  New concepts are also introduced in this proposal.  Finally,"
" it's worth explaining a few other existing terms with which people may "
"not be so familiar.  For the sake of context, here is a brief summary of "
"all three groups of terms and concepts.  A more detailed explanation of "
"the import system is found at [#import_system_docs]_."
msgstr ""

#: ../../peps/pep-0451.rst:42 ../../peps/pep-0451.rst:552
msgid "name"
msgstr ""

#: ../../peps/pep-0451.rst:44
msgid ""
"In this proposal, a module's \"name\" refers to its fully-qualified name,"
" meaning the fully-qualified name of the module's parent (if any) joined "
"to the simple name of the module by a period."
msgstr ""

#: ../../peps/pep-0451.rst:49
msgid "finder"
msgstr ""

#: ../../peps/pep-0451.rst:51
msgid ""
"A \"finder\" is an object that identifies the loader that the import "
"system should use to load a module.  Currently this is accomplished by "
"calling the finder's find_module() method, which returns the loader."
msgstr ""

#: ../../peps/pep-0451.rst:55
msgid ""
"Finders are strictly responsible for providing the loader, which they do "
"through their find_module() method. The import system then uses that "
"loader to load the module."
msgstr ""

#: ../../peps/pep-0451.rst:60 ../../peps/pep-0451.rst:553
msgid "loader"
msgstr ""

#: ../../peps/pep-0451.rst:62
msgid ""
"A \"loader\" is an object that is used to load a module during import. "
"Currently this is done by calling the loader's load_module() method.  A "
"loader may also provide APIs for getting information about the modules it"
" can load, as well as about data from sources associated with such a "
"module."
msgstr ""

#: ../../peps/pep-0451.rst:68
msgid ""
"Right now loaders (via load_module()) are responsible for certain "
"boilerplate, import-related operations.  These are:"
msgstr ""

#: ../../peps/pep-0451.rst:71
msgid "Perform some (module-related) validation"
msgstr ""

#: ../../peps/pep-0451.rst:72
msgid "Create the module object"
msgstr ""

#: ../../peps/pep-0451.rst:73
msgid "Set import-related attributes on the module"
msgstr ""

#: ../../peps/pep-0451.rst:74
msgid "\"Register\" the module to sys.modules"
msgstr ""

#: ../../peps/pep-0451.rst:75
msgid "Exec the module"
msgstr ""

#: ../../peps/pep-0451.rst:76
msgid "Clean up in the event of failure while loading the module"
msgstr ""

#: ../../peps/pep-0451.rst:78
msgid ""
"This all takes place during the import system's call to "
"Loader.load_module()."
msgstr ""

#: ../../peps/pep-0451.rst:82 ../../peps/pep-0451.rst:555
msgid "origin"
msgstr ""

#: ../../peps/pep-0451.rst:84
msgid ""
"This is a new term and concept.  The idea of it exists subtly in the "
"import system already, but this proposal makes the concept explicit."
msgstr ""

#: ../../peps/pep-0451.rst:87
msgid ""
"\"origin\" in an import context means the system (or resource within a "
"system) from which a module originates.  For the purposes of this "
"proposal, \"origin\" is also a string which identifies such a resource or"
" system.  \"origin\" is applicable to all modules."
msgstr ""

#: ../../peps/pep-0451.rst:92
msgid ""
"For example, the origin for built-in and frozen modules is the "
"interpreter itself.  The import system already identifies this origin as "
"\"built-in\" and \"frozen\", respectively.  This is demonstrated in the "
"following module repr: \"<module 'sys' (built-in)>\"."
msgstr ""

#: ../../peps/pep-0451.rst:97
msgid ""
"In fact, the module repr is already a relatively reliable, though "
"implicit, indicator of a module's origin.  Other modules also indicate "
"their origin through other means, as described in the entry for "
"\"location\"."
msgstr ""

#: ../../peps/pep-0451.rst:102
msgid ""
"It is up to the loader to decide on how to interpret and use a module's "
"origin, if at all."
msgstr ""

#: ../../peps/pep-0451.rst:106
msgid "location"
msgstr ""

#: ../../peps/pep-0451.rst:108
msgid ""
"This is a new term.  However the concept already exists clearly in the "
"import system, as associated with the ``__file__`` and ``__path__`` "
"attributes of modules, as well as the name/term \"path\" elsewhere."
msgstr ""

#: ../../peps/pep-0451.rst:112
msgid ""
"A \"location\" is a resource or \"place\", rather than a system at large,"
" from which a module is loaded.  It qualifies as an \"origin\".  Examples"
" of locations include filesystem paths and URLs.  A location is "
"identified by the name of the resource, but may not necessarily identify "
"the system to which the resource pertains.  In such cases the loader "
"would have to identify the system itself."
msgstr ""

#: ../../peps/pep-0451.rst:119
msgid ""
"In contrast to other kinds of module origin, a location cannot be "
"inferred by the loader just by the module name.  Instead, the loader must"
" be provided with a string to identify the location, usually by the "
"finder that generates the loader.  The loader then uses this information "
"to locate the resource from which it will load the module.  In theory you"
" could load the module at a given location under various names."
msgstr ""

#: ../../peps/pep-0451.rst:126
msgid ""
"The most common example of locations in the import system are the files "
"from which source and extension modules are loaded.  For these modules "
"the location is identified by the string in the ``__file__`` attribute.  "
"Although ``__file__`` isn't particularly accurate for some modules (e.g. "
"zipped), it is currently the only way that the import system indicates "
"that a module has a location."
msgstr ""

#: ../../peps/pep-0451.rst:133
msgid "A module that has a location may be called \"locatable\"."
msgstr ""

#: ../../peps/pep-0451.rst:136
msgid "cache"
msgstr ""

#: ../../peps/pep-0451.rst:138
msgid ""
"The import system stores compiled modules in the __pycache__ directory as"
" an optimization.  This module cache that we use today was provided by "
":pep:`3147`.  For this proposal, the relevant API for module caching is "
"the ``__cache__`` attribute of modules and the cache_from_source() "
"function in importlib.util.  Loaders are responsible for putting modules "
"into the cache (and loading out of the cache).   Currently the cache is "
"only used for compiled source modules.  However, loaders may take "
"advantage of the module cache for other kinds of modules."
msgstr ""

#: ../../peps/pep-0451.rst:148
msgid "package"
msgstr ""

#: ../../peps/pep-0451.rst:150
msgid ""
"The concept does not change, nor does the term.  However, the distinction"
" between modules and packages is mostly superficial. Packages *are* "
"modules.  They simply have a ``__path__`` attribute and import may add "
"attributes bound to submodules.  The typically perceived difference is a "
"source of confusion.  This proposal explicitly de-emphasizes the "
"distinction between packages and modules where it makes sense to do so."
msgstr ""

#: ../../peps/pep-0451.rst:160
msgid "Motivation"
msgstr ""

#: ../../peps/pep-0451.rst:162
msgid ""
"The import system has evolved over the lifetime of Python.  In late 2002 "
":pep:`302` introduced standardized import hooks via finders and loaders "
"and sys.meta_path.  The importlib module, introduced with Python 3.1, now"
" exposes a pure Python implementation of the APIs described by "
":pep:`302`, as well as of the full import system.  It is now much easier "
"to understand and extend the import system.  While a benefit to the "
"Python community, this greater accessibility also presents a challenge."
msgstr ""

#: ../../peps/pep-0451.rst:171
msgid ""
"As more developers come to understand and customize the import system, "
"any weaknesses in the finder and loader APIs will be more impactful.  So "
"the sooner we can address any such weaknesses the import system, the "
"better...and there are a couple we hope to take care of with this "
"proposal."
msgstr ""

#: ../../peps/pep-0451.rst:176
msgid ""
"Firstly, any time the import system needs to save information about a "
"module we end up with more attributes on module objects that are "
"generally only meaningful to the import system.  It would be nice to have"
" a per-module namespace in which to put future import-related information"
" and to pass around within the import system.  Secondly, there's an API "
"void between finders and loaders that causes undue complexity when "
"encountered.  The :pep:`420` (namespace packages) implementation had to "
"work around this.  The complexity surfaced again during recent efforts on"
" a separate proposal. [#ref_files_pep]_"
msgstr ""

#: ../../peps/pep-0451.rst:186
msgid ""
"The `finder`_ and `loader`_ sections above detail current responsibility "
"of both.  Notably, loaders are not required to provide any of the "
"functionality of their load_module() method through other methods.  Thus,"
" though the import-related information about a module is likely available"
" without loading the module, it is not otherwise exposed."
msgstr ""

#: ../../peps/pep-0451.rst:192
msgid ""
"Furthermore, the requirements associated with load_module() are common to"
" all loaders and mostly are implemented in exactly the same way.  This "
"means every loader has to duplicate the same boilerplate code.  "
"importlib.util provides some tools that help with this, but it would be "
"more helpful if the import system simply took charge of these "
"responsibilities.  The trouble is that this would limit the degree of "
"customization that load_module() could easily continue to facilitate."
msgstr ""

#: ../../peps/pep-0451.rst:200
msgid ""
"More importantly, While a finder *could* provide the information that the"
" loader's load_module() would need, it currently has no consistent way to"
" get it to the loader.  This is a gap between finders and loaders which "
"this proposal aims to fill."
msgstr ""

#: ../../peps/pep-0451.rst:205
msgid ""
"Finally, when the import system calls a finder's find_module(), the "
"finder makes use of a variety of information about the module that is "
"useful outside the context of the method.  Currently the options are "
"limited for persisting that per-module information past the method call, "
"since it only returns the loader.  Popular options for this limitation "
"are to store the information in a module-to-info mapping somewhere on the"
" finder itself, or store it on the loader."
msgstr ""

#: ../../peps/pep-0451.rst:213
msgid ""
"Unfortunately, loaders are not required to be module-specific.  On top of"
" that, some of the useful information finders could provide is common to "
"all finders, so ideally the import system could take care of those "
"details.  This is the same gap as before between finders and loaders."
msgstr ""

#: ../../peps/pep-0451.rst:219
msgid ""
"As an example of complexity attributable to this flaw, the implementation"
" of namespace packages in Python 3.3 (see :pep:`420`) added "
"FileFinder.find_loader() because there was no good way for find_module() "
"to provide the namespace search locations."
msgstr ""

#: ../../peps/pep-0451.rst:224
msgid ""
"The answer to this gap is a ModuleSpec object that contains the per-"
"module information and takes care of the boilerplate functionality "
"involved with loading the module."
msgstr ""

#: ../../peps/pep-0451.rst:230
msgid "Specification"
msgstr ""

#: ../../peps/pep-0451.rst:232
msgid ""
"The goal is to address the gap between finders and loaders while changing"
" as little of their semantics as possible.  Though some functionality and"
" information is moved to the new ModuleSpec type, their behavior should "
"remain the same.  However, for the sake of clarity the finder and loader "
"semantics will be explicitly identified."
msgstr ""

#: ../../peps/pep-0451.rst:238
msgid ""
"Here is a high-level summary of the changes described by this PEP.  More "
"detail is available in later sections."
msgstr ""

#: ../../peps/pep-0451.rst:242
msgid "importlib.machinery.ModuleSpec (new)"
msgstr ""

#: ../../peps/pep-0451.rst:244
msgid ""
"An encapsulation of a module's import-system-related state during import."
" See the `ModuleSpec`_ section below for a more detailed description."
msgstr ""

#: ../../peps/pep-0451.rst:247
msgid ""
"ModuleSpec(name, loader, \\*, origin=None, loader_state=None, "
"is_package=None)"
msgstr ""

#: ../../peps/pep-0451.rst:249
msgid "Attributes:"
msgstr ""

#: ../../peps/pep-0451.rst:251
msgid "name - a string for the fully-qualified name of the module."
msgstr ""

#: ../../peps/pep-0451.rst:252
msgid "loader - the loader to use for loading."
msgstr ""

#: ../../peps/pep-0451.rst:253
msgid ""
"origin - the name of the place from which the module is loaded, e.g. "
"\"builtin\" for built-in modules and the filename for modules loaded from"
" source."
msgstr ""

#: ../../peps/pep-0451.rst:256
msgid ""
"submodule_search_locations - list of strings for where to find "
"submodules, if a package (None otherwise)."
msgstr ""

#: ../../peps/pep-0451.rst:258
msgid ""
"loader_state - a container of extra module-specific data for use during "
"loading."
msgstr ""

#: ../../peps/pep-0451.rst:260
msgid ""
"cached (property) - a string for where the compiled module should be "
"stored."
msgstr ""

#: ../../peps/pep-0451.rst:262
msgid ""
"parent (RO-property) - the fully-qualified name of the package to which "
"the module belongs as a submodule (or None)."
msgstr ""

#: ../../peps/pep-0451.rst:264
msgid ""
"has_location (RO-property) - a flag indicating whether or not the "
"module's \"origin\" attribute refers to a location."
msgstr ""

#: ../../peps/pep-0451.rst:268
msgid "importlib.util Additions"
msgstr ""

#: ../../peps/pep-0451.rst:270
msgid ""
"These are ModuleSpec factory functions, meant as a convenience for "
"finders.  See the `Factory Functions`_ section below for more detail."
msgstr ""

#: ../../peps/pep-0451.rst:273
msgid ""
"spec_from_file_location(name, location, \\*, loader=None, "
"submodule_search_locations=None) - build a spec from file-oriented "
"information and loader APIs."
msgstr ""

#: ../../peps/pep-0451.rst:275
msgid ""
"spec_from_loader(name, loader, \\*, origin=None, is_package=None) - build"
" a spec with missing information filled in by using loader APIs."
msgstr ""

#: ../../peps/pep-0451.rst:280
msgid "Other API Additions"
msgstr ""

#: ../../peps/pep-0451.rst:282
msgid ""
"importlib.find_spec(name, path=None, target=None) will work exactly the "
"same as importlib.find_loader() (which it replaces), but return a spec "
"instead of a loader."
msgstr ""

#: ../../peps/pep-0451.rst:286
msgid "For finders:"
msgstr ""

#: ../../peps/pep-0451.rst:288
msgid ""
"importlib.abc.MetaPathFinder.find_spec(name, path, target) and "
"importlib.abc.PathEntryFinder.find_spec(name, target) will return a "
"module spec to use during import."
msgstr ""

#: ../../peps/pep-0451.rst:292
msgid "For loaders:"
msgstr ""

#: ../../peps/pep-0451.rst:294
msgid ""
"importlib.abc.Loader.exec_module(module) will execute a module in its own"
" namespace.  It replaces importlib.abc.Loader.load_module(), taking over "
"its module execution functionality."
msgstr ""

#: ../../peps/pep-0451.rst:297
msgid ""
"importlib.abc.Loader.create_module(spec) (optional) will return the "
"module to use for loading."
msgstr ""

#: ../../peps/pep-0451.rst:300
msgid "For modules:"
msgstr ""

#: ../../peps/pep-0451.rst:302
msgid "Module objects will have a new attribute: ``__spec__``."
msgstr ""

#: ../../peps/pep-0451.rst:305
msgid "API Changes"
msgstr ""

#: ../../peps/pep-0451.rst:307
msgid "InspectLoader.is_package() will become optional."
msgstr ""

#: ../../peps/pep-0451.rst:310
msgid "Deprecations"
msgstr ""

#: ../../peps/pep-0451.rst:312
msgid "importlib.abc.MetaPathFinder.find_module()"
msgstr ""

#: ../../peps/pep-0451.rst:313
msgid "importlib.abc.PathEntryFinder.find_module()"
msgstr ""

#: ../../peps/pep-0451.rst:314
msgid "importlib.abc.PathEntryFinder.find_loader()"
msgstr ""

#: ../../peps/pep-0451.rst:315
msgid "importlib.abc.Loader.load_module()"
msgstr ""

#: ../../peps/pep-0451.rst:316
msgid "importlib.abc.Loader.module_repr()"
msgstr ""

#: ../../peps/pep-0451.rst:317
msgid "importlib.util.set_package()"
msgstr ""

#: ../../peps/pep-0451.rst:318
msgid "importlib.util.set_loader()"
msgstr ""

#: ../../peps/pep-0451.rst:319
msgid "importlib.find_loader()"
msgstr ""

#: ../../peps/pep-0451.rst:322
msgid "Removals"
msgstr ""

#: ../../peps/pep-0451.rst:324
msgid ""
"These were introduced prior to Python 3.4's release, so they can simply "
"be removed."
msgstr ""

#: ../../peps/pep-0451.rst:327
msgid "importlib.abc.Loader.init_module_attrs()"
msgstr ""

#: ../../peps/pep-0451.rst:328
msgid "importlib.util.module_to_load()"
msgstr ""

#: ../../peps/pep-0451.rst:331 ../../peps/pep-0451.rst:829
msgid "Other Changes"
msgstr ""

#: ../../peps/pep-0451.rst:333
msgid ""
"The import system implementation in importlib will be changed to make use"
" of ModuleSpec."
msgstr ""

#: ../../peps/pep-0451.rst:335
msgid "importlib.reload() will make use of ModuleSpec."
msgstr ""

#: ../../peps/pep-0451.rst:336
msgid ""
"A module's import-related attributes (other than ``__spec__``) will no "
"longer be used directly by the import system during that module's import."
"  However, this does not impact use of those attributes (e.g. "
"``__path__``) when loading other modules (e.g. submodules)."
msgstr ""

#: ../../peps/pep-0451.rst:340
msgid ""
"Import-related attributes should no longer be added to modules directly, "
"except by the import system."
msgstr ""

#: ../../peps/pep-0451.rst:342
msgid ""
"The module type's ``__repr__()`` will be a thin wrapper around a pure "
"Python implementation which will leverage ModuleSpec."
msgstr ""

#: ../../peps/pep-0451.rst:344
msgid ""
"The spec for the ``__main__`` module will reflect the appropriate name "
"and origin."
msgstr ""

#: ../../peps/pep-0451.rst:348
msgid "Backward-Compatibility"
msgstr ""

#: ../../peps/pep-0451.rst:350
msgid ""
"If a finder does not define find_spec(), a spec is derived from the "
"loader returned by find_module()."
msgstr ""

#: ../../peps/pep-0451.rst:352
msgid "PathEntryFinder.find_loader() still takes priority over find_module()."
msgstr ""

#: ../../peps/pep-0451.rst:354
msgid "Loader.load_module() is used if exec_module() is not defined."
msgstr ""

#: ../../peps/pep-0451.rst:357
msgid "What Will not Change?"
msgstr ""

#: ../../peps/pep-0451.rst:359
msgid "The syntax and semantics of the import statement."
msgstr ""

#: ../../peps/pep-0451.rst:360
msgid "Existing finders and loaders will continue to work normally."
msgstr ""

#: ../../peps/pep-0451.rst:361
msgid ""
"The import-related module attributes will still be initialized with the "
"same information."
msgstr ""

#: ../../peps/pep-0451.rst:363
msgid "Finders will still create loaders (now storing them in specs)."
msgstr ""

#: ../../peps/pep-0451.rst:364
msgid ""
"Loader.load_module(), if a module defines it, will have all the same "
"requirements and may still be called directly."
msgstr ""

#: ../../peps/pep-0451.rst:366
msgid "Loaders will still be responsible for module data APIs."
msgstr ""

#: ../../peps/pep-0451.rst:367
msgid "importlib.reload() will still overwrite the import-related attributes."
msgstr ""

#: ../../peps/pep-0451.rst:370
msgid "Responsibilities"
msgstr ""

#: ../../peps/pep-0451.rst:372
msgid "Here's a quick breakdown of where responsibilities lie after this PEP."
msgstr ""

#: ../../peps/pep-0451.rst:374
msgid "finders:"
msgstr ""

#: ../../peps/pep-0451.rst:376
msgid "create/identify a loader that can load the module."
msgstr ""

#: ../../peps/pep-0451.rst:377
msgid "create the spec for the module."
msgstr ""

#: ../../peps/pep-0451.rst:379
msgid "loaders:"
msgstr ""

#: ../../peps/pep-0451.rst:381
msgid "create the module (optional)."
msgstr ""

#: ../../peps/pep-0451.rst:382
msgid "execute the module."
msgstr ""

#: ../../peps/pep-0451.rst:384
msgid "ModuleSpec:"
msgstr ""

#: ../../peps/pep-0451.rst:386
msgid "orchestrate module loading"
msgstr ""

#: ../../peps/pep-0451.rst:387
msgid ""
"boilerplate for module loading, including managing sys.modules and "
"setting import-related attributes"
msgstr ""

#: ../../peps/pep-0451.rst:389
msgid "create module if loader doesn't"
msgstr ""

#: ../../peps/pep-0451.rst:390
msgid "call loader.exec_module(), passing in the module in which to exec"
msgstr ""

#: ../../peps/pep-0451.rst:391
msgid "contain all the information the loader needs to exec the module"
msgstr ""

#: ../../peps/pep-0451.rst:392
msgid "provide the repr for modules"
msgstr ""

#: ../../peps/pep-0451.rst:396
msgid "What Will Existing Finders and Loaders Have to Do Differently?"
msgstr ""

#: ../../peps/pep-0451.rst:398
msgid ""
"Immediately?  Nothing.  The status quo will be deprecated, but will "
"continue working.  However, here are the things that the authors of "
"finders and loaders should change relative to this PEP:"
msgstr ""

#: ../../peps/pep-0451.rst:402
msgid "Implement find_spec() on finders."
msgstr ""

#: ../../peps/pep-0451.rst:403
msgid "Implement exec_module() on loaders, if possible."
msgstr ""

#: ../../peps/pep-0451.rst:405
msgid ""
"The ModuleSpec factory functions in importlib.util are intended to be "
"helpful for converting existing finders.  spec_from_loader() and "
"spec_from_file_location() are both straightforward utilities in this "
"regard."
msgstr ""

#: ../../peps/pep-0451.rst:410
msgid ""
"For existing loaders, exec_module() should be a relatively direct "
"conversion from the non-boilerplate portion of load_module().  In some "
"uncommon cases the loader should also implement create_module()."
msgstr ""

#: ../../peps/pep-0451.rst:416
msgid "ModuleSpec Users"
msgstr ""

#: ../../peps/pep-0451.rst:418
msgid ""
"ModuleSpec objects have 3 distinct target audiences: Python itself, "
"import hooks, and normal Python users."
msgstr ""

#: ../../peps/pep-0451.rst:421
msgid ""
"Python will use specs in the import machinery, in interpreter startup, "
"and in various standard library modules.  Some modules are import-"
"oriented, like pkgutil, and others are not, like pickle and pydoc.  In "
"all cases, the full ModuleSpec API will get used."
msgstr ""

#: ../../peps/pep-0451.rst:426
msgid ""
"Import hooks (finders and loaders) will make use of the spec in specific "
"ways.  First of all, finders may use the spec factory functions in "
"importlib.util to create spec objects.  They may also directly adjust the"
" spec attributes after the spec is created.  Secondly, the finder may "
"bind additional information to the spec (in finder_extras) for the loader"
" to consume during module creation/execution.  Finally, loaders will make"
" use of the attributes on a spec when creating and/or executing a module."
msgstr ""

#: ../../peps/pep-0451.rst:435
msgid ""
"Python users will be able to inspect a module's ``__spec__`` to get "
"import-related information about the object.  Generally, Python "
"applications and interactive users will not be using the ``ModuleSpec`` "
"factory functions nor any the instance methods."
msgstr ""

#: ../../peps/pep-0451.rst:442
msgid "How Loading Will Work"
msgstr ""

#: ../../peps/pep-0451.rst:444
msgid ""
"Here is an outline of what the import machinery does during loading, "
"adjusted to take advantage of the module's spec and the new loader API::"
msgstr ""

#: ../../peps/pep-0451.rst:475
msgid ""
"These steps are exactly what Loader.load_module() is already expected to "
"do.  Loaders will thus be simplified since they will only need to "
"implement exec_module()."
msgstr ""

#: ../../peps/pep-0451.rst:479
msgid ""
"Note that we must return the module from sys.modules.  During loading the"
" module may have replaced itself in sys.modules.  Since we don't have a "
"post-import hook API to accommodate the use case, we have to deal with "
"it.  However, in the replacement case we do not worry about setting the "
"import-related module attributes on the object.  The module writer is on "
"their own if they are doing this."
msgstr ""

#: ../../peps/pep-0451.rst:488
msgid "How Reloading Will Work"
msgstr ""

#: ../../peps/pep-0451.rst:490
msgid "Here is the corresponding outline for reload()::"
msgstr ""

#: ../../peps/pep-0451.rst:522
msgid ""
"A key point here is the switch to Loader.exec_module() means that loaders"
" will no longer have an easy way to know at execution time if it is a "
"reload or not.  Before this proposal, they could simply check to see if "
"the module was already in sys.modules.  Now, by the time exec_module() is"
" called during load (not reload) the import machinery would already have "
"placed the module in sys.modules.  This is part of the reason why "
"find_spec() has `the \"target\" parameter <The \"target\" parameter of "
"find_spec()>`_."
msgstr ""

#: ../../peps/pep-0451.rst:531
msgid ""
"The semantics of reload will remain essentially the same as they exist "
"already [#reload-semantics-fix]_.  The impact of this PEP on some kinds "
"of lazy loading modules was a point of discussion. "
"[#lazy_import_concerns]_"
msgstr ""

#: ../../peps/pep-0451.rst:537
msgid "ModuleSpec"
msgstr ""

#: ../../peps/pep-0451.rst:540
msgid "Attributes"
msgstr ""

#: ../../peps/pep-0451.rst:542
msgid ""
"Each of the following names is an attribute on ModuleSpec objects.  A "
"value of None indicates \"not set\".  This contrasts with module objects "
"where the attribute simply doesn't exist.  Most of the attributes "
"correspond to the import-related attributes of modules.  Here is the "
"mapping.  The reverse of this mapping describes how the import machinery "
"sets the module attributes right before calling exec_module()."
msgstr ""

#: ../../peps/pep-0451.rst:550
msgid "On ModuleSpec"
msgstr ""

#: ../../peps/pep-0451.rst:550
msgid "On Modules"
msgstr ""

#: ../../peps/pep-0451.rst:552
msgid "__name__"
msgstr ""

#: ../../peps/pep-0451.rst:553
msgid "__loader__"
msgstr ""

#: ../../peps/pep-0451.rst:554
msgid "parent"
msgstr ""

#: ../../peps/pep-0451.rst:554
msgid "__package__"
msgstr ""

#: ../../peps/pep-0451.rst:555
msgid "__file__*"
msgstr ""

#: ../../peps/pep-0451.rst:556
msgid "cached"
msgstr ""

#: ../../peps/pep-0451.rst:556
msgid "__cached__*,**"
msgstr ""

#: ../../peps/pep-0451.rst:557
msgid "submodule_search_locations"
msgstr ""

#: ../../peps/pep-0451.rst:557
msgid "__path__**"
msgstr ""

#: ../../peps/pep-0451.rst:558
msgid "loader_state"
msgstr ""

#: ../../peps/pep-0451.rst:558 ../../peps/pep-0451.rst:559
msgid "\\-"
msgstr ""

#: ../../peps/pep-0451.rst:559
msgid "has_location"
msgstr ""

#: ../../peps/pep-0451.rst:562
msgid "\\* Set on the module only if spec.has_location is true."
msgstr ""

#: ../../peps/pep-0451.rst:563
msgid "\\*\\* Set on the module only if the spec attribute is not None."
msgstr ""

#: ../../peps/pep-0451.rst:565
msgid ""
"While parent and has_location are read-only properties, the remaining "
"attributes can be replaced after the module spec is created and even "
"after import is complete.  This allows for unusual cases where directly "
"modifying the spec is the best option.  However, typical use should not "
"involve changing the state of a module's spec."
msgstr ""

#: ../../peps/pep-0451.rst:571
msgid "**origin**"
msgstr ""

#: ../../peps/pep-0451.rst:573
msgid ""
"\"origin\" is a string for the name of the place from which the module "
"originates.  See `origin`_ above.  Aside from the informational value, it"
" is also used in the module's repr.  In the case of a spec where "
"\"has_location\" is true, ``__file__`` is set to the value of \"origin\"."
" For built-in modules \"origin\" would be set to \"built-in\"."
msgstr ""

#: ../../peps/pep-0451.rst:579
msgid "**has_location**"
msgstr ""

#: ../../peps/pep-0451.rst:581
msgid ""
"As explained in the `location`_ section above, many modules are "
"\"locatable\", meaning there is a corresponding resource from which the "
"module will be loaded and that resource can be described by a string. In "
"contrast, non-locatable modules can't be loaded in this fashion, e.g. "
"builtin modules and modules dynamically created in code.  For these, the "
"name is the only way to access them, so they have an \"origin\" but not a"
" \"location\"."
msgstr ""

#: ../../peps/pep-0451.rst:589
msgid ""
"\"has_location\" is true if the module is locatable.  In that case the "
"spec's origin is used as the location and ``__file__`` is set to "
"spec.origin.  If additional location information is required (e.g. "
"zipimport), that information may be stored in spec.loader_state."
msgstr ""

#: ../../peps/pep-0451.rst:594
msgid ""
"\"has_location\" may be implied from the existence of a load_data() "
"method on the loader."
msgstr ""

#: ../../peps/pep-0451.rst:597
msgid "Incidentally, not all locatable modules will be cache-able, but most will."
msgstr ""

#: ../../peps/pep-0451.rst:600
msgid "**submodule_search_locations**"
msgstr ""

#: ../../peps/pep-0451.rst:602
msgid ""
"The list of location strings, typically directory paths, in which to "
"search for submodules.  If the module is a package this will be set to a "
"list (even an empty one).  Otherwise it is None."
msgstr ""

#: ../../peps/pep-0451.rst:606
msgid ""
"The name of the corresponding module attribute, ``__path__``, is "
"relatively ambiguous.  Instead of mirroring it, we use a more explicit "
"attribute name that makes the purpose clear."
msgstr ""

#: ../../peps/pep-0451.rst:610
msgid "**loader_state**"
msgstr ""

#: ../../peps/pep-0451.rst:612
msgid ""
"A finder may set loader_state to any value to provide additional data for"
" the loader to use during loading.  A value of None is the default and "
"indicates that there is no additional data.  Otherwise it can be set to "
"any object, such as a dict, list, or types.SimpleNamespace, containing "
"the relevant extra information."
msgstr ""

#: ../../peps/pep-0451.rst:618
msgid ""
"For example, zipimporter could use it to pass the zip archive name to the"
" loader directly, rather than needing to derive it from origin or create "
"a custom loader for each find operation."
msgstr ""

#: ../../peps/pep-0451.rst:622
msgid ""
"loader_state is meant for use by the finder and corresponding loader. It "
"is not guaranteed to be a stable resource for any other use."
msgstr ""

#: ../../peps/pep-0451.rst:626
msgid "Factory Functions"
msgstr ""

#: ../../peps/pep-0451.rst:628
msgid ""
"**spec_from_file_location(name, location, \\*, loader=None, "
"submodule_search_locations=None)**"
msgstr ""

#: ../../peps/pep-0451.rst:630
msgid "Build a spec from file-oriented information and loader APIs."
msgstr ""

#: ../../peps/pep-0451.rst:632
msgid "\"origin\" will be set to the location."
msgstr ""

#: ../../peps/pep-0451.rst:633
msgid "\"has_location\" will be set to True."
msgstr ""

#: ../../peps/pep-0451.rst:634
msgid "\"cached\" will be set to the result of calling cache_from_source()."
msgstr ""

#: ../../peps/pep-0451.rst:636
msgid ""
"\"origin\" can be deduced from loader.get_filename() (if \"location\" is "
"not passed in."
msgstr ""

#: ../../peps/pep-0451.rst:638
msgid "\"loader\" can be deduced from suffix if the location is a filename."
msgstr ""

#: ../../peps/pep-0451.rst:639 ../../peps/pep-0451.rst:648
msgid ""
"\"submodule_search_locations\" can be deduced from loader.is_package() "
"and from os.path.dirname(location) if location is a filename."
msgstr ""

#: ../../peps/pep-0451.rst:642
msgid "**spec_from_loader(name, loader, \\*, origin=None, is_package=None)**"
msgstr ""

#: ../../peps/pep-0451.rst:644
msgid "Build a spec with missing information filled in by using loader APIs."
msgstr ""

#: ../../peps/pep-0451.rst:646
msgid "\"has_location\" can be deduced from loader.get_data."
msgstr ""

#: ../../peps/pep-0451.rst:647
msgid "\"origin\" can be deduced from loader.get_filename()."
msgstr ""

#: ../../peps/pep-0451.rst:652
msgid "Backward Compatibility"
msgstr ""

#: ../../peps/pep-0451.rst:654
msgid ""
"ModuleSpec doesn't have any.  This would be a different story if "
"Finder.find_module() were to return a module spec instead of loader. In "
"that case, specs would have to act like the loader that would have been "
"returned instead.  Doing so would be relatively simple, but is an "
"unnecessary complication.  It was part of earlier versions of this PEP."
msgstr ""

#: ../../peps/pep-0451.rst:661
msgid "Subclassing"
msgstr ""

#: ../../peps/pep-0451.rst:663
msgid ""
"Subclasses of ModuleSpec are allowed, but should not be necessary. Simply"
" setting loader_state or adding functionality to a custom finder or "
"loader will likely be a better fit and should be tried first. However, as"
" long as a subclass still fulfills the requirements of the import system,"
" objects of that type are completely fine as the return value of "
"Finder.find_spec().  The same points apply to duck-typing."
msgstr ""

#: ../../peps/pep-0451.rst:672
msgid "Existing Types"
msgstr ""

#: ../../peps/pep-0451.rst:675
msgid "Module Objects"
msgstr ""

#: ../../peps/pep-0451.rst:677
msgid ""
"Other than adding ``__spec__``, none of the import-related module "
"attributes will be changed or deprecated, though some of them could be; "
"any such deprecation can wait until Python 4."
msgstr ""

#: ../../peps/pep-0451.rst:681
msgid ""
"A module's spec will not be kept in sync with the corresponding import-"
"related attributes.  Though they may differ, in practice they will "
"typically be the same."
msgstr ""

#: ../../peps/pep-0451.rst:685
msgid ""
"One notable exception is that case where a module is run as a script by "
"using the ``-m`` flag.  In that case ``module.__spec__.name`` will "
"reflect the actual module name while ``module.__name__`` will be "
"``__main__``."
msgstr ""

#: ../../peps/pep-0451.rst:690
msgid ""
"A module's spec is not guaranteed to be identical between two modules "
"with the same name.  Likewise there is no guarantee that successive calls"
" to importlib.find_spec() will return the same object or even an "
"equivalent object, though at least the latter is likely."
msgstr ""

#: ../../peps/pep-0451.rst:696
msgid "Finders"
msgstr ""

#: ../../peps/pep-0451.rst:698
msgid ""
"Finders are still responsible for identifying, and typically creating, "
"the loader that should be used to load a module.  That loader will now be"
" stored in the module spec returned by find_spec() rather than returned "
"directly.  As is currently the case without the PEP, if a loader would be"
" costly to create, that loader can be designed to defer the cost until "
"later."
msgstr ""

#: ../../peps/pep-0451.rst:705
msgid "**MetaPathFinder.find_spec(name, path=None, target=None)**"
msgstr ""

#: ../../peps/pep-0451.rst:707
msgid "**PathEntryFinder.find_spec(name, target=None)**"
msgstr ""

#: ../../peps/pep-0451.rst:709
msgid ""
"Finders must return ModuleSpec objects when find_spec() is called.  This "
"new method replaces find_module() and find_loader() (in the "
"PathEntryFinder case).  If a loader does not have find_spec(), "
"find_module() and find_loader() are used instead, for backward-"
"compatibility."
msgstr ""

#: ../../peps/pep-0451.rst:715
msgid ""
"Adding yet another similar method to loaders is a case of practicality. "
"find_module() could be changed to return specs instead of loaders. This "
"is tempting because the import APIs have suffered enough, especially "
"considering PathEntryFinder.find_loader() was just added in Python 3.3.  "
"However, the extra complexity and a less-than-explicit method name aren't"
" worth it."
msgstr ""

#: ../../peps/pep-0451.rst:723
msgid "The \"target\" parameter of find_spec()"
msgstr ""

#: ../../peps/pep-0451.rst:725
msgid ""
"A call to find_spec() may optionally include a \"target\" argument.  This"
" is the module object that will be used subsequently as the target of "
"loading.  During normal import (and by default) \"target\" is None, "
"meaning the target module has yet to be created.  During reloading the "
"module passed in to reload() is passed through to find_spec() as the "
"target.  This argument allows the finder to build the module spec with "
"more information than is otherwise available.  Doing so is particularly "
"relevant in identifying the loader to use."
msgstr ""

#: ../../peps/pep-0451.rst:734
msgid ""
"Through find_spec() the finder will always identify the loader it will "
"return in the spec (or return None).  At the point the loader is "
"identified, the finder should also decide whether or not the loader "
"supports loading into the target module, in the case that \"target\" is "
"passed in.  This decision may entail consulting with the loader."
msgstr ""

#: ../../peps/pep-0451.rst:740
msgid ""
"If the finder determines that the loader does not support loading into "
"the target module, it should either find another loader or raise "
"ImportError (completely stopping import of the module).  This "
"determination is especially important during reload since, as noted in "
"`How Reloading Will Work`_, loaders will no longer be able to trivially "
"identify a reload situation on their own."
msgstr ""

#: ../../peps/pep-0451.rst:747
msgid ""
"Two alternatives were presented to the \"target\" parameter: "
"Loader.supports_reload() and adding \"target\" to Loader.exec_module() "
"instead of find_spec().  supports_reload() was the initial approach to "
"the reload situation. [#supports_reload]_  However, there was some "
"opposition to the loader-specific, reload-centric approach. "
"[#supports_reload_considered_harmful]_"
msgstr ""

#: ../../peps/pep-0451.rst:754
msgid ""
"As to \"target\" on exec_module(), the loader may need other information "
"from the target module (or spec) during reload, more than just \"does "
"this loader support reloading this module\", that is no longer available "
"with the move away from load_module().  A proposal on the table was to "
"add something like \"target\" to exec_module().  [#exec_module_target]_ "
"However, putting \"target\" on find_spec() instead is more in line with "
"the goals of this PEP.  Furthermore, it obviates the need for "
"supports_reload()."
msgstr ""

#: ../../peps/pep-0451.rst:764
msgid "Namespace Packages"
msgstr ""

#: ../../peps/pep-0451.rst:766
msgid ""
"Currently a path entry finder may return (None, portions) from "
"find_loader() to indicate it found part of a possible namespace package."
"  To achieve the same effect, find_spec() must return a spec with "
"\"loader\" set to None (a.k.a. not set) and with "
"submodule_search_locations set to the same portions as would have been "
"provided by find_loader().  It's up to PathFinder how to handle such "
"specs."
msgstr ""

#: ../../peps/pep-0451.rst:775
msgid "Loaders"
msgstr ""

#: ../../peps/pep-0451.rst:777
msgid "**Loader.exec_module(module)**"
msgstr ""

#: ../../peps/pep-0451.rst:779
msgid ""
"Loaders will have a new method, exec_module().  Its only job is to "
"\"exec\" the module and consequently populate the module's namespace.  It"
" is not responsible for creating or preparing the module object, nor for "
"any cleanup afterward.  It has no return value. exec_module() will be "
"used during both loading and reloading."
msgstr ""

#: ../../peps/pep-0451.rst:785
msgid ""
"exec_module() should properly handle the case where it is called more "
"than once.  For some kinds of modules this may mean raising ImportError "
"every time after the first time the method is called.  This is "
"particularly relevant for reloading, where some kinds of modules do not "
"support in-place reloading."
msgstr ""

#: ../../peps/pep-0451.rst:791
msgid "**Loader.create_module(spec)**"
msgstr ""

#: ../../peps/pep-0451.rst:793
msgid ""
"Loaders may also implement create_module() that will return a new module "
"to exec.  It may return None to indicate that the default module creation"
" code should be used.  One use case, though atypical, for create_module()"
" is to provide a module that is a subclass of the builtin module type.  "
"Most loaders will not need to implement create_module(),"
msgstr ""

#: ../../peps/pep-0451.rst:799
msgid ""
"create_module() should properly handle the case where it is called more "
"than once for the same spec/module.  This may include returning None or "
"raising ImportError."
msgstr ""

#: ../../peps/pep-0451.rst:805
msgid ""
"exec_module() and create_module() should not set any import-related "
"module attributes.  The fact that load_module() does is a design flaw "
"that this proposal aims to correct."
msgstr ""

#: ../../peps/pep-0451.rst:809
msgid "Other changes:"
msgstr ""

#: ../../peps/pep-0451.rst:811
msgid ""
":pep:`420` introduced the optional module_repr() loader method to limit "
"the amount of special-casing in the module type's ``__repr__()``.  Since "
"this method is part of ModuleSpec, it will be deprecated on loaders. "
"However, if it exists on a loader it will be used exclusively."
msgstr ""

#: ../../peps/pep-0451.rst:816
msgid ""
"Loader.init_module_attr() method, added prior to Python 3.4's release, "
"will be removed in favor of the same method on ModuleSpec."
msgstr ""

#: ../../peps/pep-0451.rst:819
msgid ""
"However, InspectLoader.is_package() will not be deprecated even though "
"the same information is found on ModuleSpec.  ModuleSpec can use it to "
"populate its own is_package if that information is not otherwise "
"available.  Still, it will be made optional."
msgstr ""

#: ../../peps/pep-0451.rst:824
msgid ""
"In addition to executing a module during loading, loaders will still be "
"directly responsible for providing APIs concerning module-related data."
msgstr ""

#: ../../peps/pep-0451.rst:831
msgid ""
"The various finders and loaders provided by importlib will be updated to "
"comply with this proposal."
msgstr ""

#: ../../peps/pep-0451.rst:833
msgid ""
"Any other implementations of or dependencies on the import-related APIs "
"(particularly finders and loaders) in the stdlib will be likewise "
"adjusted to this PEP.  While they should continue to work, any such "
"changes that get missed should be considered bugs for the Python 3.4.x "
"series."
msgstr ""

#: ../../peps/pep-0451.rst:838
msgid ""
"The spec for the ``__main__`` module will reflect how the interpreter was"
" started.  For instance, with ``-m`` the spec's name will be that of the "
"module used, while ``__main__.__name__`` will still be \"__main__\"."
msgstr ""

#: ../../peps/pep-0451.rst:842
msgid ""
"We will add importlib.find_spec() to mirror importlib.find_loader() "
"(which becomes deprecated)."
msgstr ""

#: ../../peps/pep-0451.rst:844
msgid "importlib.reload() is changed to use ModuleSpec."
msgstr ""

#: ../../peps/pep-0451.rst:845
msgid "importlib.reload() will now make use of the per-module import lock."
msgstr ""

#: ../../peps/pep-0451.rst:849
msgid "Reference Implementation"
msgstr ""

#: ../../peps/pep-0451.rst:851
msgid ""
"A reference implementation is available at "
"http://bugs.python.org/issue18864."
msgstr ""

#: ../../peps/pep-0451.rst:855
msgid "Implementation Notes"
msgstr ""

#: ../../peps/pep-0451.rst:857
msgid ""
"\\* The implementation of this PEP needs to be cognizant of its impact on"
" pkgutil (and setuptools).  pkgutil has some generic function-based "
"extensions to :pep:`302` which may break if importlib starts wrapping "
"loaders without the tools' knowledge."
msgstr ""

#: ../../peps/pep-0451.rst:862
msgid ""
"\\* Other modules to look at: runpy (and pythonrun.c), pickle, pydoc, "
"inspect."
msgstr ""

#: ../../peps/pep-0451.rst:865
msgid ""
"For instance, pickle should be updated in the ``__main__`` case to look "
"at ``module.__spec__.name``."
msgstr ""

#: ../../peps/pep-0451.rst:870
msgid "Rejected Additions to the PEP"
msgstr ""

#: ../../peps/pep-0451.rst:872
msgid ""
"There were a few proposed additions to this proposal that did not fit "
"well enough into its scope."
msgstr ""

#: ../../peps/pep-0451.rst:875
msgid ""
"There is no \"PathModuleSpec\" subclass of ModuleSpec that separates out "
"has_location, cached, and submodule_search_locations.  While that might "
"make the separation cleaner, module objects don't have that distinction. "
"ModuleSpec will support both cases equally well."
msgstr ""

#: ../../peps/pep-0451.rst:880
msgid ""
"While \"ModuleSpec.is_package\" would be a simple additional attribute "
"(aliasing self.submodule_search_locations is not None), it perpetuates "
"the artificial (and mostly erroneous) distinction between modules and "
"packages."
msgstr ""

#: ../../peps/pep-0451.rst:885
msgid ""
"The module spec `Factory Functions`_ could be classmethods on ModuleSpec."
"  However that would expose them on *all* modules via ``__spec__``, which"
" has the potential to unnecessarily confuse non-advanced Python users.  "
"The factory functions have a specific use case, to support finder "
"authors.  See `ModuleSpec Users`_."
msgstr ""

#: ../../peps/pep-0451.rst:891
msgid ""
"Likewise, several other methods could be added to ModuleSpec that expose "
"the specific uses of module specs by the import machinery:"
msgstr ""

#: ../../peps/pep-0451.rst:894
msgid "create() - a wrapper around Loader.create_module()."
msgstr ""

#: ../../peps/pep-0451.rst:895
msgid "exec(module) - a wrapper around Loader.exec_module()."
msgstr ""

#: ../../peps/pep-0451.rst:896
msgid "load() - an analogue to the deprecated Loader.load_module()."
msgstr ""

#: ../../peps/pep-0451.rst:898
msgid ""
"As with the factory functions, exposing these methods via module.__spec__"
" is less than desirable.  They would end up being an attractive nuisance,"
" even if only exposed as \"private\" attributes (as they were in previous"
" versions of this PEP).  If someone finds a need for these methods later,"
" we can expose the via an appropriate API (separate from ModuleSpec) at "
"that point, perhaps relative to :pep:`406` (import engine)."
msgstr ""

#: ../../peps/pep-0451.rst:906
msgid ""
"Conceivably, the load() method could optionally take a list of modules "
"with which to interact instead of sys.modules.  Also, load() could be "
"leveraged to implement multi-version imports.  Both are interesting "
"ideas, but definitely outside the scope of this proposal."
msgstr ""

#: ../../peps/pep-0451.rst:911
msgid "Others left out:"
msgstr ""

#: ../../peps/pep-0451.rst:913
msgid ""
"Add ModuleSpec.submodules (RO-property) - returns possible submodules "
"relative to the spec."
msgstr ""

#: ../../peps/pep-0451.rst:915
msgid "Add ModuleSpec.loaded (RO-property) - the module in sys.module, if any."
msgstr ""

#: ../../peps/pep-0451.rst:917
msgid ""
"Add ModuleSpec.data - a descriptor that wraps the data API of the spec's "
"loader."
msgstr ""

#: ../../peps/pep-0451.rst:919
msgid "Also see [#cleaner_reload_support]_."
msgstr ""

#: ../../peps/pep-0451.rst:923
msgid "References"
msgstr "Referências"

#: ../../peps/pep-0451.rst:926
msgid "https://mail.python.org/pipermail/import-sig/2013-August/000658.html"
msgstr ""

#: ../../peps/pep-0451.rst:928
msgid "http://docs.python.org/3/reference/import.html"
msgstr ""

#: ../../peps/pep-0451.rst:931
msgid "https://mail.python.org/pipermail/import-sig/2013-September/000735.html"
msgstr ""

#: ../../peps/pep-0451.rst:934
msgid "https://mail.python.org/pipermail/python-dev/2013-August/128129.html"
msgstr ""

#: ../../peps/pep-0451.rst:936
msgid "http://bugs.python.org/issue19413"
msgstr ""

#: ../../peps/pep-0451.rst:939
msgid "https://mail.python.org/pipermail/python-dev/2013-October/129913.html"
msgstr ""

#: ../../peps/pep-0451.rst:941
msgid "https://mail.python.org/pipermail/python-dev/2013-October/129971.html"
msgstr ""

#: ../../peps/pep-0451.rst:944
msgid "https://mail.python.org/pipermail/python-dev/2013-October/129933.html"
msgstr ""

#: ../../peps/pep-0451.rst:947
msgid "Copyright"
msgstr "Copyright"

#: ../../peps/pep-0451.rst:949
msgid "This document has been placed in the public domain."
msgstr "Este documento foi colocado em domínio público."

#~ msgid "Brett Cannon <brett@python.org>, Nick Coghlan <ncoghlan@gmail.com>"
#~ msgstr ""

#~ msgid ""
#~ "A module's spec will not be kept"
#~ " in sync with the corresponding "
#~ "import- related attributes.  Though they "
#~ "may differ, in practice they will "
#~ "typically be the same."
#~ msgstr ""

#~ msgid ""
#~ "Adding yet another similar method to "
#~ "loaders is a case of practicality. "
#~ "find_module() could be changed to return"
#~ " specs instead of loaders. This is"
#~ " tempting because the import APIs "
#~ "have suffered enough, especially considering"
#~ " PathEntryFinder.find_loader() was just added "
#~ "in Python 3.3.  However, the extra "
#~ "complexity and a less-than- explicit "
#~ "method name aren't worth it."
#~ msgstr ""

